diff -rupN ./linux-3.10.32/arch/arm/mach-mvebu/armada-370-xp.c linux-3.10.32.switch/arch/arm/mach-mvebu/armada-370-xp.c
--- ./linux-3.10.32/arch/arm/mach-mvebu/armada-370-xp.c	2014-04-01 23:34:20.599202147 +0700
+++ linux-3.10.32.switch/arch/arm/mach-mvebu/armada-370-xp.c	2014-04-01 18:21:56.000000000 +0700
@@ -30,9 +30,20 @@
 #include "common.h"
 #include "coherency.h"
 
+static struct map_desc armada_370_xp_io_desc[] __initdata = {
+	{
+		.virtual	= (unsigned long) ARMADA_370_XP_REGS_VIRT_BASE,
+		.pfn		= __phys_to_pfn(ARMADA_370_XP_REGS_PHYS_BASE),
+		.length		= ARMADA_370_XP_REGS_SIZE,
+		.type		= MT_DEVICE,
+	},
+};
 static void __init armada_370_xp_map_io(void)
 {
-	debug_ll_io_init();
+	unsigned long of;
+	iotable_init(armada_370_xp_io_desc, ARRAY_SIZE(armada_370_xp_io_desc));
+	of =*((unsigned long *) (ARMADA_370_XP_INTER_REGS_BASE+0x72c00));
+	printk(KERN_ERR "reg = %lx\n", of);
 }
 
 static void __init armada_370_xp_timer_and_clk_init(void)
diff -rupN ./linux-3.10.32/arch/arm/mach-mvebu/armada-370-xp.h linux-3.10.32.switch/arch/arm/mach-mvebu/armada-370-xp.h
--- ./linux-3.10.32/arch/arm/mach-mvebu/armada-370-xp.h	2014-04-01 23:34:21.903202119 +0700
+++ linux-3.10.32.switch/arch/arm/mach-mvebu/armada-370-xp.h	2014-04-01 18:05:18.000000000 +0700
@@ -15,6 +15,22 @@
 #ifndef __MACH_ARMADA_370_XP_H
 #define __MACH_ARMADA_370_XP_H
 
+#if 0
+#define ARMADA_370_XP_REGS_PHYS_BASE	0xd0000000
+#define ARMADA_370_XP_REGS_VIRT_BASE	IOMEM(0xfec00000)
+#define ARMADA_370_XP_REGS_SIZE		SZ_1M
+#else
+#define ARMADA_370_XP_REGS_PHYS_BASE	0xf1000000
+#define ARMADA_370_XP_REGS_VIRT_BASE	IOMEM(0xfbc00000)
+#define ARMADA_370_XP_INTER_REGS_BASE	0xfbc00000
+#define ARMADA_370_XP_REGS_SIZE		SZ_1M
+#endif
+
+/* These defines can go away once mvebu-mbus has a DT binding */
+#define ARMADA_370_XP_MBUS_WINS_BASE    (ARMADA_370_XP_REGS_PHYS_BASE + 0x20000)
+#define ARMADA_370_XP_MBUS_WINS_SIZE    0x100
+#define ARMADA_370_XP_SDRAM_WINS_BASE   (ARMADA_370_XP_REGS_PHYS_BASE + 0x20180)
+#define ARMADA_370_XP_SDRAM_WINS_SIZE   0x20
 #ifdef CONFIG_SMP
 #include <linux/cpumask.h>
 
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/Makefile linux-3.10.32.switch/drivers/net/ethernet/marvell/Makefile
--- ./linux-3.10.32/drivers/net/ethernet/marvell/Makefile	2014-02-23 03:41:54.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/Makefile	2014-04-14 15:31:54.000000000 +0700
@@ -8,3 +8,4 @@ obj-$(CONFIG_MVNETA) += mvneta.o
 obj-$(CONFIG_PXA168_ETH) += pxa168_eth.o
 obj-$(CONFIG_SKGE) += skge.o
 obj-$(CONFIG_SKY2) += sky2.o
+obj-y				+= switch/
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/mvneta.c linux-3.10.32.switch/drivers/net/ethernet/marvell/mvneta.c
--- ./linux-3.10.32/drivers/net/ethernet/marvell/mvneta.c	2014-04-01 23:34:21.883202119 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/mvneta.c	2014-04-14 16:12:32.000000000 +0700
@@ -30,6 +30,9 @@
 #include <linux/phy.h>
 #include <linux/clk.h>
 
+//#include "switch/mvTypes.h"
+#include "switch/mv_switch.h"
+
 /* Registers */
 #define MVNETA_RXQ_CONFIG_REG(q)                (0x1400 + ((q) << 2))
 #define      MVNETA_RXQ_HW_BUF_ALLOC            BIT(1)
@@ -2799,6 +2802,8 @@ static int mvneta_probe(struct platform_
 	}
 	mvneta_port_power_up(pp, phy_mode);
 
+	mv_switch_init(1522, SWITCH_CONNECTED_PORTS_MASK);
+
 	dram_target_info = mv_mbus_dram_info();
 	if (dram_target_info)
 		mvneta_conf_mbus_windows(pp, dram_target_info);
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/common/mvTypes.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/common/mvTypes.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/common/mvTypes.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/common/mvTypes.h	2014-04-08 19:50:00.000000000 +0700
@@ -0,0 +1,270 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvTypesh
+#define __INCmvTypesh
+
+/* Defines */
+
+/* The following is a list of Marvell status    */
+#define MV_ERROR		    (-1)
+#define MV_OK			    (0)	/* Operation succeeded                   */
+#define MV_FAIL			    (1)	/* Operation failed                      */
+#define MV_BAD_VALUE        (2)	/* Illegal value (general)               */
+#define MV_OUT_OF_RANGE     (3)	/* The value is out of range             */
+#define MV_BAD_PARAM        (4)	/* Illegal parameter in function called  */
+#define MV_BAD_PTR          (5)	/* Illegal pointer value                 */
+#define MV_BAD_SIZE         (6)	/* Illegal size                          */
+#define MV_BAD_STATE        (7)	/* Illegal state of state machine        */
+#define MV_SET_ERROR        (8)	/* Set operation failed                  */
+#define MV_GET_ERROR        (9)	/* Get operation failed                  */
+#define MV_CREATE_ERROR     (10)	/* Fail while creating an item           */
+#define MV_NOT_FOUND        (11)	/* Item not found                        */
+#define MV_NO_MORE          (12)	/* No more items found                   */
+#define MV_NO_SUCH          (13)	/* No such item                          */
+#define MV_TIMEOUT          (14)	/* Time Out                              */
+#define MV_NO_CHANGE        (15)	/* Parameter(s) is already in this value */
+#define MV_NOT_SUPPORTED    (16)	/* This request is not support           */
+#define MV_NOT_IMPLEMENTED  (17)	/* Request supported but not implemented */
+#define MV_NOT_INITIALIZED  (18)	/* The item is not initialized           */
+#define MV_NO_RESOURCE      (19)	/* Resource not available (memory ...)   */
+#define MV_FULL             (20)	/* Item is full (Queue or table etc...)  */
+#define MV_EMPTY            (21)	/* Item is empty (Queue or table etc...) */
+#define MV_INIT_ERROR       (22)	/* Error occured while INIT process      */
+#define MV_HW_ERROR         (23)	/* Hardware error                        */
+#define MV_TX_ERROR         (24)	/* Transmit operation not succeeded      */
+#define MV_RX_ERROR         (25)	/* Recieve operation not succeeded       */
+#define MV_NOT_READY	    (26)	/* The other side is not ready yet       */
+#define MV_ALREADY_EXIST    (27)	/* Tried to create existing item         */
+#define MV_OUT_OF_CPU_MEM   (28)	/* Cpu memory allocation failed.         */
+#define MV_NOT_STARTED      (29)	/* Not started yet                       */
+#define MV_BUSY             (30)	/* Item is busy.                         */
+#define MV_TERMINATE        (31)	/* Item terminates it's work.            */
+#define MV_NOT_ALIGNED      (32)	/* Wrong alignment                       */
+#define MV_NOT_ALLOWED      (33)	/* Operation NOT allowed                 */
+#define MV_WRITE_PROTECT    (34)	/* Write protected                       */
+#define MV_DROPPED          (35)	/* Packet dropped                        */
+#define MV_STOLEN           (36)	/* Packet stolen */
+#define MV_CONTINUE         (37)        /* Continue */
+#define MV_RETRY		    (38)	/* Operation failed need retry           */
+
+#define MV_INVALID  (int)(-1)
+
+#define MV_FALSE	0
+#define MV_TRUE     (!(MV_FALSE))
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+#ifndef MV_ASMLANGUAGE
+/* typedefs */
+
+typedef char MV_8;
+typedef unsigned char MV_U8;
+
+typedef int MV_32;
+typedef unsigned int MV_U32;
+
+typedef short MV_16;
+typedef unsigned short MV_U16;
+
+#ifdef MV_PPC64
+typedef long MV_64;
+typedef unsigned long MV_U64;
+#else
+typedef long long MV_64;
+typedef unsigned long long MV_U64;
+#endif
+
+typedef long MV_LONG;		/* 32/64 */
+typedef unsigned long MV_ULONG;	/* 32/64 */
+
+typedef int MV_STATUS;
+typedef int MV_BOOL;
+typedef void MV_VOID;
+typedef float MV_FLOAT;
+
+typedef int (*MV_FUNCPTR) (void);	/* ptr to function returning int   */
+typedef void (*MV_VOIDFUNCPTR) (void);	/* ptr to function returning void  */
+typedef double (*MV_DBLFUNCPTR) (void);	/* ptr to function returning double */
+typedef float (*MV_FLTFUNCPTR) (void);	/* ptr to function returning float */
+
+typedef MV_U32 MV_KHZ;
+typedef MV_U32 MV_MHZ;
+typedef MV_U32 MV_HZ;
+
+/* This enumerator describes the set of commands that can be applied on   	*/
+/* an engine (e.g. IDMA, XOR). Appling a comman depends on the current   	*/
+/* status (see MV_STATE enumerator)                      					*/
+/* Start can be applied only when status is IDLE                         */
+/* Stop can be applied only when status is IDLE, ACTIVE or PAUSED        */
+/* Pause can be applied only when status is ACTIVE                          */
+/* Restart can be applied only when status is PAUSED                        */
+typedef enum _mvCommand {
+	MV_START,		/* Start     */
+	MV_STOP,		/* Stop     */
+	MV_PAUSE,		/* Pause    */
+	MV_RESTART		/* Restart  */
+} MV_COMMAND;
+
+/* This enumerator describes the set of state conditions.					*/
+/* Moving from one state to other is stricted.   							*/
+typedef enum _mvState {
+	MV_IDLE,
+	MV_ACTIVE,
+	MV_PAUSED,
+	MV_UNDEFINED_STATE
+} MV_STATE;
+
+typedef enum {
+	ETH_MAC_SPEED_10M,
+	ETH_MAC_SPEED_100M,
+	ETH_MAC_SPEED_1000M,
+	ETH_MAC_SPEED_AUTO
+
+} MV_ETH_MAC_SPEED;
+
+/* This structure describes address space window. Window base can be        */
+/* 64 bit, window size up to 4GB                                            */
+typedef struct _mvAddrWin {
+	MV_U32 baseLow;		/* 32bit base low       */
+	MV_U32 baseHigh;	/* 32bit base high      */
+	MV_U64 size;		/* 64bit size           */
+} MV_ADDR_WIN;
+
+/* This binary enumerator describes protection attribute status             */
+typedef enum _mvProtRight {
+	ALLOWED,		/* Protection attribute allowed                         */
+	FORBIDDEN		/* Protection attribute forbidden                       */
+} MV_PROT_RIGHT;
+
+/* Unified struct for Rx and Tx packet operations. The user is required to 	*/
+/* be familier only with Tx/Rx descriptor command status.               	*/
+typedef struct _bufInfo {
+	MV_U32 cmdSts;		/* Tx/Rx command status                                     */
+	MV_U16 byteCnt;		/* Size of valid data in the buffer     */
+	MV_U16 bufSize;		/* Total size of the buffer             */
+	MV_U8 *pBuff;		/* Pointer to Buffer                    */
+	MV_U8 *pData;		/* Pointer to data in the Buffer        */
+	MV_U32 userInfo1;	/* Tx/Rx attached user information 1    */
+	MV_U32 userInfo2;	/* Tx/Rx attached user information 2    */
+	struct _bufInfo *pNextBufInfo;	/* Next buffer in packet            */
+} BUF_INFO;
+
+/* This structure contains information describing one of buffers
+ * (fragments) they are built Ethernet packet.
+ */
+typedef struct {
+	MV_U8 *bufVirtPtr;
+	MV_ULONG bufPhysAddr;
+	MV_U32 bufSize;
+	MV_U32 dataSize;
+	MV_U32 memHandle;
+	MV_32 bufAddrShift;
+} MV_BUF_INFO;
+
+/* This structure contains information describing Ethernet packet.
+ * The packet can be divided for few buffers (fragments)
+ */
+typedef struct {
+	MV_ULONG osInfo;
+	MV_BUF_INFO *pFrags;
+	MV_U32 status;
+	MV_U16 pktSize;
+	MV_U16 numFrags;
+	MV_U32 ownerId;
+	MV_U32 fragIP;
+	MV_U32 txq;
+} MV_PKT_INFO;
+
+/* This structure describes SoC units address decode window	*/
+typedef struct {
+	MV_ADDR_WIN addrWin;	/* An address window */
+	MV_BOOL enable;		/* Address decode window is enabled/disabled    */
+	MV_U8 attrib;		/* chip select attributes */
+	MV_U8 targetId;		/* Target Id of this MV_TARGET */
+} MV_UNIT_WIN_INFO;
+
+/* This structure describes access rights for Access protection windows     */
+/* that can be found in IDMA, XOR, Ethernet and MPSC units.                 */
+/* Note that the permission enumerator coresponds to its register format.   */
+/* For example, Read only premission is presented as "1" in register field. */
+typedef enum _mvAccessRights {
+	NO_ACCESS_ALLOWED = 0,	/* No access allowed            */
+	READ_ONLY = 1,		/* Read only permission         */
+	ACC_RESERVED = 2,	/* Reserved access right                */
+	FULL_ACCESS = 3,	/* Read and Write permission    */
+	MAX_ACC_RIGHTS
+} MV_ACCESS_RIGHTS;
+
+typedef struct _mvDecRegs {
+	MV_U32 baseReg;
+	MV_U32 baseRegHigh;
+	MV_U32 ctrlReg;
+} MV_DEC_REGS;
+
+#endif /* MV_ASMLANGUAGE */
+
+#endif /* __INCmvTypesh */
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/config/mvSysEthConfig.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/config/mvSysEthConfig.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/config/mvSysEthConfig.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/config/mvSysEthConfig.h	2014-04-08 15:54:22.000000000 +0700
@@ -0,0 +1,188 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvSysEthConfig.h - Marvell Ethernet unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __mvSysEthConfig_h__
+#define __mvSysEthConfig_h__
+
+/*
+** Base address for ethernet registers.
+*/
+#define MV_PON_PORT(p)		MV_FALSE
+#define MV_ETH_REGS_BASE(p)	MV_ETH_REGS_OFFSET(p)
+
+#define MV_BM_REG_BASE		MV_BM_REGS_OFFSET
+#define MV_PNC_REG_BASE         MV_PNC_REGS_OFFSET
+#define MV_ETH_COMPLEX_BASE		(MV_ETH_COMPLEX_OFFSET)
+#define MV_ETH_ONLY_REGS_BASE		(MV_ETH_ONLY_REGS_OFFSET)
+
+#if defined(CONFIG_MV_INCLUDE_GIG_ETH)
+
+/* put descriptors in uncached memory */
+/* #define ETH_DESCR_UNCACHED */
+
+/* port's default queueus */
+#define ETH_DEF_RXQ         0  
+
+#ifdef CONFIG_MV_ETH_LEGACY 
+
+#ifdef CONFIG_MV_NFP_STATS
+#define MV_FP_STATISTICS
+#else
+#undef MV_FP_STATISTICS
+#endif
+
+/* Default configuration for TX_EN workaround: 0 - Disabled, 1 - Enabled */
+#define MV_ETH_TX_EN_DEFAULT        0
+
+/* un-comment if you want to perform tx_done from within the poll function */
+/* #define ETH_TX_DONE_ISR */
+
+/* Descriptors location: DRAM/internal-SRAM */
+#define ETH_DESCR_IN_SDRAM
+#undef  ETH_DESCR_IN_SRAM    /* No integrated SRAM in 88Fxx81 devices */
+
+#if defined(ETH_DESCR_IN_SRAM)
+#if defined(ETH_DESCR_UNCACHED)
+ #define ETH_DESCR_CONFIG_STR    "Uncached descriptors in integrated SRAM"
+#else
+ #define ETH_DESCR_CONFIG_STR    "Cached descriptors in integrated SRAM"
+#endif
+#elif defined(ETH_DESCR_IN_SDRAM)
+#if defined(ETH_DESCR_UNCACHED)
+ #define ETH_DESCR_CONFIG_STR    "Uncached descriptors in DRAM"
+#else
+ #define ETH_DESCR_CONFIG_STR    "Cached descriptors in DRAM"
+#endif
+#else 
+ #error "Ethernet descriptors location undefined"
+#endif /* ETH_DESCR_IN_SRAM or ETH_DESCR_IN_SDRAM*/
+
+/* SW Sync-Barrier: not relevant for 88fxx81*/
+/* Reasnable to define this macro when descriptors in SRAM and buffers in DRAM */
+/* In RX the CPU theoretically might see himself as the descriptor owner,      */
+/* although the buffer hadn't been written to DRAM yet. Performance cost.      */
+/* #define INCLUDE_SYNC_BARR */
+
+/* Buffers cache coherency method (buffers in DRAM) */
+#ifndef MV_CACHE_COHER_SW
+/* Taken from mvCommon.h */
+/* Memory uncached, HW or SW cache coherency is not needed */
+#define MV_UNCACHED             0   
+/* Memory cached, HW cache coherency supported in WriteThrough mode */
+#define MV_CACHE_COHER_HW_WT    1
+/* Memory cached, HW cache coherency supported in WriteBack mode */
+#define MV_CACHE_COHER_HW_WB    2
+/* Memory cached, No HW cache coherency, Cache coherency must be in SW */
+#define MV_CACHE_COHER_SW       3
+
+#endif
+
+#define ETHER_DRAM_COHER    MV_CACHE_COHER_SW   /* No HW coherency in 88Fxx81 devices */
+
+#if (ETHER_DRAM_COHER == MV_CACHE_COHER_HW_WB)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM HW cache coherency (write-back)"
+#elif (ETHER_DRAM_COHER == MV_CACHE_COHER_HW_WT)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM HW cache coherency (write-through)"
+#elif (ETHER_DRAM_COHER == MV_CACHE_COHER_SW)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM SW cache-coherency"
+#elif (ETHER_DRAM_COHER == MV_UNCACHED)
+#   define ETH_SDRAM_CONFIG_STR  "DRAM uncached"
+#else
+ #error "Ethernet-DRAM undefined"
+#endif /* ETHER_DRAM_COHER */
+
+
+/****************************************************************/
+/************* Ethernet driver configuration ********************/
+/****************************************************************/
+
+/* port's default queueus */
+#define ETH_DEF_TXQ         0
+
+#define MV_ETH_RX_Q_NUM     CONFIG_MV_ETH_RXQ
+#define MV_ETH_TX_Q_NUM     CONFIG_MV_ETH_TXQ
+
+/* interrupt coalescing setting */
+#define ETH_TX_COAL    		    200
+#define ETH_RX_COAL    		    200
+
+/* Checksum offloading */
+#define TX_CSUM_OFFLOAD
+#define RX_CSUM_OFFLOAD
+#endif /* CONFIG_MV_ETH_LEGACY */
+
+#endif /* CONFIG_MV_INCLUDE_GIG_ETH */
+
+#endif /* __mvSysEthConfig_h__ */
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/ctrlEnv/mvCtrlEnvLib.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/ctrlEnv/mvCtrlEnvLib.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/ctrlEnv/mvCtrlEnvLib.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/ctrlEnv/mvCtrlEnvLib.h	2014-03-28 15:00:54.000000000 +0700
@@ -0,0 +1,287 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCtrlEnvLibh
+#define __INCmvCtrlEnvLibh
+
+#if 0
+/* includes */
+#include "mvSysHwConfig.h"
+#include "mvCommon.h"
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+/*#include "boardEnv/mvBoardEnvLib.h"*/
+#endif
+
+//#include "../config/mvSysHwConfig.h"
+#include "../wnc_mvCommon.h"
+#include "../mvTypes.h"
+#include "../wnc_mvOs.h"
+#include "../ctrlEnv/mvCtrlEnvSpec.h"
+#include "../ctrlEnv/mvCtrlEnvRegs.h"
+
+/* 0 for Auto scan mode, 1 for manual. */
+#define MV_INTERNAL_SWITCH_SMI_SCAN_MODE	0
+
+/* typedefs */
+typedef MV_STATUS(*MV_WIN_GET_FUNC_PTR)(MV_U32, MV_U32, MV_UNIT_WIN_INFO*);
+
+/* This enumerator describes the possible HW cache coherency policies the   */
+/* controllers supports.                                                    */
+typedef enum _mvCachePolicy {
+    NO_COHERENCY,   /* No HW cache coherency support                        */
+    WT_COHERENCY,   /* HW cache coherency supported in Write Through policy */
+    WB_COHERENCY    /* HW cache coherency supported in Write Back policy    */
+} MV_CACHE_POLICY;
+
+
+/* The swapping is referred to a 64-bit words (as this is the controller    */
+/* internal data path width). This enumerator describes the possible        */
+/* data swap types. Below is an example of the data 0x0011223344556677      */
+typedef enum _mvSwapType {
+    MV_BYTE_SWAP,       /* Byte Swap                77 66 55 44 33 22 11 00 */
+    MV_NO_SWAP,         /* No swapping              00 11 22 33 44 55 66 77 */
+    MV_BYTE_WORD_SWAP,  /* Both byte and word swap  33 22 11 00 77 66 55 44 */
+    MV_WORD_SWAP,       /* Word swap                44 55 66 77 00 11 22 33 */
+    SWAP_TYPE_MAX	/* Delimiter for this enumerator                    */
+} MV_SWAP_TYPE;
+
+typedef enum {
+	SERDES_UNIT_UNCONNECTED	= 0x0,
+	SERDES_UNIT_PEX		= 0x1,
+	SERDES_UNIT_SATA	= 0x2,
+	SERDES_UNIT_SGMII0	= 0x3,
+	SERDES_UNIT_SGMII1	= 0x4,
+	SERDES_UNIT_SGMII2	= 0x5,
+	SERDES_UNIT_SGMII3	= 0x6,
+	SERDES_UNIT_QSGMII	= 0x7,
+	SERDES_UNIT_LAST
+} MV_SERDES_UNIT_INDX;
+
+typedef enum {
+	PEX_BUS_DISABLED	= 0,
+	PEX_BUS_MODE_X1		= 1,
+	PEX_BUS_MODE_X4		= 2,
+	PEX_BUS_MODE_X8		= 3
+} MV_PEX_UNIT_CFG;
+
+/* Configuration per SERDES line.
+   Each nibble is MV_SERDES_LINE_TYPE */
+typedef struct _boardSerdesConf {
+	MV_U32 enableSerdesConfiguration; /*This will determine if mvCtrlSerdesPhyConfig will configure the serdes*/
+	MV_U32	serdesLine0_7;	/* Lines 0 to 7 SERDES MUX one nibble per line */
+	MV_U32	serdesLine8_15;	/* Lines 8 to 15 SERDES MUX one nibble per line */
+	MV_PEX_UNIT_CFG		pex0Mod;
+	MV_PEX_UNIT_CFG		pex1Mod;
+	MV_PEX_UNIT_CFG		pex2Mod;
+	MV_PEX_UNIT_CFG		pex3Mod;
+	MV_U32	busSpeed;	/* Bus speed - one bit per SERDES line:
+	Low speed (0)		High speed (1)
+	PEX	2.5 G (10 bit)		5 G (20 bit)
+	SATA	1.5 G			3 G
+	SGMII 	1.25 Gbps		3.125 Gbps	*/
+} MV_SERDES_CFG;
+/* Termal Sensor Registers */
+#define TSEN_STATUS_REG				0x184C4
+#define	TSEN_STATUS_TEMP_OUT_OFFSET		1
+#define	TSEN_STATUS_TEMP_OUT_MASK		(0x1FF << TSEN_STATUS_TEMP_OUT_OFFSET)
+
+#define TSEN_CONF_REG					0x184D0
+#define	TSEN_CONF_OTF_CALIB_MASK		(0x1 << 30)
+#define	TSEN_CONF_REF_CAL_MASK			(0x1FF << 11)
+#define	TSEN_CONF_SOFT_RESET_MASK		(0x1 << 1)
+#define	TSEN_CONF_START_CALIB_MASK		(0x1 << 25)
+
+
+/* BIOS Modes related defines */
+
+#define SAR0_BOOTWIDTH_OFFSET	3
+#define SAR0_BOOTWIDTH_MASK		(0x3 << SAR0_BOOTWIDTH_OFFSET)
+#define SAR0_BOOTSRC_OFFSET		5
+#define SAR0_BOOTSRC_MASK		(0xF << SAR0_BOOTSRC_OFFSET)
+
+#define SAR0_L2_SIZE_OFFSET		19
+#define SAR0_L2_SIZE_MASK		(0x3 << SAR0_L2_SIZE_OFFSET)
+#define SAR0_CPU_FREQ_OFFSET	21
+#define SAR0_CPU_FREQ_MASK		(0x7 << SAR0_CPU_FREQ_OFFSET)
+#define SAR0_FABRIC_FREQ_OFFSET	24
+#define SAR0_FABRIC_FREQ_MASK	(0xF << SAR0_FABRIC_FREQ_OFFSET)
+#define SAR0_CPU0CORE_OFFSET	31
+#define SAR0_CPU0CORE_MASK		(0x1 << SAR0_CPU0CORE_OFFSET)
+#define SAR1_CPU0CORE_OFFSET	0
+#define SAR1_CPU0CORE_MASK		(0x1 << SAR1_CPU0CORE_OFFSET)
+
+#define PEX_CLK_100MHZ_OFFSET	2
+#define PEX_CLK_100MHZ_MASK     (0x1 << PEX_CLK_100MHZ_OFFSET)
+
+#define SAR1_CPU_CORE_OFFSET	3
+#define SAR1_CPU_CORE_MASK		(0x3 << SAR1_CPU_CORE_OFFSET)
+#define SAR1_FABRIC_MODE_OFFSET	19
+#define SAR1_FABRIC_MODE_MASK	(0x1 << SAR1_FABRIC_MODE_OFFSET)
+#define SAR1_CPU_MODE_OFFSET	20
+#define SAR1_CPU_MODE_MASK		(0x1 << SAR1_CPU_MODE_OFFSET)
+
+#define SAR_CPU_FAB_GET(cpu, fab)	(((cpu & 0x7) << 21) | ((fab & 0xF) << 24))
+#define BIOS_MODES_NUM			4
+
+typedef struct {
+	char *name;
+	MV_U16 confId;
+	MV_U16 code;
+	MV_U8 l2size;
+	MV_U8 cpuFreq;
+	MV_U8 cpuFreqMode;
+	MV_U8 fabricFreq;
+	MV_U8 AltfabricFreq;
+	MV_U8 fabricFreqMode;
+	MV_U8 cpuEna;
+	MV_U8 cpuEndianess;
+	MV_U8 dramBusWidth;
+	MV_U8 bootSource;
+	MV_U8 bootWidth;
+} MV_BIOS_MODE;
+
+extern MV_BIOS_MODE bios_modes[];
+extern MV_BIOS_MODE bios_modes_b0[];
+
+/* mcspLib.h API list */
+MV_U32 mvCtrlGetCpuNum(MV_VOID);
+MV_U32 mvCtrlGetQuadNum(MV_VOID);
+MV_BOOL mvCtrlIsValidSatR(MV_VOID);
+
+MV_STATUS mvCtrlEnvInit(MV_VOID);
+MV_U32    mvCtrlMppRegGet(MV_U32 mppGroup);
+
+#if defined(MV_INCLUDE_PEX)
+MV_U32	mvCtrlPexMaxIfGet(MV_VOID);
+MV_U32	mvCtrlPexMaxUnitGet(MV_VOID);
+#else
+#define mvCtrlPexMaxIfGet()	(0)
+#endif
+
+#if defined(MV_INCLUDE_PCI)
+MV_U32	mvCtrlPciMaxIfGet(MV_VOID);
+#else
+#define mvCtrlPciIfMaxIfGet()	(mvCtrlPexMaxIfGet())
+#endif
+
+MV_U32	  mvCtrlEthMaxPortGet(MV_VOID);
+MV_U8	  mvCtrlEthMaxCPUsGet(MV_VOID);
+#if defined(MV_INCLUDE_IDMA)
+MV_U32 mvCtrlIdmaMaxUnitGet(MV_VOID);
+MV_U32 mvCtrlIdmaMaxChanGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_XOR)
+MV_U32 mvCtrlXorMaxChanGet(MV_VOID);
+MV_U32 mvCtrlXorMaxUnitGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_USB)
+MV_U32 	  mvCtrlUsbMaxGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_LEGACY_NAND)
+MV_U32	  mvCtrlNandSupport(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_SDIO)
+MV_U32	  mvCtrlSdioSupport(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_TDM)
+MV_U32	  mvCtrlTdmSupport(MV_VOID);
+MV_U32	  mvCtrlTdmMaxGet(MV_VOID);
+MV_UNIT_ID mvCtrlTdmUnitTypeGet(MV_VOID);
+MV_U32    mvCtrlTdmUnitIrqGet(MV_VOID);
+#endif
+MV_U32 mvCtrlDevFamilyIdGet(MV_U16 ctrlModel);
+MV_U16    mvCtrlModelGet(MV_VOID);
+MV_U8     mvCtrlRevGet(MV_VOID);
+MV_STATUS mvCtrlNameGet(char *pNameBuff);
+MV_U32    mvCtrlModelRevGet(MV_VOID);
+MV_STATUS mvCtrlModelRevNameGet(char *pNameBuff);
+MV_VOID   mvCtrlAddrDecShow(MV_VOID);
+const MV_8 *mvCtrlTargetNameGet(MV_TARGET target);
+MV_U32	  ctrlSizeToReg(MV_U32 size, MV_U32 alignment);
+MV_U32	  ctrlRegToSize(MV_U32 regSize, MV_U32 alignment);
+MV_U32	  ctrlSizeRegRoundUp(MV_U32 size, MV_U32 alignment);
+MV_U32	  mvCtrlSysRstLengthCounterGet(MV_VOID);
+MV_STATUS ctrlWinOverlapTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+MV_STATUS ctrlWinWithinWinTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+
+MV_VOID   mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable);
+MV_BOOL	  mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index);
+MV_VOID   mvCtrlPwrMemSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable);
+MV_BOOL	  mvCtrlIsBootFromNOR(MV_VOID);
+MV_BOOL	  mvCtrlIsBootFromSPI(MV_VOID);
+MV_BOOL	  mvCtrlIsBootFromNAND(MV_VOID);
+MV_BOOL	  mvCtrlPwrMemGet(MV_UNIT_ID unitId, MV_U32 index);
+
+MV_U32 mvCtrlSerdesMaxLinesGet(MV_VOID);
+MV_STATUS mvCtrlSerdesPhyConfig(MV_VOID);
+MV_U32 mvCtrlDDRBudWidth(MV_VOID);
+MV_BOOL mvCtrlDDRThruXbar(MV_VOID);
+MV_BOOL mvCtrlDDRECC(MV_VOID);
+
+#endif /* __INCmvCtrlEnvLibh */
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/ctrlEnv/mvCtrlEnvRegs.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/ctrlEnv/mvCtrlEnvRegs.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/ctrlEnv/mvCtrlEnvRegs.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/ctrlEnv/mvCtrlEnvRegs.h	2013-10-03 15:44:58.000000000 +0700
@@ -0,0 +1,569 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvRegsh
+#define __INCmvCtrlEnvRegsh
+
+#include "mvCtrlEnvSpec.h"
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* CV Support */
+#define PEX0_MEM0 	PEX0_MEM
+#define PCI0_MEM0	PEX0_MEM
+
+/* Controller revision info */
+#define PCI_CLASS_CODE_AND_REVISION_ID		0x008
+#define PCCRIR_REVID_OFFS			0		/* Revision ID */
+#define PCCRIR_REVID_MASK			(0xff << PCCRIR_REVID_OFFS)
+
+/* Controler environment registers offsets */
+#define MV_TDM_IRQ_NUM				56
+
+
+/* Coherent Fabric Control and Status */
+#define MV_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x0)
+#define MV_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x4)
+
+/* CIB registers offsets */
+#define MV_CIB_CTRL_CFG_REG			(MV_COHERENCY_FABRIC_OFFSET + 0x80)
+
+/* PMU_NFABRIC PMU_NFABRIC PMU_UNIT_SERVICE Units */
+#define MV_L2C_NFABRIC_PM_CTRL_CFG_REG		(MV_PMU_NFABRIC_UNIT_SERV_OFFSET + 0x4)
+#define MV_L2C_NFABRIC_PM_CTRL_CFG_PWR_DOWN	(1 << 20)
+
+#define MV_L2C_NFABRIC_PWR_DOWN_FLOW_CTRL_REG	(MV_PMU_NFABRIC_UNIT_SERV_OFFSET + 0x8)
+
+#define PM_CONTROL_AND_CONFIG_REG(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0x4)
+#define PM_CONTROL_AND_CONFIG_DFS_REQ		(1 << 18)
+#define PM_CONTROL_AND_CONFIG_PWDDN_REQ		(1 << 16)
+#define PM_CONTROL_AND_CONFIG_L2_PWDDN		(1 << 20)
+
+#define PM_STATUS_AND_MASK_REG(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0xc)
+#define PM_STATUS_AND_MASK_CPU_IDLE_WAIT	(1 << 16)
+#define PM_STATUS_AND_MASK_SNP_Q_EMPTY_WAIT	(1 << 17)
+#define PM_STATUS_AND_MASK_IRQ_WAKEUP		(1 << 20)
+#define PM_STATUS_AND_MASK_FIQ_WAKEUP		(1 << 21)
+#define PM_STATUS_AND_MASK_DBG_WAKEUP		(1 << 22)
+#define PM_STATUS_AND_MASK_IRQ_MASK		(1 << 24)
+#define PM_STATUS_AND_MASK_FIQ_MASK		(1 << 25)
+
+#define PM_EVENT_STATUS_AND_MASK_REG(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0x20)
+#define PM_EVENT_STATUS_AND_MASK_DFS_DONE_OFFS			1
+#define PM_EVENT_STATUS_AND_MASK_DFS_DONE_MASK_OFFS		17
+
+#define PM_CPU_BOOT_ADDR_REDIRECT(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0x24)
+
+/* Power Management Memory Power Down Registers 1 - 6 */
+#define POWER_MNG_MEM_CTRL_REG(num)		((num) < 6 ? 0x1820C + (num) * 4 : 0x18228)
+#define PMC_MCR_NUM_COMM			6
+#define PMC_MCR_NUM_PEX				2
+#define PMC_MCR_NUM_USB				4
+#define PMC_MCR_NUM_DUNIT			3
+#define PMC_MCR_NUM_DEVB			4
+#define PMC_MCR_NUM_NF				4
+#define PMC_MCR_NUM_XOR				4
+#define PMC_MCR_NUM_SATA			5
+#define PMC_MCR_NUM_CESA			4
+#define PMC_MCR_NUM_GE				5
+#define PMC_MCR_NUM_PNC				5
+#define PMC_MCR_NUM_BM				5
+#define PMC_MCR_NUM_PDMA			1
+#define PMC_MCR_NUM_NCS				3
+#define PMC_MCR_NUM_CFU				3
+#define PMC_MCR_NUM_L2				3
+#define PMC_MCR_NUM_CIB				3
+#define PMC_MCR_NUM_CPU				3
+#define PMC_MCR_NUM_IDMA			4
+#define PMC_MCR_NUM_LCD				4
+#define PMC_MCR_NUM_PMU				6
+
+#define PMC_COMMSTOPMEM_OFFS			4
+#define PMC_COMMSTOPMEM_MASK			(7 << PMC_COMMSTOPMEM_OFFS)
+#define PMC_COMMSTOPMEM_EN			(0 << PMC_COMMSTOPMEM_OFFS)
+#define PMC_COMMSTOPMEM_STOP			(1 << PMC_COMMSTOPMEM_OFFS)
+
+#define PMC_PEXSTOPMEM_OFFS(port)		((port) < 10 ? ((port) * 3) : 0)
+#define PMC_PEXSTOPMEM_MASK(port)		(7 << PMC_PEXSTOPMEM_OFFS(port))
+#define PMC_PEXSTOPMEM_EN(port)			(0 << PMC_PEXSTOPMEM_OFFS(port))
+#define PMC_PEXSTOPMEM_STOP(port)		(1 << PMC_PEXSTOPMEM_OFFS(port))
+
+#define PMC_USBSTOPMEM_OFFS(port)		((port) < 3 ? (3 + (port) * 3) : 0)
+#define PMC_USBSTOPMEM_MASK(port)		(7 << PMC_USBSTOPMEM_OFFS(port))
+#define PMC_USBSTOPMEM_EN(port)			(0 << PMC_USBSTOPMEM_OFFS(port))
+#define PMC_USBSTOPMEM_STOP(port)		(1 << PMC_USBSTOPMEM_OFFS(port))
+
+#define PMC_DUNITSTOPMEM_OFFS			12
+#define PMC_DUNITSTOPMEM_MASK			(7 << PMC_DUNITSTOPMEM_OFFS)
+#define PMC_DUNITSTOPMEM_EN			(0 << PMC_DUNITSTOPMEM_OFFS)
+#define PMC_DUNITSTOPMEM_STOP			(1 << PMC_DUNITSTOPMEM_OFFS)
+
+#define PMC_NFSTOPMEM_OFFS			27
+#define PMC_NFSTOPMEM_MASK			(7 << PMC_NFSTOPMEM_OFFS)
+#define PMC_NFSTOPMEM_EN			(0 << PMC_NFSTOPMEM_OFFS)
+#define PMC_NFSTOPMEM_STOP			(1 << PMC_NFSTOPMEM_OFFS)
+
+#define PMC_DEVBSTOPMEM_OFFS			21
+#define PMC_DEVBSTOPMEM_MASK			(7 << PMC_DEVBSTOPMEM_OFFS)
+#define PMC_DEVBSTOPMEM_EN			(0 << PMC_DEVBSTOPMEM_OFFS)
+#define PMC_DEVBSTOPMEM_STOP			(1 << PMC_DEVBSTOPMEM_OFFS)
+
+#define PMC_XORSTOPMEM_OFFS(port)		((port) == 0 ? 15 : 24)
+#define PMC_XORSTOPMEM_MASK(port)		(7 << PMC_XORSTOPMEM_OFFS(port))
+#define PMC_XORSTOPMEM_EN(port)			(0 << PMC_XORSTOPMEM_OFFS(port))
+#define PMC_XORSTOPMEM_STOP(port)		(1 << PMC_XORSTOPMEM_OFFS(port))
+
+#define PMC_SATASTOPMEM_OFFS(port)		((port) == 0 ? 18 : 24)
+#define PMC_SATASTOPMEM_MASK(port)		(0x3F << PMC_SATASTOPMEM_OFFS(port))
+#define PMC_SATASTOPMEM_EN(port)		(0 << PMC_SATASTOPMEM_OFFS(port))
+#define PMC_SATASTOPMEM_STOP(port)		(9 << PMC_SATASTOPMEM_OFFS(port))
+
+#define PMC_CESASTOPMEM_OFFS			18
+#define PMC_CESASTOPMEM_MASK			(7 << PMC_CESASTOPMEM_OFFS)
+#define PMC_CESASTOPMEM_EN			(0 << PMC_CESASTOPMEM_OFFS)
+#define PMC_CESASTOPMEM_STOP			(1 << PMC_CESASTOPMEM_OFFS)
+
+#define PMC_GESTOPMEM_OFFS(port)		((port) < 4 ? (9 - (port) * 3) : 0)
+#define PMC_GESTOPMEM_MASK(port)		(7 << PMC_GESTOPMEM_OFFS(port))
+#define PMC_GESTOPMEM_EN(port)			(0 << PMC_GESTOPMEM_OFFS(port))
+#define PMC_GESTOPMEM_STOP(port)		(1 << PMC_GESTOPMEM_OFFS(port))
+
+#define PMC_PNCSTOPMEM_OFFS			12
+#define PMC_PNCSTOPMEM_MASK			(7 << PMC_PNCSTOPMEM_OFFS)
+#define PMC_PNCSTOPMEM_EN			(0 << PMC_PNCSTOPMEM_OFFS)
+#define PMC_PNCSTOPMEM_STOP			(1 << PMC_PNCSTOPMEM_OFFS)
+
+#define PMC_BMSTOPMEM_OFFS			15
+#define PMC_BMSTOPMEM_MASK			(7 << PMC_BMSTOPMEM_OFFS)
+#define PMC_BMSTOPMEM_EN			(0 << PMC_BMSTOPMEM_OFFS)
+#define PMC_BMSTOPMEM_STOP			(1 << PMC_BMSTOPMEM_OFFS)
+
+#define PMC_PDMASTOPMEM_OFFS			0
+#define PMC_PDMATOPMEM_MASK			(7 << PMC_PDMASTOPMEM_OFFS)
+#define PMC_PDMASTOPMEM_EN			(0 << PMC_PDMASTOPMEM_OFFS)
+#define PMC_PDMASTOPMEM_STOP			(1 << PMC_PDMASTOPMEM_OFFS)
+
+#define PMC_NCSSTOPMEM_OFFS			24
+#define PMC_NCSSTOPMEM_MASK			(7 << PMC_NCSSTOPMEM_OFFS)
+#define PMC_NCSSTOPMEM_EN			(0 << PMC_NCSSTOPMEM_OFFS)
+#define PMC_NCSSTOPMEM_STOP			(1 << PMC_NCSSTOPMEM_OFFS)
+
+#define PMC_CFUSTOPMEM_OFFS			21
+#define PMC_CFUSTOPMEM_MASK			(7 << PMC_CFUSTOPMEM_OFFS)
+#define PMC_CFUSTOPMEM_EN			(0 << PMC_CFUSTOPMEM_OFFS)
+#define PMC_CFUSTOPMEM_STOP			(1 << PMC_CFUSTOPMEM_OFFS)
+
+#define PMC_L2STOPMEM_OFFS			18
+#define PMC_L2STOPMEM_MASK			(7 << PMC_L2STOPMEM_OFFS)
+#define PMC_L2STOPMEM_EN			(0 << PMC_L2STOPMEM_OFFS)
+#define PMC_L2STOPMEM_STOP			(1 << PMC_L2STOPMEM_OFFS)
+
+#define PMC_CIBSTOPMEM_OFFS			15
+#define PMC_CIBSTOPMEM_MASK			(7 << PMC_CIBSTOPMEM_OFFS)
+#define PMC_CIBSTOPMEM_EN			(0 << PMC_CIBSTOPMEM_OFFS)
+#define PMC_CIBSTOPMEM_STOP			(1 << PMC_CIBSTOPMEM_OFFS)
+
+/* TODO - verify, the manual has no description */
+#define PMC_CPUSTOPMEM_OFFS(id)			((id) < 4 ? (id) * 3 : 0)
+#define PMC_CPUSTOPMEM_MASK(id)			(7 << PMC_CPUSTOPMEM_OFFS(id))
+#define PMC_CPUSTOPMEM_EN(id)			(0 << PMC_CPUSTOPMEM_OFFS(id))
+#define PMC_CPUSTOPMEM_STOP(id)			(1 << PMC_CPUSTOPMEM_OFFS(id))
+
+#define PMC_IDMASTOPMEM_OFFS			12
+#define PMC_IDMASTOPMEM_MASK			(7 << PMC_IDMASTOPMEM_OFFS)
+#define PMC_IDMASTOPMEM_EN			(0 << PMC_IDMASTOPMEM_OFFS)
+#define PMC_IDMASTOPMEM_STOP			(1 << PMC_IDMASTOPMEM_OFFS)
+
+#define PMC_LCDSTOPMEM_OFFS			0
+#define PMC_LCDSTOPMEM_MASK			(7 << PMC_LCDSTOPMEM_OFFS)
+#define PMC_LCDSTOPMEM_EN			(0 << PMC_LCDSTOPMEM_OFFS)
+#define PMC_LCDSTOPMEM_STOP			(1 << PMC_LCDSTOPMEM_OFFS)
+
+#define PMC_PMUSTOPMEM_OFFS			0
+#define PMC_PMUSTOPMEM_MASK			(7 << PMC_PMUSTOPMEM_OFFS)
+#define PMC_PMUSTOPMEM_EN			(0 << PMC_PMUSTOPMEM_OFFS)
+#define PMC_PMUSTOPMEM_STOP			(1 << PMC_PMUSTOPMEM_OFFS)
+
+
+/*  Power Management Clock Gating Control Register	*/
+#define POWER_MNG_CTRL_REG			0x18220
+#define L2C_MTCMOS_CONTROL_0_REG    0x22F00
+#define L2C_MTCMOS_CONTROL_1_REG    0x22F04
+
+#define PMU_DFS_CTRL_REG(cpu)			(MV_RUNIT_PMU_REGS_OFFSET + 0x54 + ((cpu) * 0x4))
+#define PMU_DFS_CTRL_INIT_RATIO_OFFS	24
+#define PMU_DFS_CTRL_INIT_RATIO_MASK	0x3F
+#define PMU_DFS_CTRL_RATIO_OFFS			16
+#define PMU_DFS_CTRL_RATIO_MASK			0x3F
+
+#define PMC_TDMSTOPCLOCK_OFFS			25
+#define PMC_TDMSTOPCLOCK_MASK			(1 << PMC_TDMSTOPCLOCK_OFFS)
+#define PMC_TDMSTOPCLOCK_EN			(1 << PMC_TDMSTOPCLOCK_OFFS)
+#define PMC_TDMSTOPCLOCK_STOP			(0 << PMC_TDMSTOPCLOCK_OFFS)
+
+#define PMC_PEXSTOPCLOCK_OFFS(port)		((port) < 8 ? (5 + (port)) : (18 + (port)))
+#define PMC_PEXSTOPCLOCK_MASK(port)		(1 << PMC_PEXSTOPCLOCK_OFFS(port))
+#define PMC_PEXSTOPCLOCK_EN(port)		(1 << PMC_PEXSTOPCLOCK_OFFS(port))
+#define PMC_PEXSTOPCLOCK_STOP(port)		(0 << PMC_PEXSTOPCLOCK_OFFS(port))
+
+#define PMC_USBSTOPCLOCK_OFFS(port)		((port) < 3 ? (18 + (port)) : 0)
+#define PMC_USBSTOPCLOCK_MASK(port)		(1 << PMC_USBSTOPCLOCK_OFFS(port))
+#define PMC_USBSTOPCLOCK_EN(port)		(1 << PMC_USBSTOPCLOCK_OFFS(port))
+#define PMC_USBSTOPCLOCK_STOP(port)		(0 << PMC_USBSTOPCLOCK_OFFS(port))
+
+#define PMC_SDIOSTOPCLOCK_OFFS			17
+#define PMC_SDIOSTOPCLOCK_MASK			(1 << PMC_SDIOSTOPCLOCK_OFFS)
+#define PMC_SDIOSTOPCLOCK_EN			(1 << PMC_SDIOSTOPCLOCK_OFFS)
+#define PMC_SDIOSTOPCLOCK_STOP			(0 << PMC_SDIOSTOPCLOCK_OFFS)
+
+#define PMC_RUNITSTOPCLOCK_OFFS			24
+#define PMC_RUNITSTOPCLOCK_MASK			(1 << PMC_RUNITSTOPCLOCK_OFFS)
+#define PMC_RUNITSTOPCLOCK_EN			(1 << PMC_RUNITSTOPCLOCK_OFFS)
+#define PMC_RUNITSTOPCLOCK_STOP			(0 << PMC_RUNITSTOPCLOCK_OFFS)
+
+#define PMC_XORSTOPCLOCK_OFFS			22
+#define PMC_XORSTOPCLOCK_MASK			(1 << PMC_XORSTOPCLOCK_OFFS)
+#define PMC_XORSTOPCLOCK_EN			(1 << PMC_XORSTOPCLOCK_OFFS)
+#define PMC_XORSTOPCLOCK_STOP			(0 << PMC_XORSTOPCLOCK_OFFS)
+
+#define PMC_SATASTOPCLOCK_OFFS(ch)		(ch == 0 ? 14 : 29)
+#define PMC_SATASTOPCLOCK_MASK(ch)		(3 << PMC_SATASTOPCLOCK_OFFS(ch))
+#define PMC_SATASTOPCLOCK_EN(ch)		(3 << PMC_SATASTOPCLOCK_OFFS(ch))
+#define PMC_SATASTOPCLOCK_STOP(ch)		(0 << PMC_SATASTOPCLOCK_OFFS(ch))
+
+#define PMC_CESASTOPCLOCK_OFFS			23
+#define PMC_CESASTOPCLOCK_MASK			(1 << PMC_CESASTOPCLOCK_OFFS)
+#define PMC_CESASTOPCLOCK_EN			(1 << PMC_CESASTOPCLOCK_OFFS)
+#define PMC_CESASTOPCLOCK_STOP			(0 << PMC_CESASTOPCLOCK_OFFS)
+
+#define PMC_GESTOPCLOCK_OFFS(port)		((port) < 4 ? (4 - (port)) : 0)
+#define PMC_GESTOPCLOCK_MASK(port)		(1 << PMC_GESTOPCLOCK_OFFS(port))
+#define PMC_GESTOPCLOCK_EN(port)		(1 << PMC_GESTOPCLOCK_OFFS(port))
+#define PMC_GESTOPCLOCK_STOP(port)		(0 << PMC_GESTOPCLOCK_OFFS(port))
+
+#define PMC_NETASTOPCLOCK_OFFS			13
+#define PMC_NETASTOPCLOCK_MASK			(1 << PMC_NETASTOPCLOCK_OFFS)
+#define PMC_NETASTOPCLOCK_EN			(1 << PMC_NETASTOPCLOCK_OFFS)
+#define PMC_NETASTOPCLOCK_STOP			(0 << PMC_NETASTOPCLOCK_OFFS)
+
+#define PMC_LCDSTOPCLOCK_OFFS			16
+#define PMC_LCDSTOPCLOCK_MASK			(1 << PMC_LCDSTOPCLOCK_OFFS)
+#define PMC_LCDSTOPCLOCK_EN			(1 << PMC_LCDSTOPCLOCK_OFFS)
+#define PMC_LCDSTOPCLOCK_STOP			(0 << PMC_LCDSTOPCLOCK_OFFS)
+
+#define PMC_IDMASTOPCLOCK_OFFS			21
+#define PMC_IDMASTOPCLOCK_MASK			(1 << PMC_IDMASTOPCLOCK_OFFS)
+#define PMC_IDMASTOPCLOCK_EN			(1 << PMC_IDMASTOPCLOCK_OFFS)
+#define PMC_IDMASTOPCLOCK_STOP			(0 << PMC_IDMASTOPCLOCK_OFFS)
+
+#define PMC_DDRSTOPCLOCK_OFFS			28
+#define PMC_DDRSTOPCLOCK_MASK			(1 << PMC_DDRSTOPCLOCK_OFFS)
+#define PMC_DDRSTOPCLOCK_EN			(1 << PMC_DDRSTOPCLOCK_OFFS)
+#define PMC_DDRSTOPCLOCK_STOP			(0 << PMC_DDRSTOPCLOCK_OFFS)
+
+#define SATA_IMP_TX_SSC_CTRL_REG(port)		(0xA2810 + (port)*0x2000)
+#define SATA_GEN_1_SET_0_REG(port)			(0xA2834 + (port)*0x2000)
+#define SATA_GEN_1_SET_1_REG(port)			(0xA2838 + (port)*0x2000)
+#define SATA_GEN_2_SET_0_REG(port)			(0xA283C + (port)*0x2000)
+#define SATA_GEN_2_SET_1_REG(port)			(0xA2840 + (port)*0x2000)
+
+#define SATA_PWR_PLL_CTRL_REG(port)			(0xA2804 + (port)*0x2000)
+#define SATA_DIG_LP_ENA_REG(port)			(0xA288C + (port)*0x2000)
+#define SATA_REF_CLK_SEL_REG(port)			(0xA2918 + (port)*0x2000)
+#define SATA_COMPHY_CTRL_REG(port)			(0xA2920 + (port)*0x2000)
+#define SATA_LP_PHY_EXT_CTRL_REG(port)		(0xA2058 + (port)*0x2000)
+#define SATA_LP_PHY_EXT_STAT_REG(port)		(0xA205C + (port)*0x2000)
+
+#define SGMII_PWR_PLL_CTRL_REG(port)		(0x72E04 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_DIG_LP_ENA_REG(port)		(0x72E8C + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_REF_CLK_SEL_REG(port)		(0x72F18 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_SERDES_CFG_REG(port)		(0x724A0 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_SERDES_STAT_REG(port)		(0x724A4 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_COMPHY_CTRL_REG(port)		(0x72F20 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define QSGMII_GEN_1_SETTING_REG(port)		(0x72E38 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+
+#define SERDES_LINE_MUX_REG_0_7			0x18270
+#define SERDES_LINE_MUX_REG_8_15		0x18274
+#define QSGMII_CONTROL_1_REG                    0x18404
+/* Controler environment registers offsets */
+#define GEN_PURP_RES_1_REG			0x182F4
+#define GEN_PURP_RES_2_REG			0x182F8
+
+#define MPP_CONTROL_REG(id)			(0x18000 + (id * 4))
+
+/* Sample at Reset */
+#define MPP_SAMPLE_AT_RESET(id)			(0x18230 + (id * 4))
+
+/* SYSRSTn Length Counter */
+#define SYSRST_LENGTH_COUNTER_REG		0x18250
+#define SLCR_COUNT_OFFS				0
+#define SLCR_COUNT_MASK				(0x1FFFFFFF << SLCR_COUNT_OFFS)
+#define SLCR_CLR_OFFS				31
+#define SLCR_CLR_MASK				(1 << SLCR_CLR_OFFS)
+
+/* Device ID */
+#define CHIP_BOND_REG				0x18238
+#define PCKG_OPT_MASK				0x3
+
+#define MPP_OUTPUT_DRIVE_REG			0x184E4
+#define MPP_GE_A_OUTPUT_DRIVE_OFFS		6
+#define MPP_GE_A_1_8_OUTPUT_DRIVE		(0x1 << MPP_GE_A_OUTPUT_DRIVE_OFFS)
+#define MPP_GE_A_2_5_OUTPUT_DRIVE		(0x2 << MPP_GE_A_OUTPUT_DRIVE_OFFS)
+#define MPP_GE_B_OUTPUT_DRIVE_OFFS		14
+#define MPP_GE_B_1_8_OUTPUT_DRIVE		(0x1 << MPP_GE_B_OUTPUT_DRIVE_OFFS)
+#define MPP_GE_B_2_5_OUTPUT_DRIVE		(0x2 << MPP_GE_B_OUTPUT_DRIVE_OFFS)
+
+#define MSAR_BOOT_MODE_OFFS			5
+#define MSAR_BOOT_MODE_MASK			(0xF << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_NOR				(0x0 << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_SPI				(0x3 << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_DOVE_NAND			(0x1 << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_LEGACY_NAND			(0x6 << MSAR_BOOT_MODE_OFFS)
+
+#define MSAR_TCLK_OFFS				28
+#define MSAR_TCLK_MASK				(0x1 << MSAR_TCLK_OFFS)
+
+/*****************/
+/* PUP registers */
+/*****************/
+#define PUP_EN_REG				0x1864C
+
+/* Extract CPU, L2, DDR clocks SAR value from
+** SAR bits 24-27
+*/
+#define MSAR_CPU_CLK_IDX(sar0, sar1)		((((sar0) >> 21) & 0x7) + ((((sar1) >> 20) & 1) << 3))
+#define MSAR_CPU_CLK_TWSI(sar0, sar1)		((((sar0) >> 2)  & 0x7) + (((sar1) & 1) << 3))
+#define MSAR_DDR_L2_CLK_RATIO_IDX(sar0, sar1)	((((sar0) >> 24) & 0xF) + ((((sar1) >> 19) & 1) << 4))
+#define MSAR_DDR_L2_CLK_RATIO_TWSI(sar0)	(((sar0) >> 1)  & 0xF)
+
+#ifndef MV_ASMLANGUAGE
+
+#define MV_CPU_CLK_TBL { 1000, 1066, 1200, 1333, 1500, 1666, 1800, 2000,\
+			  600,  667,  800, 1600, 2133, 2200, 2400, 0 }
+
+/*		cpu	l2c	hclk	ddr	*/
+#define MV_DDR_L2_CLK_RATIO_TBL    { \
+/*00*/	{	1,	1,	4,	2	},\
+/*01*/	{	1,	2,	2,	2	},\
+/*02*/	{	2,	2,	6,	3	},\
+/*03*/	{	2,	2,	3,	3	},\
+/*04*/	{	1,	2,	3,	3	},\
+/*05*/	{	1,	2,	4,	2	},\
+/*06*/	{	1,	1,	2,	2	},\
+/*07*/	{	2,	3,	6,	6	},\
+/*08*/	{	2,	3,	5,	5	},\
+/*09*/	{	1,	2,	6,	3	},\
+/*10*/	{	2,	4,	10,	5	},\
+/*11*/	{	1,	3,	6,	6	},\
+/*12*/	{	1,	2,	4,	4	},\
+/*13*/	{	1,	3,	6,	3	},\
+/*14*/	{	1,	2,	5,	5	},\
+/*15*/	{	2,	2,	5,	5	},\
+/*16*/	{	1,	1,	3,	3	},\
+/*17*/	{	2,	5,	10,	10	},\
+/*18*/	{	1,	3,	8,	4	},\
+/*19*/	{	1,	1,	2,	1	},\
+/*20*/	{	2,	3,	6,	3	},\
+/*21*/	{	1,	2,	8,	4	},\
+/*22*/	{	2,	5,	10,	5	} \
+}
+
+/* These macros help units to identify a target Mport Arbiter group */
+#define MV_TARGET_IS_DRAM(target)   \
+		((target >= SDRAM_CS0) && (target <= SDRAM_CS3))
+
+#define MV_TARGET_IS_PEX0(target)   \
+		((target >= PEX0_MEM) && (target <= PEX0_IO))
+#define MV_TARGET_IS_PEX1(target)   \
+		((target >= PEX1_MEM) && (target <= PEX1_IO))
+#define MV_TARGET_IS_PEX2(target)   \
+		((target >= PEX2_MEM) && (target <= PEX2_IO))
+#define MV_TARGET_IS_PEX3(target)   \
+		((target >= PEX3_MEM) && (target <= PEX3_IO))
+#define MV_TARGET_IS_PEX4(target)   \
+		((target >= PEX4_MEM) && (target <= PEX4_IO))
+#define MV_TARGET_IS_PEX5(target)   \
+		((target >= PEX5_MEM) && (target <= PEX5_IO))
+#define MV_TARGET_IS_PEX6(target)   \
+		((target >= PEX6_MEM) && (target <= PEX6_IO))
+#define MV_TARGET_IS_PEX7(target)   \
+		((target >= PEX7_MEM) && (target <= PEX7_IO))
+#define MV_TARGET_IS_PEX8(target)   \
+		((target >= PEX8_MEM) && (target <= PEX8_IO))
+#define MV_TARGET_IS_PEX9(target)   \
+		((target >= PEX9_MEM) && (target <= PEX9_IO))
+
+#define MV_TARGET_IS_PEX(target)	((target >= PEX0_MEM) && (target <= PEX9_IO))
+
+#define MV_TARGET_IS_DEVICE(target)	((target >= DEVICE_CS0) && (target <= DEVICE_CS3))
+
+#define MV_PCI_DRAM_BAR_TO_DRAM_TARGET(bar)   0
+
+#define MV_CHANGE_BOOT_CS(target) target
+
+#define TCLK_TO_COUNTER_RATIO   1   /* counters running in Tclk */
+
+
+#define BOOT_TARGETS_NAME_ARRAY {	\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	TBL_TERM, 			\
+	TBL_TERM, 			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	BOOT_ROM_CS			\
+}
+
+#define START_DEV_CS   		DEV_CS0
+#define DEV_TO_TARGET(dev)	((dev) + START_DEV_CS)
+
+#define PCI_IF0_MEM0		PEX0_MEM
+#define PCI_IF0_IO		PEX0_IO
+
+/* This enumerator defines the Marvell controller target ID  (see Address map) */
+typedef enum _mvTargetId {
+    DRAM_TARGET_ID	= 0,	/* Port 0 -> DRAM interface		*/
+    DEV_TARGET_ID	= 1,	/* Port 1 -> Device port, BootROM, SPI	*/
+    PEX0_2_TARGET_ID	= 4,	/* Port 4 -> PCI Express 0 and 2	*/
+    PEX1_3_TARGET_ID	= 8,	/* Port 4 -> PCI Express 1 and 3	*/
+    CRYPT_TARGET_ID	= 9,	/* Port 9 --> Crypto Engine SRAM	*/
+    PNC_BM_TARGET_ID	= 12,  	/* Port 12 -> PNC + BM Unit		*/
+    MAX_TARGETS_ID
+} MV_TARGET_ID;
+
+/*
+typedef enum {
+	SERDES_UNIT_UNCONNECTED	= 0x0,
+	SERDES_UNIT_PEX		= 0x1,
+	SERDES_UNIT_SATA	= 0x2,
+	SERDES_UNIT_SGMII0	= 0x3,
+	SERDES_UNIT_SGMII1	= 0x4,
+	SERDES_UNIT_SGMII2	= 0x5,
+	SERDES_UNIT_SGMII3	= 0x6,
+	SERDES_UNIT_QSGMII	= 0x7
+} MV_SERDES_UNIT_INDX;
+*/
+
+/*
+	This structure refrect registers:
+	Serdes 0-7 selectors		0x18270
+	and Serdes 8-15 selectors  	0x18274
+*/
+
+#define SERDES_CFG {	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 0 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 1 */	\
+	{0, 1, -1 ,  2, -1, -1, -1, -1}, /* Lane 2 */	\
+	{0, 1, -1 , -1,  2, -1, -1,  3}, /* Lane 3 */	\
+	{0, 1,  2 , -1, -1,  3, -1, -1}, /* Lane 4 */	\
+	{0, 1,  2 , -1,  3, -1, -1,  4}, /* Lane 5 */	\
+	{0, 1,  2 ,  4, -1,  3, -1, -1}, /* Lane 6 */	\
+	{0, 1, -1 ,  2, -1, -1,  3, -1}, /* Lane 7*/	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 8 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 9 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 10 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 11 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 12 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 13 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 14 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}	 /* Lane 15 */	\
+}
+
+
+/*
+	This enum should reflect the units numbers in register
+	space which we will need when accessing the HW
+*/
+
+typedef enum {
+	PEX0_0x4	= 0,
+	PEX0_1x4	= 1,
+	PEX0_2x4	= 2,
+	PEX0_3x4	= 3,
+	PEX1_0x4	= 4,
+	PEX1_1x4	= 5,
+	PEX1_2x4	= 6,
+	PEX1_3x4	= 7,
+	PEX2_0x4	= 8,
+	PEX3_0x4	= 9,
+	PEXIF_MAX	= 10
+} MV_PEXIF_INDX;
+
+#endif /* MV_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/ctrlEnv/mvCtrlEnvSpec.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/ctrlEnv/mvCtrlEnvSpec.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/ctrlEnv/mvCtrlEnvSpec.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/ctrlEnv/mvCtrlEnvSpec.h	2014-04-14 15:34:16.000000000 +0700
@@ -0,0 +1,494 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvSpech
+#define __INCmvCtrlEnvSpech
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define MV_ARM_SOC
+#define SOC_NAME_PREFIX				"MV88F"
+
+/*
+ * Armada-XP Units Address decoding
+ */
+#define MV_DRAM_REGS_OFFSET			(0x0)
+#define MV_AURORA_L2_REGS_OFFSET		(0x8000)
+#define MV_RTC_REGS_OFFSET			(0x10300)
+#define MV_DEV_BUS_REGS_OFFSET			(0x10400)
+#define MV_SPI_REGS_OFFSET(unit)		(0x10600 + (unit * 0x80))
+#define MV_TWSI_SLAVE_REGS_OFFSET(chanNum)	(0x11000 + (chanNum * 0x100))
+#define MV_UART_REGS_OFFSET(chanNum)		(0x12000 + (chanNum * 0x100))
+#define MV_RUNIT_PMU_REGS_OFFSET		(0x1C000)
+#define MV_MPP_REGS_OFFSET			(0x18000)
+#define MV_GPP_REGS_OFFSET(unit)		(0x18100 + ((unit) * 0x40))
+#define MV_MISC_REGS_OFFSET			(0x18200)
+#define MV_CLK_CMPLX_REGS_OFFSET	(0x18700)
+#define MV_MBUS_REGS_OFFSET			(0x20000)
+#define MV_COHERENCY_FABRIC_OFFSET		(0x20200)
+#define MV_CIB_CTRL_STATUS_OFFSET		(0x20280)
+#define MV_CNTMR_REGS_OFFSET			(0x20300)
+#define MV_CPUIF_LOCAL_REGS_OFFSET		(0x21000)
+#define MV_CPUIF_REGS_OFFSET(cpu)		(0x21800 + (cpu) * 0x100)
+#define MV_PMU_NFABRIC_UNIT_SERV_OFFSET		(0x22000)
+#define MV_CPU_PMU_UNIT_SERV_OFFSET(cpu)	(0x22100 + (cpu) * 0x100)
+#define MV_CPU_HW_SEM_OFFSET			(0x20500)
+
+#define MV_ETH_LEGACY
+
+#if defined(MV_ETH_LEGACY)
+	#define MV_ETH_BASE_ADDR		(0x72000)
+#else
+	#define MV_ETH_BASE_ADDR		(0x70000)
+#endif
+#define MV_ETH_REGS_OFFSET(port)		(MV_ETH_BASE_ADDR - ((port) / 2) * 0x40000 + ((port) % 2) * 0x4000)
+#define MV_PEX_IF_REGS_OFFSET(pexIf)		(pexIf < 8 ? (0x40000 + ((pexIf) / 4) * 0x40000 + ((pexIf) % 4) * 0x4000) \
+											 : (0x42000 + ((pexIf) % 8) * 0x40000))
+#define MV_USB_REGS_OFFSET(dev)       		(0x50000 + (dev * 0x1000))
+#define MV_XOR_REGS_OFFSET(unit)		(unit ? 0xF0900 : 0x60900)
+#if defined(MV_INCLUDE_IDMA)
+#define MV_IDMA_REGS_OFFSET			(0x60800)
+#endif
+#define MV_CESA_TDMA_REGS_OFFSET(chanNum)	(0x90000 + (chanNum * 0x2000))
+#define MV_CESA_REGS_OFFSET(chanNum)		(0x9D000 + (chanNum * 0x2000))
+#define MV_SATA_REGS_OFFSET			(0xA0000)
+#define MV_COMM_UNIT_REGS_OFFSET		(0xB0000)
+#define MV_NFC_REGS_OFFSET			(0xD0000)
+#define MV_BM_REGS_OFFSET			(0xC0000)
+#define MV_PNC_REGS_OFFSET			(0xC8000)
+#define MV_SDMMC_REGS_OFFSET			(0xD4000)
+
+
+#ifdef CONFIG_ARMADA_XP_ERRATA_SMI_1
+	#define MV_ETH_SMI_PORT   1
+#else
+    #define MV_ETH_SMI_PORT   0
+#endif
+
+#define MV_SERDES_NUM_TO_PEX_NUM(sernum)	((sernum < 8) ? (sernum) : (8 + (sernum/12)))
+/*
+ * Miscellanuous Controller Configurations
+ */
+
+#define AVS_CONTROL2_REG			0x20868
+#define AVS_LOW_VDD_LIMIT			0x20860
+
+#define INTER_REGS_SIZE				_1M
+
+/* This define describes the TWSI interrupt bit and location */
+#define TWSI_CPU_MAIN_INT_CAUSE_REG(cpu)	CPU_MAIN_INT_CAUSE_REG(1, (cpu))
+#define TWSI0_CPU_MAIN_INT_BIT(ch)		((ch) + 3)
+#define TWSI_SPEED				100000
+
+#define MV_GPP_MAX_PINS				68
+#define MV_GPP_MAX_GROUP    			3 /* group == configuration register? */
+#define MV_CNTMR_MAX_COUNTER 		8 /* 4 global + 1 global WD + 2 current private CPU + 1 private CPU WD*/
+
+/*
+	MV88F78X60_Z1								MV88F78X60_A0
+	-------------------------------             -------------------------------
+	Global Counters 0-3  : 0-3         		    Global Counters 0-3  		: 0-3
+	Global WD            : 4                    Global WD            		: 4
+
+	CPU 0 Counter 0-1    : 5-6					Private CPU Counter 0-1    : 5-6
+	CPU 0 WD             : 7                    Private CPU WD             : 7
+	CPU 1 Counter 0-1    : 8-9
+	CPU 1 WD             : 10
+	CPU 2 Counter 0-1    : 11-12
+	CPU 2 WD             : 13
+	CPU 3 Counter 0-1    : 14-15
+	CPU 3 WD             : 16
+*/
+
+#define MV_UART_MAX_CHAN			4
+
+#define MV_XOR_MAX_UNIT				2 /* XOR unit == XOR engine */
+#define MV_XOR_MAX_CHAN         		4 /* total channels for all units together*/
+#define MV_XOR_MAX_CHAN_PER_UNIT		2 /* channels for units */
+
+#if defined(MV_INCLUDE_IDMA)
+#define MV_IDMA_MAX_UNIT			1 /* IDMA unit == IDMA engine */
+#define MV_IDMA_MAX_CHAN			4 /* total channels for all units together */
+#endif
+
+#define MV_SATA_MAX_CHAN			2
+
+#define MV_MPP_MAX_GROUP			9
+
+#define MV_DRAM_MAX_CS				4
+#define MV_SPI_MAX_CS				8
+/* This define describes the maximum number of supported PCI\PCIX Interfaces */
+#ifdef MV_INCLUDE_PCI
+ #define MV_PCI_MAX_IF				1
+ #define MV_PCI_START_IF			0
+ #define PCI_HOST_BUS_NUM(pciIf)               (pciIf)
+ #define PCI_HOST_DEV_NUM(pciIf)               0
+#else
+ #define MV_PCI_MAX_IF				0
+ #define MV_PCI_START_IF			0
+#endif
+
+/* This define describes the maximum number of supported PEX Interfaces */
+#define MV_PEX_MAX_IF				10
+#define MV_PEX_MAX_UNIT				4
+#ifdef MV_INCLUDE_PEX
+#define MV_INCLUDE_PEX0
+#define MV_DISABLE_PEX_DEVICE_BAR
+
+#define MV_PEX_START_IF				MV_PCI_MAX_IF
+ #define PEX_HOST_BUS_NUM(pciIf)               (pciIf)
+ #define PEX_HOST_DEV_NUM(pciIf)               0
+#else
+ #undef MV_INCLUDE_PEX0
+#endif
+
+#define PCI_IO(pciIf)				(PEX0_IO + 2 * (pciIf))
+#define PCI_MEM(pciIf, memNum)			(PEX0_MEM0 + 2 * (pciIf))
+/* This define describes the maximum number of supported PCI Interfaces 	*/
+#define MV_IDMA_MAX_CHAN			4
+#define ARMADA_XP_MAX_USB_PORTS			3
+#define ARMADA_XP_NAND				1
+#define ARMADA_XP_SDIO				1
+#define ARMADA_XP_MAX_TDM_PORTS			32
+#define ARMADA_XP_TDM				1
+#define MV_DEVICE_MAX_CS      			4
+
+#ifndef MV_USB_MAX_PORTS
+#define MV_USB_MAX_PORTS (ARMADA_XP_MAX_USB_PORTS)
+#endif
+
+
+/* CESA version #3: One channel, 2KB SRAM, TDMA, CHAIN Mode support */
+#define MV_CESA_VERSION				3 /*TODO verify */
+#define MV_CESA_SRAM_SIZE               	(2 * 1024)
+
+
+/* This define describes the maximum number of supported Ethernet ports */
+/* TODO - verify all these numbers */
+#define MV_ETH_VERSION 				4 /* for Legacy mode */
+#define MV_NETA_VERSION				1 /* for NETA mode */
+#define MV_ETH_MAX_PORTS			4
+#define MV_ETH_MAX_RXQ              		8
+#define MV_ETH_MAX_TXQ              		8
+#define MV_ETH_TX_CSUM_MAX_SIZE 		9800
+#define MV_PNC_TCAM_LINES			1024	/* TCAM num of entries */
+
+/* New GMAC module is used */
+#define MV_ETH_GMAC_NEW
+/* New WRR/EJP module is used */
+#define MV_ETH_WRR_NEW
+/* IPv6 parsing support for Legacy parser */
+#define MV_ETH_LEGACY_PARSER_IPV6
+/* New PNC module - extra fields */
+#define MV_ETH_PNC_NEW
+/* PNC Load Balancing support */
+#define MV_ETH_PNC_LB
+
+#define MV_78130_ETH_MAX_PORT			3
+
+#if defined(RD_78XMP_WIFI)
+#define MV_78460_ETH_MAX_PORT                   2
+#else 
+#define MV_78460_ETH_MAX_PORT			4
+#endif
+/* This define describes the the support of USB */
+#define MV_USB_VERSION  			1
+
+#define MV_SPI_VERSION				2
+
+#define MV_INCLUDE_SDRAM_CS0
+#define MV_INCLUDE_SDRAM_CS1
+#define MV_INCLUDE_SDRAM_CS2
+#define MV_INCLUDE_SDRAM_CS3
+
+#define MV_INCLUDE_DEVICE_CS0
+#define MV_INCLUDE_DEVICE_CS1
+#define MV_INCLUDE_DEVICE_CS2
+#define MV_INCLUDE_DEVICE_CS3
+
+#ifndef MV_ASMLANGUAGE
+
+#define TBL_UNUSED	0	/* Used to mark unused entry */
+
+typedef enum {
+	TDM_UNIT_32CH
+} MV_TDM_UNIT_TYPE;
+
+/* This enumerator defines the Marvell Units ID      */
+typedef enum _mvUnitId {
+	DRAM_UNIT_ID,
+	PEX_UNIT_ID,
+	ETH_GIG_UNIT_ID,
+	USB_UNIT_ID,
+	IDMA_UNIT_ID,
+	XOR_UNIT_ID,
+	SATA_UNIT_ID,
+	TDM_32CH_UNIT_ID,
+	UART_UNIT_ID,
+	CESA_UNIT_ID,
+	SPI_UNIT_ID,
+	SDIO_UNIT_ID,
+	BM_UNIT_ID,
+	PNC_UNIT_ID,
+	MAX_UNITS_ID
+} MV_UNIT_ID;
+
+/* This enumerator describes the Marvell controller possible devices that   */
+/* can be connected to its device interface.                                */
+typedef enum _mvDevice {
+#if defined(MV_INCLUDE_DEVICE_CS0)
+	DEV_CS0 = 0,    /* Device connected to dev CS[0]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)
+	DEV_CS1 = 1,        /* Device connected to dev CS[1]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)
+	DEV_CS2 = 2,        /* Device connected to dev CS[2]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS3)
+	DEV_CS3 = 3,        /* Device connected to dev CS[2]    */
+#endif
+	BOOT_CS,        /* Device connected to BOOT dev    */
+	MV_DEV_MAX_CS = MV_DEVICE_MAX_CS
+} MV_DEVICE;
+
+/* This enumerator described the possible Controller paripheral targets.    */
+/* Controller peripherals are designated memory/IO address spaces that the  */
+/* controller can access. They are also refered as "targets"                */
+typedef enum _mvTarget {
+	TBL_TERM = -1, 	/* none valid target, used as targets list terminator*/
+	SDRAM_CS0,	/*0 SDRAM chip select 0		*/
+	SDRAM_CS1,	/*1 SDRAM chip select 1		*/
+	SDRAM_CS2,	/*2 SDRAM chip select 2		*/
+	SDRAM_CS3,	/*3 SDRAM chip select 3		*/
+	DEVICE_CS0,	/*4 Device chip select 0		*/
+	DEVICE_CS1,	/*5 Device chip select 1		*/
+	DEVICE_CS2,	/*6 Device chip select 2		*/
+	DEVICE_CS3,	/*7 Device chip select 3		*/
+	PEX0_MEM,	/*8 PCI Express 0 Memory		*/
+	PEX0_IO,	/*9 PCI Express 0 IO		*/
+	PEX1_MEM,	/*10 PCI Express 1 Memory		*/
+	PEX1_IO,	/*11 PCI Express 1 IO		*/
+	PEX2_MEM,	/*12 PCI Express 2 Memory		*/
+	PEX2_IO,	/*13 PCI Express 2 IO		*/
+	PEX3_MEM,	/*14 PCI Express 3 Memory		*/
+	PEX3_IO,	/*15 PCI Express 3 IO		*/
+	PEX4_MEM,	/*16 PCI Express 4 Memory		*/
+	PEX4_IO,	/*17 PCI Express 4 IO		*/
+	PEX5_MEM,	/*18 PCI Express 5 Memory		*/
+	PEX5_IO,	/*19 PCI Express 5 IO		*/
+	PEX6_MEM,	/*20 PCI Express 6 Memory		*/
+	PEX6_IO,	/*21 PCI Express 6 IO		*/
+	PEX7_MEM,	/*22 PCI Express 7 Memory		*/
+	PEX7_IO,	/*23 PCI Express 7 IO		*/
+	PEX8_MEM,	/*24 PCI Express 8 Memory		*/
+	PEX8_IO,	/*25 PCI Express 8 IO		*/
+	PEX9_MEM,	/*26 PCI Express 9 Memory		*/
+	PEX9_IO,	/*27 PCI Express 9 IO		*/
+	INTER_REGS,	/*28 Internal registers		*/
+	DMA_UART,	/*29 DMA based UART request	*/
+	SPI_CS0,	/*30 SPI_CS0			*/
+	SPI_CS1,	/*31 SPI_CS1			*/
+	SPI_CS2,	/*32 SPI_CS2			*/
+	SPI_CS3,	/*33 SPI_CS3			*/
+	SPI_CS4,	/*34 SPI_CS4			*/
+	SPI_CS5,	/*35 SPI_CS5			*/
+	SPI_CS6,	/*36 SPI_CS6			*/
+	SPI_CS7,	/*37 SPI_CS7			*/
+	BOOT_ROM_CS, /*38 BOOT_ROM_CS			*/
+	DEV_BOOCS,	/*39 DEV_BOOCS			*/
+	PMU_SCRATCHPAD,	/*40 PMU Scratchpad		*/
+	CRYPT0_ENG,	/* 41 Crypto0 Engine		*/
+	CRYPT1_ENG,	/* 42 Crypto1 Engine		*/
+	PNC_BM,		/* 43 PNC + BM 		        */
+	MAX_TARGETS
+} MV_TARGET;
+
+#ifdef AURORA_IO_CACHE_COHERENCY
+#define DRAM_CS0_ATTR		0x1E
+#define DRAM_CS1_ATTR		0x1D
+#define DRAM_CS2_ATTR		0x1B
+#define DRAM_CS3_ATTR		0x17
+#else
+#define DRAM_CS0_ATTR		0x0E
+#define DRAM_CS1_ATTR		0x0D
+#define DRAM_CS2_ATTR		0x0B
+#define DRAM_CS3_ATTR		0x07
+#endif
+
+#ifdef CONFIG_MACH_ARMADA_XP_FPGA
+ #define MAIN_BOOT_ATTR		0x2F	/* Boot Device CS - NOR */
+ #define SEC_BOOT_ATTR		0x1D	/* BootROM - Dummy */
+#else
+ #define MAIN_BOOT_ATTR		0x1D	/* BootROM */
+ #define SEC_BOOT_ATTR		0x2F	/* Boot Device CS */
+#endif
+
+#define TARGETS_DEF_ARRAY	{			\
+	{DRAM_CS0_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS0 */	\
+	{DRAM_CS1_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS1 */	\
+	{DRAM_CS2_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS0 */	\
+	{DRAM_CS3_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS1 */	\
+	{0x3E, DEV_TARGET_ID    }, /* DEVICE_CS0 */	\
+	{0x3D, DEV_TARGET_ID    }, /* DEVICE_CS1 */	\
+	{0x3B, DEV_TARGET_ID    }, /* DEVICE_CS2 */	\
+	{0x37, DEV_TARGET_ID    }, /* DEVICE_CS3 */	\
+	{0xE8, PEX0_2_TARGET_ID }, /* PEX0_LANE0_MEM */	\
+	{0xE0, PEX0_2_TARGET_ID }, /* PEX0_LANE0_IO */	\
+	{0xD8, PEX0_2_TARGET_ID }, /* PEX0_LANE1_MEM */	\
+	{0xD0, PEX0_2_TARGET_ID }, /* PEX0_LANE1_IO */	\
+	{0xB8, PEX0_2_TARGET_ID }, /* PEX0_LANE2_MEM */	\
+	{0xB0, PEX0_2_TARGET_ID }, /* PEX0_LANE2_IO */	\
+	{0x78, PEX0_2_TARGET_ID }, /* PEX0_LANE3_MEM */	\
+	{0x70, PEX0_2_TARGET_ID }, /* PEX0_LANE3_IO */	\
+	{0xE8, PEX1_3_TARGET_ID }, /* PEX1_LANE0_MEM */	\
+	{0xE0, PEX1_3_TARGET_ID }, /* PEX1_LANE0_IO */	\
+	{0xD8, PEX1_3_TARGET_ID }, /* PEX1_LANE1_MEM */	\
+	{0xD0, PEX1_3_TARGET_ID }, /* PEX1_LANE1_IO */	\
+	{0xB8, PEX1_3_TARGET_ID }, /* PEX1_LANE2_MEM */	\
+	{0xB0, PEX1_3_TARGET_ID }, /* PEX1_LANE2_IO */	\
+	{0x78, PEX1_3_TARGET_ID }, /* PEX1_LANE3_MEM */	\
+	{0x70, PEX1_3_TARGET_ID }, /* PEX1_LANE3_IO */	\
+	{0xF8, PEX0_2_TARGET_ID }, /* PEX2_LANE0_MEM */	\
+	{0xF0, PEX0_2_TARGET_ID }, /* PEX2_LANE0_IO */	\
+	{0xF8, PEX1_3_TARGET_ID }, /* PEX3_LANE0_MEM */	\
+	{0xF0, PEX1_3_TARGET_ID }, /* PEX3_LANE0_IO */	\
+	{0xFF, 0xFF             }, /* INTER_REGS */	\
+	{0x01, DEV_TARGET_ID    }, /* DMA_UART */	\
+	{0x1E, DEV_TARGET_ID    }, /* SPI_CS0 */	\
+	{0x5E, DEV_TARGET_ID    }, /* SPI_CS1 */	\
+	{0x9E, DEV_TARGET_ID    }, /* SPI_CS2 */	\
+	{0xDE, DEV_TARGET_ID    }, /* SPI_CS3 */	\
+	{0x1F, DEV_TARGET_ID    }, /* SPI_CS4 */	\
+	{0x5F, DEV_TARGET_ID    }, /* SPI_CS5 */	\
+	{0x9F, DEV_TARGET_ID    }, /* SPI_CS6 */	\
+	{0xDF, DEV_TARGET_ID    }, /* SPI_CS7 */	\
+	{MAIN_BOOT_ATTR, DEV_TARGET_ID    }, /* Main Boot device */	\
+	{SEC_BOOT_ATTR, DEV_TARGET_ID    }, /* Secondary Boot device, */	\
+	{0x2D, DEV_TARGET_ID    }, /* PMU_SCRATCHPAD */	\
+	{0x01, CRYPT_TARGET_ID  }, /* CRYPT_ENG0 */	\
+	{0x05, CRYPT_TARGET_ID  }, /* CRYPT_ENG1 */     \
+	{0x00, PNC_BM_TARGET_ID }, /* PNC_BM */		\
+}
+
+#define CESA_TARGET_NAME_DEF	("CRYPT_ENG0", "CRYPT_ENG1")
+#define TARGETS_NAME_ARRAY	{		\
+	"SDRAM_CS0",    /* SDRAM_CS0 */		\
+	"SDRAM_CS1",    /* SDRAM_CS1 */		\
+	"SDRAM_CS2",    /* SDRAM_CS1 */		\
+	"SDRAM_CS3",    /* SDRAM_CS1 */		\
+	"DEVICE_CS0",	/* DEVICE_CS0 */	\
+	"DEVICE_CS1",	/* DEVICE_CS1 */	\
+	"DEVICE_CS2",	/* DEVICE_CS2 */	\
+	"DEVICE_CS3",	/* DEVICE_CS3 */	\
+	"PEX0_MEM",	/* PEX0_MEM */		\
+	"PEX0_IO",	/* PEX0_IO */		\
+	"PEX1_MEM",	/* PEX1_MEM */		\
+	"PEX1_IO",	/* PEX1_IO */		\
+	"PEX2_MEM",	/* PEX2_MEM */		\
+	"PEX2_IO",	/* PEX2_IO */		\
+	"PEX3_MEM",	/* PEX3_MEM */		\
+	"PEX3_IO",	/* PEX3_IO */		\
+	"PEX4_MEM",	/* PEX4_MEM */		\
+	"PEX4_IO",	/* PEX4_IO */		\
+	"PEX5_MEM",	/* PEX5_MEM */		\
+	"PEX5_IO",	/* PEX5_IO */		\
+	"PEX6_MEM",	/* PEX6_MEM */		\
+	"PEX6_IO",	/* PEX6_IO */		\
+	"PEX7_MEM",	/* PEX7_MEM */		\
+	"PEX7_IO",	/* PEX7_IO */		\
+	"PEX8_MEM",	/* PEX8_MEM */		\
+	"PEX8_IO",	/* PEX8_IO */		\
+	"PEX9_MEM",	/* PEX9_MEM */		\
+	"PEX9_IO",	/* PEX9_IO */		\
+	"INTER_REGS",	/* INTER_REGS */	\
+	"DMA_UART",	/* DMA_UART */		\
+	"SPI_CS0",	/* SPI_CS0 */		\
+	"SPI_CS1",	/* SPI_CS1 */		\
+	"SPI_CS2",	/* SPI_CS2 */		\
+	"SPI_CS3",	/* SPI_CS3 */		\
+	"SPI_CS4",	/* SPI_CS4 */		\
+	"SPI_CS5",	/* SPI_CS5 */		\
+	"SPI_CS6",	/* SPI_CS6 */		\
+	"SPI_CS7",	/* SPI_CS7 */		\
+	"BOOT_ROM_CS",	/* BOOT_ROM_CS */	\
+	"DEV_BOOTCS",	/* DEV_BOOCS */		\
+	"PMU_SCRATCHPAD",/* PMU_SCRATCHPAD */	\
+	"CRYPT1_ENG",	/* CRYPT1_ENG */	\
+	"CRYPT2_ENG",	/* CRYPT2_ENG */	\
+	"PNC_BM"	/* PNC_BM */		\
+}
+
+
+
+
+#endif /* MV_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvCtrlEnvSpech */
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/ctrlEnv/sys/mvCpuIf.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/ctrlEnv/sys/mvCpuIf.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/ctrlEnv/sys/mvCpuIf.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/ctrlEnv/sys/mvCpuIf.h	2014-03-26 16:39:30.000000000 +0700
@@ -0,0 +1,131 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCpuIfh
+#define __INCmvCpuIfh
+
+#if 0
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+#include "ctrlEnv/sys/mvAhbToMbus.h"
+#if defined(MV_INCLUDE_PEX)
+#include "pex/mvPex.h"
+#endif
+#endif
+
+#include "../mvCtrlEnvLib.h"
+#include "mvCpuIfRegs.h"
+
+
+
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* defines  */
+
+/* typedefs */
+/* This structure describes CPU interface address decode window	*/
+typedef struct _mvCpuIfDecWin {
+	MV_ADDR_WIN	addrWin;	/* An address window */
+	MV_U32		winNum;		/* Window Number in the AHB To Mbus bridge */
+	MV_BOOL		enable;		/* Address decode window is enabled/disabled */
+} MV_CPU_DEC_WIN;
+
+
+/* mvCpuIfLib.h API list */
+
+/* mvCpuIfLib.h API list */
+
+MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap);
+MV_STATUS mvCpuIfVerify(MV_CPU_DEC_WIN *cpuAddrWinMap);
+MV_STATUS mvCpuIfDramInit(MV_VOID);
+MV_STATUS mvCpuIfTargetWinSet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin);
+MV_STATUS mvCpuIfTargetWinGet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin);
+MV_STATUS mvCpuIfTargetWinEnable(MV_TARGET target, MV_BOOL enable);
+MV_U32    mvCpuIfTargetWinSizeGet(MV_TARGET target);
+MV_U32    mvCpuIfTargetWinBaseLowGet(MV_TARGET target);
+MV_U32    mvCpuIfTargetWinBaseHighGet(MV_TARGET target);
+MV_TARGET mvCpuIfTargetOfBaseAddressGet(MV_U32 baseAddress);
+MV_STATUS mvCpuIfSramWinDisable(MV_VOID);
+#if defined(MV_INCLUDE_PEX)
+MV_U32    mvCpuIfPexRemap(MV_TARGET pexTarget, MV_ADDR_WIN *pAddrDecWin);
+#endif
+#if defined(MV_INCLUDE_PCI)
+MV_U32 	  mvCpuIfPciRemap(MV_TARGET pciTarget, MV_ADDR_WIN *pAddrDecWin);
+#endif
+MV_VOID   mvCpuIfAddDecShow(MV_VOID);
+
+MV_STATUS mvCpuIfLvdsPadsEnable(MV_BOOL enable);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvCpuIfh */
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/ctrlEnv/sys/mvCpuIfRegs.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/ctrlEnv/sys/mvCpuIfRegs.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/ctrlEnv/sys/mvCpuIfRegs.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/ctrlEnv/sys/mvCpuIfRegs.h	2014-03-26 16:43:12.000000000 +0700
@@ -0,0 +1,373 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCpuIfRegsh
+#define __INCmvCpuIfRegsh
+
+/****************************************/
+/* ARM Control and Status Registers Map */
+/****************************************/
+
+#if 0
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+#endif
+
+#include "../mvCtrlEnvSpec.h"
+#include "../mvCtrlEnvRegs.h"
+
+
+
+
+
+
+#define MV_CPUIF_REGS_BASE(cpu)			(MV_CPUIF_REGS_OFFSET(cpu))
+#define MV_MISC_REGS_BASE			(MV_MISC_REGS_OFFSET)
+#define MV_CLK_CMPLX_REGS_BASE		(MV_CLK_CMPLX_REGS_OFFSET)
+#define MV_L2C_REGS_BASE			(MV_AURORA_L2_REGS_OFFSET)
+#define MV_CPUIF_SHARED_REGS_BASE		(MV_MBUS_REGS_OFFSET)
+#define MV_COHERENCY_FABRIC_REGS_BASE		(MV_COHERENCY_FABRIC_OFFSET)
+
+#define CPU_CONFIG_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu))
+#define CPU_CTRL_STAT_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu) + 0x8)
+#define CPU_RESUME_ADDR_REG(cpu)		(MV_CPUIF_SHARED_REGS_BASE + (0x2124) + (cpu)*0x100)
+#define CPU_RESET_REG(cpu)			(MV_CPUIF_SHARED_REGS_BASE + (0x800+(cpu)*8))
+#define CPU_RESUME_CTRL_REG			(MV_CPUIF_SHARED_REGS_BASE + (0x988))
+#define CPU_RSTOUTN_MASK_REG			(MV_MISC_REGS_BASE + 0x60)
+#define CPU_SYS_SOFT_RST_REG			(MV_MISC_REGS_BASE + 0x64)
+#define CPU_L2_CTRL_REG				(MV_L2C_REGS_BASE + 0x100)
+#define CPU_L2_AUX_CTRL_REG			(MV_L2C_REGS_BASE + 0x104)
+#define SOC_CTRL_REG				(MV_MISC_REGS_BASE + 0x4)
+#define LVDS_PADS_CTRL_REG			(MV_MISC_REGS_BASE + 0xF0)
+#define SOC_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_REGS_BASE)
+#define SOC_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_REGS_BASE + 0x4)
+#define SOC_CIB_CTRL_CFG_REG			(MV_COHERENCY_FABRIC_REGS_BASE + 0x80)
+
+#define Fabric_Units_Priority_Control_REG	(MV_MBUS_REGS_OFFSET + 0x424)
+#define Fabric_Units_Prefetch_Control_REG	(MV_MBUS_REGS_OFFSET + 0x42c)
+#define CPUs_Data_PFen (0xf << 8)
+#define CPUs_Data_PFen_MASK (0xf << 8)
+#define CPU_PRIO_HIGH  0x2
+#define CPUs_PRIO_MASK 0xff
+#define CPU0_PRIO_HIGH (CPU_PRIO_HIGH << 0)
+#define CPU1_PRIO_HIGH (CPU_PRIO_HIGH << 2)
+#define CPU2_PRIO_HIGH (CPU_PRIO_HIGH << 4)
+#define CPU3_PRIO_HIGH (CPU_PRIO_HIGH << 6)
+/*   SoC Control Register bits  */
+#define PCIE0_QUADX1_EN				(1<<7)
+#define PCIE1_QUADX1_EN				(1<<8)
+
+/* ARM Configuration register */
+/* CPU_CONFIG_REG (CCR) */
+
+/* Reset vector location */
+#define CCR_VEC_INIT_LOC_OFFS			1
+#define CCR_VEC_INIT_LOC_MASK			(1 << CCR_VEC_INIT_LOC_OFFS)
+/* reset at 0x00000000 */
+#define CCR_VEC_INIT_LOC_0000			(0 << CCR_VEC_INIT_LOC_OFFS)
+/* reset at 0xFFFF0000 */
+#define CCR_VEC_INIT_LOC_FF00			(1 << CCR_VEC_INIT_LOC_OFFS)
+
+#define CCR_ENDIAN_INIT_OFFS			3
+#define CCR_ENDIAN_INIT_MASK			(1 << CCR_ENDIAN_INIT_OFFS)
+#define CCR_ENDIAN_INIT_LITTLE			(0 << CCR_ENDIAN_INIT_OFFS)
+#define CCR_ENDIAN_INIT_BIG			(1 << CCR_ENDIAN_INIT_OFFS)
+
+#define CCR_ARM_ID_SEL_OFFS			4
+#define CCR_CPU_ID_SEL_MASK			(1 << CCR_ARM_ID_SEL_OFFS)
+#define CCR_CPU_ID_SEL_ARM			(0 << CCR_ARM_ID_SEL_OFFS)
+#define CCR_CPU_ID_SEL_MRVL			(1 << CCR_ARM_ID_SEL_OFFS)
+
+#define CCR_TE_INIT_OFFS			5
+#define CCR_TE_INIT_MASK			(1 << CCR_NCB_BLOCKING_OFFS)
+#define CCR_TE_INIT_ARM				(0 << CCR_NCB_BLOCKING_OFFS)
+#define CCR_TE_INIT_THUMB			(1 << CCR_NCB_BLOCKING_OFFS)
+
+#define CCR_NFMI_EN_OFFS			6
+#define CCR_NFMI_EN_MASK			(1 << CCR_NFMI_EN_OFFS)
+#define CCR_NFMI_EN_DIS				(0 << CCR_NFMI_EN_OFFS)
+#define CCR_NFMI_EN_EN				(1 << CCR_NFMI_EN_OFFS)
+
+#define CCR_CORE_MODE_OFFS			9
+#define CCR_CORE_MODE_MASK			(3 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_ARM1176			(0 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_CORTEX_A8			(1 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_ARM11_MPC			(2 << CCR_CORE_MODE_OFFS)
+
+#define CCR_UBIT_INIT_OFFS			11
+#define CCR_UBIT_INIT_MASK			(1 << CCR_UBIT_INIT_OFFS)
+#define CCR_UBIT_INIT_DIS			(0 << CCR_UBIT_INIT_OFFS)
+#define CCR_UBIT_INIT_EN			(1 << CCR_UBIT_INIT_OFFS)
+
+#define CCR_PCLK_WFI_OFFS			15
+#define CCR_PCLK_WFI_MASK			(1 << CCR_PCLK_WFI_OFFS)
+#define CCR_PCLK_WFI_DIS			(0 << CCR_PCLK_WFI_OFFS)
+#define CCR_PCLK_WFI_EN				(1 << CCR_PCLK_WFI_OFFS)
+
+#define CCR_SHARED_L2_OFFS			16
+#define CCR_SHARED_L2_MASK			(1 << CCR_SHARED_L2_OFFS)
+#define CCR_SHARED_L2_DIS			(0 << CCR_SHARED_L2_OFFS)
+#define CCR_SHARED_L2_EN			(1 << CCR_SHARED_L2_OFFS)
+
+#define CCR_SP_IN_MP_OFFS			17
+#define CCR_SP_IN_MP_MASK			(1 << CCR_SP_IN_MP_OFFS)
+#define CCR_SP_IN_MP_DIS			(0 << CCR_SP_IN_MP_OFFS)
+#define CCR_SP_IN_MP_EN				(1 << CCR_SP_IN_MP_OFFS)
+
+#define CCR_SRAM_LOW_LEAK_OFFS			19
+#define CCR_SRAM_LOW_LEAK_MASK			(1 << CCR_SRAM_LOW_LEAK_OFFS)
+#define CCR_SRAM_LOW_LEAK_EN			(0 << CCR_SRAM_LOW_LEAK_OFFS)
+#define CCR_SRAM_LOW_LEAK_DIS			(1 << CCR_SRAM_LOW_LEAK_OFFS)
+
+#define CCR_CLUSTER_ID_OFFS			24
+#define CCR_CLUSTER_ID_MASK			(0xF << CCR_SRAM_LOW_LEAK_OFFS)
+
+
+/* ARM Control and Status register */
+/* CPU_CTRL_STAT_REG (CCSR) */
+
+#define CCSR_SMP_N_AMP_OFFS			0
+#define CCSR_SMP_N_AMP_MASK			(1 << CCSR_SMP_N_AMP_OFFS)
+
+#define CCSR_ENDIAN_STATUS_OFFS			15
+#define CCSR_ENDIAN_STATUS_MASK			(1 << CCSR_ENDIAN_STATUS_OFFS)
+#define CCSR_ENDIAN_STATUS_LITTLE		(0 << CCSR_ENDIAN_STATUS_OFFS)
+#define CCSR_ENDIAN_STATUS_BIG			(1 << CCSR_ENDIAN_STATUS_OFFS)
+
+
+/* RSTOUTn Mask Register */
+/* CPU_RSTOUTN_MASK_REG (CRMR) */
+
+#define CRMR_SOFT_RST_OUT_OFFS			0
+#define CRMR_SOFT_RST_OUT_MASK			(1 << CRMR_SOFT_RST_OUT_OFFS)
+#define CRMR_SOFT_RST_OUT_ENABLE		(1 << CRMR_SOFT_RST_OUT_OFFS)
+#define CRMR_SOFT_RST_OUT_DISABLE		(0 << CRMR_SOFT_RST_OUT_OFFS)
+
+#define CRMR_PEX_SYSRST_OUT_OFFS(bus)		(1 + ((bus) & 0x3))
+#define CRMR_PEX_SYSRST_OUT_MASK(bus)		(1 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+#define CRMR_PEX_SYSRST_OUT_ENABLE(bus)		(1 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+#define CRMR_PEX_SYSRST_OUT_DISABLE(bus)	(0 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+
+#define CRMR_PEX_TRST_OUT_OFFS(bus)		(5 + ((bus) & 0x3))
+#define CRMR_PEX_TRST_OUT_MASK(bus)		(1 << CRMR_PEX_TRST_OUT_OFFS(bus))
+#define CRMR_PEX_TRST_OUT_ENABLE(bus)		(1 << CRMR_PEX_TRST_OUT_OFFS(bus))
+#define CRMR_PEX_TRST_OUT_DISABLE(bus)		(0 << CRMR_PEX_TRST_OUT_OFFS(bus))
+
+
+/* System Software Reset Register */
+/* CPU_SYS_SOFT_RST_REG (CSSRR) */
+
+#define CSSRR_SYSTEM_SOFT_RST			BIT0
+
+
+/* CPU_L2_CTRL_REG fields */
+
+#define CL2CR_L2_EN_OFFS			0
+#define CL2CR_L2_EN_MASK			(1 << CL2CR_L2_EN_OFFS)
+
+/* CPU_L2_AUX_CTRL_REG fields */
+
+#define CL2ACR_WB_WT_ATTR_OFFS			0
+#define CL2ACR_WB_WT_ATTR_MASK			(3 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_PAGE			(0 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_WB			(1 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_WT			(2 << CL2ACR_WB_WT_ATTR_OFFS)
+
+#define CL2ACR_PFU_OFFS				2
+#define CL2ACR_PFU_MASK				(1 << CL2ACR_PFU_OFFS)
+#define CL2ACR_PFU_EN				(1 << CL2ACR_PFU_OFFS)
+#define CL2ACR_PFU_DIS				(0 << CL2ACR_PFU_OFFS)
+
+#define CL2ACR_L2_SIZE_OFFS			10
+#define CL2ACR_L2_SIZE_MASK			(3 << CL2ACR_L2_SIZE_OFFS)
+#define CL2ACR_L2_SIZE_KB(reg)			((((((reg) & 0x3) & CL2ACR_L2_SIZE_MASK) \
+						>> CL2ACR_PFU_OFFS) + 1) * _512K)
+
+#define CL2ACR_ASSOC_OFFS			13
+#define CL2ACR_ASSOC_MASK			(0xF << CL2ACR_ASSOC_OFFS)
+
+#define CL2ACR_L2_WAY_SZ_OFFS			17
+#define CL2ACR_L2_WAY_SZ_MASK			(7 << CL2ACR_L2_WAY_SZ_OFFS)
+#define CL2ACR_L2_WAY_SZ_KB(reg)		(_16K << (((((reg) & 0x7) & CL2ACR_L2_SIZE_MASK) \
+						>> CL2ACR_L2_WAY_SZ_OFFS)))
+
+#define CL2ACR_ECC_OFFS				20
+#define CL2ACR_ECC_MASK				(1 << CL2ACR_ECC_OFFS)
+#define CL2ACR_ECC_EN				(1 << CL2ACR_ECC_OFFS)
+#define CL2ACR_ECC_DIS				(0 << CL2ACR_ECC_OFFS)
+
+#define CL2ACR_PARITY_OFFS			21
+#define CL2ACR_PARITY_MASK			(1 << CL2ACR_PARITY_OFFS)
+#define CL2ACR_PARITY_EN			(1 << CL2ACR_PARITY_OFFS)
+#define CL2ACR_PARITY_DIS			(0 << CL2ACR_PARITY_OFFS)
+
+#define CL2ACR_INVAL_UCE_OFFS			22
+#define CL2ACR_INVAL_UCE_MASK			(1 << CL2ACR_INVAL_UCE_OFFS)
+#define CL2ACR_INVAL_UCE_EN			(1 << CL2ACR_INVAL_UCE_OFFS)
+#define CL2ACR_INVAL_UCE_DIS			(0 << CL2ACR_INVAL_UCE_OFFS)
+
+#define CL2ACR_FORCE_WA_OFFS			23
+#define CL2ACR_FORCE_WA_MASK			(3 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_WA_DISABLE			(0 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_NO_WA			(1 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_WA				(2 << CL2ACR_FORCE_WA_OFFS)
+
+#define CL2ACR_REP_STRGY_OFFS			27
+#define CL2ACR_REP_STRGY_MASK			(3 << CL2ACR_REP_STRGY_OFFS)
+
+#define CL2ACR_REP_STRGY_LFSR_MASK              (0x1 << CL2ACR_REP_STRGY_OFFS)
+#define CL2ACR_REP_STRGY_semiPLRU_MASK		(0x2 << CL2ACR_REP_STRGY_OFFS)
+#define CL2ACR_REP_STRGY_semiPLRU_WA_MASK          (0x3 << CL2ACR_REP_STRGY_OFFS)
+#define CL2_DUAL_EVICTION		(0x1 << 4)
+#define CL2_PARITY_ENABLE		(0x1 << 21)
+#define CL2_InvalEvicLineUCErr          (0x1 << 22)
+
+/* SOC_CTRL_REG fields */
+#define SCR_PEX_ENA_OFFS(pex)			((pex) & 0x3)
+#define SCR_PEX_ENA_MASK(pex)			(1 << pex)
+
+#define SCR_PEX_4BY1_OFFS(pex)			((pex) + 7)
+#define SCR_PEX_4BY1_MASK(pex)			(1 << SCR_PEX_4BY1_OFFS(pex))
+
+#define SCR_PEX0_4BY1_OFFS			7
+#define SCR_PEX0_4BY1_MASK			(1 << SCR_PEX0_4BY1_OFFS)
+
+#define SCR_PEX1_4BY1_OFFS			8
+#define SCR_PEX1_4BY1_MASK			(1 << SCR_PEX1_4BY1_OFFS)
+
+#define PCIE1_CLK_OUT_EN_OFF                   5
+#define PCIE1_CLK_OUT_EN_MASK                  (1 << PCIE1_CLK_OUT_EN_OFF)
+
+#define PCIE0_CLK_OUT_EN_OFF                   4
+#define PCIE0_CLK_OUT_EN_MASK                  (1 << PCIE0_CLK_OUT_EN_OFF)
+
+/* LVDS_PADS_CTRL_REG fields */
+#define LVDS_PADS_CONF_PD_OFFS(idx)		(16 + idx)
+#define LVDS_PADS_CONF_PD_MASK(idx)		(1 << (16 + idx))
+#define LVDS_PADS_CONF_PD_EN(idx, en)		((en ? 0 : 1) << LVDS_PADS_CONF_PD_OFFS(idx))
+
+
+/*******************************************/
+/* Main Interrupt Controller Registers Map */
+/*******************************************/
+
+#define CPU_MAIN_INT_CAUSE_REG(vec, cpu)	(MV_CPUIF_REGS_BASE(cpu) + 0x80 + (vec * 0x4))
+#define CPU_MAIN_INT_TWSI_OFFS(i)			(2 + i)
+#define CPU_MAIN_INT_CAUSE_TWSI(i)			(31 + i)
+
+#define CPU_CF_LOCAL_MASK_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu) + 0xc4)
+#define CPU_CF_LOCAL_MASK_PMU_MASK_OFFS		18
+#define CPU_INT_SOURCE_CONTROL_REG(i)		(MV_CPUIF_SHARED_REGS_BASE + 0xB00 + (i * 0x4))
+
+#define CPU_INT_SOURCE_CONTROL_IRQ_OFFS		28
+#define CPU_INT_SOURCE_CONTROL_IRQ_MASK		(1 << CPU_INT_SOURCE_CONTROL_IRQ_OFFS )
+
+#define CPU_INT_SET_ENABLE_REG			(MV_CPUIF_SHARED_REGS_BASE + 0xA30)
+#define CPU_INT_CLEAR_ENABLE_REG		(MV_CPUIF_SHARED_REGS_BASE + 0xA34)
+
+#define CPU_INT_SET_MASK_OFFS			(0xB8)
+#define CPU_INT_CLEAR_MASK_OFFS			(0xBC)
+
+#define CPU_INT_SET_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + CPU_INT_SET_MASK_OFFS)
+#define CPU_INT_CLEAR_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + CPU_INT_CLEAR_MASK_OFFS)
+
+#define CPU_INT_SET_MASK_LOCAL_REG		(MV_CPUIF_LOCAL_REGS_OFFSET + CPU_INT_SET_MASK_OFFS)
+#define CPU_INT_CLEAR_MASK_LOCAL_REG	(MV_CPUIF_LOCAL_REGS_OFFSET + CPU_INT_CLEAR_MASK_OFFS)
+
+#define CPU_SNOOP_FILTER_CTRL_REG		(MV_CPUIF_LOCAL_REGS_OFFSET + 0x20)
+
+#define MV_IRQ_NR							116
+
+
+/*******************************************/
+/* ARM Doorbell Registers Map		   */
+/*******************************************/
+#define CPU_SW_TRIG_IRQ						(MV_MBUS_REGS_OFFSET + 0xA04)
+#define CPU_DOORBELL_IN_REG					(MV_CPUIF_LOCAL_REGS_OFFSET + 0x78)
+#define CPU_DOORBELL_IN_MASK_REG			(MV_CPUIF_LOCAL_REGS_OFFSET + 0x7C)
+#define CPU_HOST_TO_ARM_DRBL_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x78)
+#define CPU_HOST_TO_ARM_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x7C)
+#define CPU_ARM_TO_HOST_DRBL_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x70)
+#define CPU_ARM_TO_HOST_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x74)
+
+/*******************************************/
+/* CLOCK Complex Registers Map			   */
+/*******************************************/
+
+#define CPU_DIV_CLK_CTRL0_REG				(MV_CLK_CMPLX_REGS_OFFSET)
+#define CPU_DIV_CLK_CTRL0_RESET_MASK_OFFS	8
+#define CPU_DIV_CLK_CTRL2_RATIO_FULL0_REG	(MV_CLK_CMPLX_REGS_OFFSET + 0x8)
+#define CPU_DIV_CLK_CTRL2_NB_RATIO_OFFS		16
+#define CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG	(MV_CLK_CMPLX_REGS_OFFSET + 0xC)
+#define CPU_DIV_CLK_CTRL3_CPU_RATIO_OFFS	8
+
+/* CPU control register map */
+/* Set bits means value is about to change according to new value */
+#define CPU_CONFIG_DEFAULT_MASK         	(CCR_VEC_INIT_LOC_MASK)
+#define CPU_CONFIG_DEFAULT                      (CCR_VEC_INIT_LOC_FF00)
+
+
+#endif /* __INCmvCpuIfRegsh */
+
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/dsdt/Copyright.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/dsdt/Copyright.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/dsdt/Copyright.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/dsdt/Copyright.h	2014-04-08 19:38:52.000000000 +0700
@@ -0,0 +1,60 @@
+
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms. Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+********************************************************************************
+Marvell Commercial License Option
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+********************************************************************************
+Marvell GPL License Option
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED. The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+* Redistributions of source code must retain the above copyright notice,
+this list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+* Neither the name of Marvell nor the names of its contributors may be
+used to endorse or promote products derived from this software without
+specific prior written permission.
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*******************************************************************************/
+
+#ifndef _msCopyright_h
+#define _msCopyright_h
+
+#define MSAPI_COPYRIGHT "Copyright 2000~2011, Marvell International Ltd."
+#define MSAPI_VERSION "3.0D"
+
+#endif /* _msCopyright_h */
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/dsdt/gtDrvSwRegs.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/dsdt/gtDrvSwRegs.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/dsdt/gtDrvSwRegs.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/dsdt/gtDrvSwRegs.h	2014-04-08 19:37:48.000000000 +0700
@@ -0,0 +1,299 @@
+#include "Copyright.h"
+
+/********************************************************************************
+ * * gtDrvSwRegs.h
+ * *
+ * * DESCRIPTION:
+ * *       definitions of the register map of QuarterDeck Device
+ * *
+ * * DEPENDENCIES:
+ * *
+ * * FILE REVISION NUMBER:
+ * *
+ * *******************************************************************************/
+#ifndef __gtDrvSwRegsh
+#define __gtDrvSwRegsh
+
+/* QuarterDeck Per Port Registers */
+#define QD_REG_PORT_STATUS        0x0
+#define QD_REG_PCS_CONTROL        0x1        /* for Sapphire family */
+#define QD_REG_LIMIT_PAUSE_CONTROL        0x2        /* Jamming control register */
+#define QD_REG_SWITCH_ID        0x3
+#define QD_REG_PORT_CONTROL        0x4
+#define QD_REG_PORT_CONTROL1        0x5
+#define QD_REG_PORT_VLAN_MAP        0x6
+#define QD_REG_PVID            0x7
+#define QD_REG_PORT_CONTROL2        0x8    /* for Sapphire family */
+#define QD_REG_INGRESS_RATE_CTRL    0x9    /* for Sapphire family */
+#define QD_REG_EGRESS_RATE_CTRL        0xA    /* for Sapphire family */
+#define QD_REG_RATE_CTRL0        0x9
+#define QD_REG_RATE_CTRL        0xA
+#define QD_REG_PAV            0xB
+#define QD_REG_PORT_ATU_CONTROL        0xC
+#define QD_REG_PRI_OVERRIDE        0xD
+#define QD_REG_POLICY_CONTROL    0xE
+#define QD_REG_PORT_ETH_TYPE    0xF
+#define QD_REG_RX_COUNTER        0x10
+#define QD_REG_TX_COUNTER        0x11
+#define QD_REG_DROPPED_COUNTER    0x12
+
+#define QD_REG_INDISCARD_LO_COUNTER        0x10
+#define QD_REG_INDISCARD_HI_COUNTER        0x11
+#define QD_REG_INFILTERED_COUNTER        0x12
+#define QD_REG_OUTFILTERED_COUNTER        0x13
+
+#define QD_REG_LED_CONTROL        0x16
+
+#define QD_REG_Q_COUNTER        0x1B
+#define QD_REG_RATE_CONTROL        0x0A
+#define QD_REG_PORT_ASSOCIATION        0x0B
+#define QD_REG_IEEE_PRI_REMAP_3_0    0x18    /* for Sapphire family */
+#define QD_REG_IEEE_PRI_REMAP_7_4    0x19    /* for Sapphire family */
+
+#define QD_REG_PROVIDER_TAG        0x1A        /* for Schooner family */
+
+/* QuarterDeck Global Registers */
+#define QD_REG_GLOBAL_STATUS        0x0
+#define QD_REG_MACADDR_01        0x1
+#define QD_REG_MACADDR_23        0x2
+#define QD_REG_MACADDR_45        0x3
+#define QD_REG_GLOBAL_CONTROL        0x4
+#define QD_REG_GLOBAL_CONTROL2        0x1C    /* for Sapphire, Schooner family */
+#define QD_REG_CORETAG_TYPE        0x19        /* for Ruby family */
+#define QD_REG_IP_MAPPING_TABLE    0x19        /* for Amber family */
+#define QD_REG_MONITOR_CONTROL    0x1A        /* for Ruby family */
+#define QD_REG_MANGEMENT_CONTROL    0x1A    /* for Schooner family */
+#define QD_REG_TOTAL_FREE_COUNTER    0x1B    /* for Schooner family */
+
+/* QuarterDeck Global 2 Registers */
+#define QD_REG_PHYINT_SOURCE    0x0
+#define QD_REG_DEVINT_SOURCE    0x0
+#define QD_REG_DEVINT_MASK        0x1
+#define QD_REG_MGMT_ENABLE_2X    0x2
+#define QD_REG_MGMT_ENABLE        0x3
+#define QD_REG_FLOWCTRL_DELAY    0x4
+#define QD_REG_MANAGEMENT        0x5
+#define QD_REG_ROUTING_TBL        0x6
+#define QD_REG_TRUNK_MASK_TBL    0x7
+#define QD_REG_TRUNK_ROUTING    0x8
+#define QD_REG_INGRESS_RATE_COMMAND    0x9
+#define QD_REG_INGRESS_RATE_DATA    0xA
+#define QD_REG_PVT_ADDR            0xB
+#define QD_REG_PVT_DATA            0xC
+#define QD_REG_SWITCH_MAC        0xD
+#define QD_REG_ATU_STATS        0xE
+#define QD_REG_PRIORITY_OVERRIDE    0xF
+#define QD_REG_EEPROM_COMMAND    0x14
+#define QD_REG_EEPROM_DATA        0x15
+#define QD_REG_PTP_COMMAND        0x16
+#define QD_REG_PTP_DATA            0x17
+#define QD_REG_SMI_PHY_CMD        0x18
+#define QD_REG_SMI_PHY_DATA        0x19
+#define QD_REG_SCRATCH_MISC        0x1A
+#define QD_REG_WD_CONTROL        0x1B
+#define QD_REG_QOS_WEIGHT        0x1C
+#define QD_REG_SDET_POLARITY    0x1D
+
+/* QuarterDeck Global 3 Registers */
+#define QD_REG_TCAM_OPERATION         0x0
+#define QD_REG_TCAM_P0_KEYS_1         0x2
+#define QD_REG_TCAM_P0_KEYS_2         0x3
+#define QD_REG_TCAM_P0_KEYS_3         0x4
+#define QD_REG_TCAM_P0_KEYS_4         0x5
+#define QD_REG_TCAM_P0_MATCH_DATA_1   0x6
+#define QD_REG_TCAM_P0_MATCH_DATA_2   0x7
+#define QD_REG_TCAM_P0_MATCH_DATA_3   0x8
+#define QD_REG_TCAM_P0_MATCH_DATA_4   0x9
+#define QD_REG_TCAM_P0_MATCH_DATA_5   0xa
+#define QD_REG_TCAM_P0_MATCH_DATA_6   0xb
+#define QD_REG_TCAM_P0_MATCH_DATA_7   0xc
+#define QD_REG_TCAM_P0_MATCH_DATA_8   0xd
+#define QD_REG_TCAM_P0_MATCH_DATA_9   0xe
+#define QD_REG_TCAM_P0_MATCH_DATA_10  0xf
+#define QD_REG_TCAM_P0_MATCH_DATA_11  0x10
+#define QD_REG_TCAM_P0_MATCH_DATA_12  0x11
+#define QD_REG_TCAM_P0_MATCH_DATA_13  0x12
+#define QD_REG_TCAM_P0_MATCH_DATA_14  0x13
+#define QD_REG_TCAM_P0_MATCH_DATA_15  0x14
+#define QD_REG_TCAM_P0_MATCH_DATA_16  0x15
+#define QD_REG_TCAM_P0_MATCH_DATA_17  0x16
+#define QD_REG_TCAM_P0_MATCH_DATA_18  0x17
+#define QD_REG_TCAM_P0_MATCH_DATA_19  0x18
+#define QD_REG_TCAM_P0_MATCH_DATA_20  0x19
+#define QD_REG_TCAM_P0_MATCH_DATA_21  0x1a
+#define QD_REG_TCAM_P0_MATCH_DATA_22  0x1b
+
+#define QD_REG_TCAM_P1_MATCH_DATA_23   0x2
+#define QD_REG_TCAM_P1_MATCH_DATA_24   0x3
+#define QD_REG_TCAM_P1_MATCH_DATA_25   0x4
+#define QD_REG_TCAM_P1_MATCH_DATA_26   0x5
+#define QD_REG_TCAM_P1_MATCH_DATA_27   0x6
+#define QD_REG_TCAM_P1_MATCH_DATA_28   0x7
+#define QD_REG_TCAM_P1_MATCH_DATA_29   0x8
+#define QD_REG_TCAM_P1_MATCH_DATA_30   0x9
+#define QD_REG_TCAM_P1_MATCH_DATA_31   0xa
+#define QD_REG_TCAM_P1_MATCH_DATA_32   0xb
+#define QD_REG_TCAM_P1_MATCH_DATA_33   0xc
+#define QD_REG_TCAM_P1_MATCH_DATA_34   0xd
+#define QD_REG_TCAM_P1_MATCH_DATA_35   0xe
+#define QD_REG_TCAM_P1_MATCH_DATA_36   0xf
+#define QD_REG_TCAM_P1_MATCH_DATA_37   0x10
+#define QD_REG_TCAM_P1_MATCH_DATA_38   0x11
+#define QD_REG_TCAM_P1_MATCH_DATA_39   0x12
+#define QD_REG_TCAM_P1_MATCH_DATA_40   0x13
+#define QD_REG_TCAM_P1_MATCH_DATA_41   0x14
+#define QD_REG_TCAM_P1_MATCH_DATA_42   0x15
+#define QD_REG_TCAM_P1_MATCH_DATA_43   0x16
+#define QD_REG_TCAM_P1_MATCH_DATA_44   0x17
+#define QD_REG_TCAM_P1_MATCH_DATA_45   0x18
+#define QD_REG_TCAM_P1_MATCH_DATA_46   0x19
+#define QD_REG_TCAM_P1_MATCH_DATA_47   0x1a
+#define QD_REG_TCAM_P1_MATCH_DATA_48   0x1b
+
+#define QD_REG_TCAM_P2_ACTION_1        0x2
+#define QD_REG_TCAM_P2_ACTION_2        0x3
+#define QD_REG_TCAM_P2_ACTION_3        0x4
+#define QD_REG_TCAM_P2_ACTION_4        0x5
+#define QD_REG_TCAM_P2_DEBUG_PORT      0x1c
+#define QD_REG_TCAM_P2_ALL_HIT         0x1f
+
+
+
+/* Global 1 Registers Definition for STU,VTU,RMON,and ATU Registers */
+#define QD_REG_ATU_FID_REG        0x1
+#define QD_REG_VTU_FID_REG        0x2
+#define QD_REG_STU_SID_REG        0x3
+#define QD_REG_VTU_OPERATION        0x5
+#define QD_REG_VTU_VID_REG        0x6
+#define QD_REG_VTU_DATA1_REG        0x7
+#define QD_REG_VTU_DATA2_REG        0x8
+#define QD_REG_VTU_DATA3_REG        0x9
+#define QD_REG_STATS_OPERATION        0x1D
+#define QD_REG_STATS_COUNTER3_2        0x1E
+#define QD_REG_STATS_COUNTER1_0        0x1F
+
+#define QD_REG_ATU_CONTROL        0xA
+#define QD_REG_ATU_OPERATION        0xB
+#define QD_REG_ATU_DATA_REG        0xC
+#define QD_REG_ATU_MAC_BASE        0xD
+#define QD_REG_IP_PRI_BASE        0x10
+#define QD_REG_IEEE_PRI            0x18
+
+
+/* Definitions for MIB Counter */
+#define GT_STATS_NO_OP            0x0
+#define GT_STATS_FLUSH_ALL        0x1
+#define GT_STATS_FLUSH_PORT        0x2
+#define GT_STATS_READ_COUNTER        0x4
+#define GT_STATS_CAPTURE_PORT        0x5
+
+#define QD_PHY_CONTROL_REG            0
+#define QD_PHY_AUTONEGO_AD_REG            4
+#define QD_PHY_NEXTPAGE_TX_REG            7
+#define QD_PHY_AUTONEGO_1000AD_REG        9
+#define QD_PHY_SPEC_CONTROL_REG            16
+#define QD_PHY_INT_ENABLE_REG            18
+#define QD_PHY_INT_STATUS_REG            19
+#define QD_PHY_INT_PORT_SUMMARY_REG        20
+
+/* Definitions for VCT registers */
+#define QD_REG_MDI0_VCT_STATUS     16
+#define QD_REG_MDI1_VCT_STATUS     17
+#define QD_REG_MDI2_VCT_STATUS     18
+#define QD_REG_MDI3_VCT_STATUS     19
+#define QD_REG_ADV_VCT_CONTROL_5    23
+#define QD_REG_ADV_VCT_CONTROL_8    20
+#define QD_REG_PAIR_SKEW_STATUS    20
+#define QD_REG_PAIR_SWAP_STATUS    21
+
+/* Bit Definition for QD_PHY_CONTROL_REG */
+#define QD_PHY_RESET            0x8000
+#define QD_PHY_LOOPBACK            0x4000
+#define QD_PHY_SPEED            0x2000
+#define QD_PHY_AUTONEGO            0x1000
+#define QD_PHY_POWER            0x800
+#define QD_PHY_ISOLATE            0x400
+#define QD_PHY_RESTART_AUTONEGO        0x200
+#define QD_PHY_DUPLEX            0x100
+#define QD_PHY_SPEED_MSB        0x40
+
+#define QD_PHY_POWER_BIT            11
+#define QD_PHY_RESTART_AUTONEGO_BIT        9
+
+/* Bit Definition for QD_PHY_AUTONEGO_AD_REG */
+#define QD_PHY_NEXTPAGE            0x8000
+#define QD_PHY_REMOTEFAULT        0x4000
+#define QD_PHY_PAUSE            0x400
+#define QD_PHY_100_FULL            0x100
+#define QD_PHY_100_HALF            0x80
+#define QD_PHY_10_FULL            0x40
+#define QD_PHY_10_HALF            0x20
+
+#define QD_PHY_MODE_AUTO_AUTO    (QD_PHY_100_FULL | QD_PHY_100_HALF | QD_PHY_10_FULL | QD_PHY_10_HALF)
+#define QD_PHY_MODE_100_AUTO    (QD_PHY_100_FULL | QD_PHY_100_HALF)
+#define QD_PHY_MODE_10_AUTO        (QD_PHY_10_FULL | QD_PHY_10_HALF)
+#define QD_PHY_MODE_AUTO_FULL    (QD_PHY_100_FULL | QD_PHY_10_FULL)
+#define QD_PHY_MODE_AUTO_HALF    (QD_PHY_100_HALF | QD_PHY_10_HALF)
+
+#define QD_PHY_MODE_100_FULL    QD_PHY_100_FULL
+#define QD_PHY_MODE_100_HALF    QD_PHY_100_HALF
+#define QD_PHY_MODE_10_FULL        QD_PHY_10_FULL
+#define QD_PHY_MODE_10_HALF        QD_PHY_10_HALF
+
+/* Gigabit Phy related definition */
+#define QD_GIGPHY_1000X_FULL_CAP    0x8
+#define QD_GIGPHY_1000X_HALF_CAP    0x4
+#define QD_GIGPHY_1000T_FULL_CAP    0x2
+#define QD_GIGPHY_1000T_HALF_CAP    0x1
+
+#define QD_GIGPHY_1000X_CAP        (QD_GIGPHY_1000X_FULL_CAP|QD_GIGPHY_1000X_HALF_CAP)
+#define QD_GIGPHY_1000T_CAP        (QD_GIGPHY_1000T_FULL_CAP|QD_GIGPHY_1000T_HALF_CAP)
+
+#define QD_GIGPHY_1000X_FULL        0x20
+#define QD_GIGPHY_1000X_HALF        0x40
+
+#define QD_GIGPHY_1000T_FULL        0x200
+#define QD_GIGPHY_1000T_HALF        0x100
+
+/* Bit definition for QD_PHY_INT_ENABLE_REG */
+#define QD_PHY_INT_SPEED_CHANGED        0x4000
+#define QD_PHY_INT_DUPLEX_CHANGED        0x2000
+#define QD_PHY_INT_PAGE_RECEIVED        0x1000
+#define QD_PHY_INT_AUTO_NEG_COMPLETED        0x800
+#define QD_PHY_INT_LINK_STATUS_CHANGED        0x400
+#define QD_PHY_INT_SYMBOL_ERROR            0x200
+#define QD_PHY_INT_FALSE_CARRIER        0x100
+#define QD_PHY_INT_FIFO_FLOW            0x80
+#define QD_PHY_INT_CROSSOVER_CHANGED        0x40
+#define QD_PHY_INT_POLARITY_CHANGED        0x2
+#define QD_PHY_INT_JABBER            0x1
+
+
+/* Bit definition for DEVICE Interrupt */
+#define QD_DEV_INT_WATCHDOG            0x8000
+#define QD_DEV_INT_JAMLIMIT            0x4000
+#define QD_DEV_INT_DUPLEX_MISMATCH    0x2000
+#define QD_DEV_INT_WAKE_EVENT         0x1000
+
+/* Definition for Multi Address Mode */
+#define QD_REG_SMI_COMMAND        0x0
+#define QD_REG_SMI_DATA            0x1
+
+/* Bit definition for QD_REG_SMI_COMMAND */
+#define QD_SMI_BUSY                0x8000
+#define QD_SMI_MODE                0x1000
+#define QD_SMI_MODE_BIT            12
+#define QD_SMI_OP_BIT            10
+#define QD_SMI_OP_SIZE            2
+#define QD_SMI_DEV_ADDR_BIT        5
+#define QD_SMI_DEV_ADDR_SIZE    5
+#define QD_SMI_REG_ADDR_BIT        0
+#define QD_SMI_REG_ADDR_SIZE    5
+
+#define QD_SMI_CLAUSE45            0
+#define QD_SMI_CLAUSE22            1
+
+#define QD_SMI_WRITE            0x01
+#define QD_SMI_READ                0x02
+
+#endif /* __gtDrvSwRegsh */
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/dsdt/msApiDefs.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/dsdt/msApiDefs.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/dsdt/msApiDefs.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/dsdt/msApiDefs.h	2014-04-10 17:50:38.000000000 +0700
@@ -0,0 +1,4217 @@
+#include "Copyright.h"
+
+/********************************************************************************
+* msApiDefs.h
+*
+* DESCRIPTION:
+*       API definitions for QuarterDeck Device
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __msApiDefs_h
+#define __msApiDefs_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+/* Micro definitions */
+#undef GT_USE_MAD
+#undef GT_RMGMT_ACCESS
+#undef CONFIG_AVB_FPGA
+#undef CONFIG_AVB_FPGA_2
+#undef GT_PORT_MAP_IN_DEV
+#ifdef CHECK_API_SELECT
+#include "msApiSelect.h"
+#endif
+
+
+#include "../common/mvTypes.h"
+#ifdef GT_USE_MAD
+#include "madApiDefs.h"
+#endif
+
+#ifdef DEBUG_QD
+#define DBG_INFO(x) gtDbgPrint x
+#else
+#define DBG_INFO(x);
+#endif /* DEBUG_QD */
+
+typedef MV_U32 GT_SEM;
+
+#define ETHERNET_HEADER_SIZE    GT_ETHERNET_HEADER_SIZE
+#define IS_MULTICAST_MAC(mac)   (mac[0] & 0x1) == 1) //      GT_IS_MULTICAST_MAC
+#define IS_BROADCAST_MAC(mac)   GT_IS_BROADCAST_MAC
+
+#define GT_INVALID_PHY            0xFF
+#define GT_INVALID_PORT            0xFF
+#define GT_INVALID_PORT_VEC        0xFFFFFFFF
+
+#define GT_UNUSED_PARAM(_a)        (_a)=(_a)
+
+/* general */
+#undef IN
+#define IN
+#undef OUT
+#define OUT
+#undef INOUT
+#define INOUT
+
+#define PHY_ACCESS            1
+#define PORT_ACCESS           2
+#define GLOBAL_REG_ACCESS     3
+#define GLOBAL2_REG_ACCESS    4
+#define GLOBAL3_REG_ACCESS    5
+
+/* Start address of phy related register.               */
+#define PHY_REGS_START_ADDR     0x0
+#define PHY_REGS_START_ADDR_8PORT    0x0
+
+/* Start address of ports related register.             */
+#define PORT_REGS_START_ADDR        0x8
+#define PORT_REGS_START_ADDR_8PORT    0x10
+
+/* Start address of global register.                    */
+#define GLOBAL_REGS_START_ADDR  0xF
+#define GLOBAL_REGS_START_ADDR_8PORT  0x1B
+
+#define CALC_SMI_DEV_ADDR(_dev, _portNum, _accessType)        \
+            portToSmiMapping(_dev, _portNum, _accessType)
+
+/*
+ *   Logical Port value based on a Port
+ *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+ *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |0|  reserved                                   |    port       |
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *
+ *
+ *   The following macros should be used to extract specific info
+ *   from a Logical Port index
+ */
+typedef MV_U32 GT_LPORT;
+typedef MV_U32 GT_ETYPE;
+
+#define DEV_88E6171              0x2000000
+
+/* Define the different device type that may exist in system        */
+typedef enum
+{
+    GT_88E6021  = 0x021,
+    GT_88E6031  = 0x031,
+    GT_88E6035  = 0x035,
+    GT_88E6046  = 0x048,
+    GT_88E6047  = 0x049,
+    GT_88E6085  = 0x04A,
+    GT_88E6051  = 0x051,
+    GT_88E6052  = 0x052,
+    GT_88E6055  = 0x055,
+    GT_88E6060  = 0x060,
+    GT_88E6061  = 0x061,
+    GT_88E6065  = 0x065,
+    GT_88E6083  = 0x083,
+    GT_88E6093  = 0x093,
+    GT_88E6045  = 0x094,
+    GT_88E6095  = 0x095,
+    GT_88E6092  = 0x097,
+    GT_88E6096  = 0x098,
+    GT_88E6097  = 0x099,
+    GT_88E6063    = 0x153,
+    GT_88E6121    = 0x104,
+    GT_88E6122    = 0x105,
+    GT_88E6131    = 0x106,
+    GT_88E6108    = 0x107,
+    GT_88E6123    = 0x121,
+    GT_88E6125    = 0x124,    /* was 88E6124 */
+    GT_88E6140    = 0x141, /* Emerald */
+    GT_88E6161    = 0x161, /* Emerald */
+    GT_88E6165    = 0x165, /* Emerald */
+    GT_88E6171    = 0x171, /* Amber */
+    GT_88E6175    = 0x175, /* Amber */
+    GT_88E6181    = 0x1A0,
+    GT_88E6153    = 0x1A1,
+    GT_88E6183    = 0x1A3,
+    GT_88E6152    = 0x1A4,
+    GT_88E6155    = 0x1A5,
+    GT_88E6182    = 0x1A6,
+    GT_88E6185    = 0x1A7,
+    GT_88E6321    = 0x324,    /* was 88E6325 */ /* Amber */
+    GT_88E6350    = 0x371,    /* was 88E6371 */ /* Amber */
+    GT_88E6351    = 0x375, /* Amber */
+    GT_88EC000    = 0xC00,    /* Melody 0xc00-0xc07 */
+    GT_88E3020    = 0x000,    /* Spinnaker 0x000 */
+    GT_88E6020    = 0x020,    /* Spinnaker 0x020 */
+    GT_88E6070    = 0x070,    /* Spinnaker 0x070 */
+    GT_88E6071    = 0x071,    /* Spinnaker 0x071 */
+    GT_88E6220    = 0x220,    /* Spinnaker 0x220 */
+    GT_88E6250    = 0x250,    /* Spinnaker 0x250 */
+    GT_FH_VPN   = 0xF53,
+    GT_FF_EG    = 0xF91,
+    GT_FF_HG    = 0xF93,
+    GT_88E6172    = 0x172, /* Agate */
+    GT_88E6176    = 0x176, /* Agate */
+    GT_88E6240    = 0x240, /* Agate */
+    GT_88E6352    = 0x352, /* Agate */
+	GT_KW2_INT	= 0x044		/* Internal Swiych in KW2 */
+
+}GT_DEVICE;
+
+
+/* Definition for the revision number of the device        */
+typedef enum
+{
+    GT_REV_0 = 0,
+    GT_REV_1,
+    GT_REV_2,
+    GT_REV_3
+}GT_DEVICE_REV;
+
+
+/* ToDo: No Used */
+typedef enum
+{
+    INTR_MODE_DISABLE =0,
+    INTR_MODE_ENABLE
+}INTERRUPT_MODE;
+
+/* Definition for the Port Speed */
+typedef enum
+{
+    PORT_SPEED_10_MBPS = 0,
+    PORT_SPEED_100_MBPS = 1,
+    PORT_SPEED_200_MBPS = 2,    /* valid only if device support */
+    PORT_SPEED_1000_MBPS = 2 ,    /* valid only if device support */
+    PORT_SPEED_UNKNOWN = 3
+} GT_PORT_SPEED_MODE;
+
+/* Definition for the forced Port Speed */
+typedef enum
+{
+    PORT_FORCE_SPEED_10_MBPS = 0,
+    PORT_FORCE_SPEED_100_MBPS = 1,
+    PORT_FORCE_SPEED_200_MBPS = 2,    /* valid only if device support */
+    PORT_FORCE_SPEED_1000_MBPS = 2,    /* valid only if device support */
+    PORT_DO_NOT_FORCE_SPEED =3
+} GT_PORT_FORCED_SPEED_MODE;
+
+/* Definition for the forced Port Duplex mode */
+typedef enum
+{
+    PORT_DO_NOT_FORCE_DUPLEX,
+    PORT_FORCE_FULL_DUPLEX,
+    PORT_FORCE_HALF_DUPLEX
+} GT_PORT_FORCED_DUPLEX_MODE;
+
+/* Definition for the forced Port Link */
+typedef enum
+{
+    PORT_DO_NOT_FORCE_LINK,
+    PORT_FORCE_LINK_UP,
+    PORT_FORCE_LINK_DOWN
+} GT_PORT_FORCED_LINK_MODE;
+
+/* Definition for the forced flow control mode */
+typedef enum
+{
+    PORT_DO_NOT_FORCE_FC,
+    PORT_FORCE_FC_ENABLED,
+    PORT_FORCE_FC_DISABLED
+} GT_PORT_FORCED_FC_MODE;
+
+/* Definition for the PPU state */
+typedef enum
+{
+    PPU_STATE_DISABLED_AT_RESET,
+    PPU_STATE_ACTIVE,
+    PPU_STATE_DISABLED_AFTER_RESET,
+    PPU_STATE_POLLING
+} GT_PPU_STATE;
+
+
+/*
+ * Typedef: enum GT_PORT_CONFIG_MODE
+ *
+ * Description: Defines port's interface type configuration mode determined at
+ *                reset. This definition may not represent the device under use.
+ *                Please refer to the device datasheet for detailed information.
+ *
+ */
+typedef enum
+{
+    PORTCFG_GMII_125MHZ = 0,        /* Px_GTXCLK = 125MHz, 1000BASE */
+    PORTCFG_FD_MII_0MHZ = 1,        /* Px_GTXCLK = 0 MHz, Power Save */
+    PORTCFG_FDHD_MII_25MHZ = 2,        /* Px_GTXCLK = 25MHz, 100BASE */
+    PORTCFG_FDHD_MII_2_5MHZ = 3,    /* Px_GTXCLK = 2.5MHz, 10BASE */
+    PORTCFG_FD_SERDES = 4,            /* Default value */
+    PORTCFG_FD_1000BASE_X = 5,
+    PORTCFG_MGMII = 6,                /* duplex, speed determined by the PPU */
+    PORTCFG_DISABLED = 7
+} GT_PORT_CONFIG_MODE;
+
+
+typedef enum
+{
+    GT_SA_FILTERING_DISABLE = 0,
+    GT_SA_DROP_ON_LOCK,
+    GT_SA_DROP_ON_UNLOCK,
+    GT_SA_DROP_TO_CPU
+} GT_SA_FILTERING;
+
+
+/* Definition for the Ingree/Egress Frame Mode */
+typedef enum
+{
+    GT_FRAME_MODE_NORMAL = 0,    /* Normal Network */
+    GT_FRAME_MODE_DSA,            /* Distributed Switch Architecture */
+    GT_FRAME_MODE_PROVIDER,        /* Provider */
+    GT_FRAME_MODE_ETHER_TYPE_DSA    /* Ether Type DSA */
+} GT_FRAME_MODE;
+
+/*
+ * Typedef: enum GT_JUMBO_MODE
+ *
+ * Description: Defines Jumbo Frame Size allowed to be tx and rx
+ *
+ * Fields:
+ *      GT_JUMBO_MODE_1522 - Rx and Tx frames with max byte of 1522.
+ *      GT_JUMBO_MODE_2048 - Rx and Tx frames with max byte of 2048.
+ *      GT_JUMBO_MODE_10240 - Rx and Tx frames with max byte of 10240.
+ *
+ */
+typedef enum
+{
+    GT_JUMBO_MODE_1522 = 0,
+    GT_JUMBO_MODE_2048,
+    GT_JUMBO_MODE_10240
+} GT_JUMBO_MODE;
+
+
+/*
+ * Typedef: enum GT_PRI_OVERRIDE
+ *
+ * Description: Defines the priority override
+ *
+ * Fields:
+ *      PRI_OVERRIDE_NONE - Normal frame priority processing occurs.
+ *        PRI_OVERRIDE_FRAME_QUEUE -
+ *            Both frame and queue overrides take place on the frame.
+ *      PRI_OVERRIDE_FRAME -
+ *            Overwite the frame's FPri (frame priority).
+ *            If the frame egresses tagged, the priority in the frame will be
+ *            the overwritten priority value.
+ *        PRI_OVERRIDE_QUEUE -
+ *            Overwite the frame's QPri (queue priority).
+ *            QPri is used internally to map the frame to one of the egress
+ *            queues inside the switch.
+ *
+ */
+typedef enum
+{
+    PRI_OVERRIDE_NONE = 0,
+    PRI_OVERRIDE_FRAME_QUEUE,
+    PRI_OVERRIDE_FRAME,
+    PRI_OVERRIDE_QUEUE
+} GT_PRI_OVERRIDE;
+
+
+/*
+ * Typedef: enum GT_FRAME_POLICY
+ *
+ * Description: Defines the policy of the frame
+ *
+ * Fields:
+ *      FRAME_POLICY_NONE - Normal frame switching
+ *      FRAME_POLICY_MIRROR - Mirror(copy) frame to the MirrorDest port
+ *      FRAME_POLICY_TRAP - Trap(re-direct) frame to the CPUDest port
+ *      FRAME_POLICY_DISCARD - Discard(filter) the frame
+ *
+ */
+typedef enum
+{
+    FRAME_POLICY_NONE = 0,
+    FRAME_POLICY_MIRROR,
+    FRAME_POLICY_TRAP,
+    FRAME_POLICY_DISCARD
+} GT_FRAME_POLICY;
+
+
+/*
+ * Typedef: enum GT_POLICY_TYPE
+ *
+ * Description: Defines the policy type
+ *
+ * Fields:
+ *      POLICY_TYPE_DA     - Policy based on Destination Address
+ *      POLICY_TYPE_SA     - Policy based on Source Address
+ *      POLICY_TYPE_VTU     - Policy based on VID
+ *        POLICY_TYPE_ETYPE    - based on Ether Type of a frame
+ *        POLICY_TYPE_PPPoE    - Policy for the frame with Ether Type of 0x8863
+ *        POLICY_TYPE_VBAS    - Policy for the frame with Ether Type of 0x8200
+ *        POLICY_TYPE_OPT82    - Policy for the frame with DHCP Option 82
+ *        POLICY_TYPE_UDP    - Policy for the frame with Broadcast IPv4 UDP or
+ *                        Multicast IPv6 UDP
+ */
+typedef enum
+{
+    POLICY_TYPE_DA,
+    POLICY_TYPE_SA,
+    POLICY_TYPE_VTU,
+    POLICY_TYPE_ETYPE,
+    POLICY_TYPE_PPPoE,
+    POLICY_TYPE_VBAS,
+    POLICY_TYPE_OPT82,
+    POLICY_TYPE_UDP
+} GT_POLICY_TYPE;
+
+
+/*
+ * Typedef: enum GT_PRI_OVERRIDE_FTYPE
+ *
+ * Description: Definition of the frame type for priority override
+ *
+ * Fields:
+ *        FTYPE_DSA_TO_CPU_BPDU -
+ *            Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+ *            Not used on non-DSA Control frames.
+ *        FTYPE_DSA_TO_CPU_F2R -
+ *            Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+ *            Reply). Not used on non-DSA Control frames.
+ *        FTYPE_DSA_TO_CPU_IGMP -
+ *            Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+ *            and on non-DSA Control frames that are IGMP or MLD trapped
+ *        FTYPE_DSA_TO_CPU_TRAP -
+ *            Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+ *            on non-DSA Control frames that are Policy Trapped
+ *        FTYPE_DSA_TO_CPU_ARP -
+ *            Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+ *            on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+ *        FTYPE_DSA_TO_CPU_MIRROR -
+ *            Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+ *            on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+ *        FTYPE_DSA_TO_CPU_RESERVED -
+ *            Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+ *            used on non-DSA Control frames.
+ *        FTYPE_DSA_TO_CPU_UCAST_MGMT -
+ *            Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+ *            MGMT). Not used on non-DSA Control frames.
+ *        FTYPE_DSA_FROM_CPU -
+ *            Used on DSA From_CPU frames. Not used on non-DSA Control frame
+ *        FTYPE_DSA_CROSS_CHIP_FC -
+ *            Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+ *            Control). Not used on non-DSA Control frames.
+ *        FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+ *            Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+ *            Not used on non-DSA Control frames.
+ *        FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+ *            Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+ *            Not used on non-DSA Control frames.
+ *        FTYPE_PORT_ETYPE_MATCH -
+ *            Used on normal network ports (see gprtSetFrameMode API)
+ *            on frames whose Ethertype matches the port's PortEType register.
+ *            Not used on non-DSA Control frames.
+ *        FTYPE_BCAST_NON_DSA_CONTROL -
+ *            Used on Non-DSA Control frames that contain a Broadcast
+ *            destination address. Not used on DSA Control frames.
+ *        FTYPE_PPPoE_NON_DSA_CONTROL -
+ *            Used on Non-DSA Control frames that contain an Ether Type 0x8863
+ *            (i.e., PPPoE frames). Not used on DSA Control frames.
+ *        FTYPE_IP_NON_DSA_CONTROL -
+ *            Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+ *            Type. Not used on DSA Control frames.
+ */
+typedef enum
+{
+    FTYPE_DSA_TO_CPU_BPDU = 0,
+    FTYPE_DSA_TO_CPU_F2R,
+    FTYPE_DSA_TO_CPU_IGMP,
+    FTYPE_DSA_TO_CPU_TRAP,
+    FTYPE_DSA_TO_CPU_ARP,
+    FTYPE_DSA_TO_CPU_MIRROR,
+    FTYPE_DSA_TO_CPU_RESERVED,
+    FTYPE_DSA_TO_CPU_UCAST_MGMT,
+    FTYPE_DSA_FROM_CPU,
+    FTYPE_DSA_CROSS_CHIP_FC,
+    FTYPE_DSA_CROSS_CHIP_EGRESS_MON,
+    FTYPE_DSA_CROSS_CHIP_INGRESS_MON,
+    FTYPE_PORT_ETYPE_MATCH,
+    FTYPE_BCAST_NON_DSA_CONTROL,
+    FTYPE_PPPoE_NON_DSA_CONTROL,
+    FTYPE_IP_NON_DSA_CONTROL
+} GT_PRI_OVERRIDE_FTYPE;
+
+
+/*
+ * Typedef: struct GT_QPRI_TBL_ENTRY
+ *
+ * Description: This structure is used for the entry of Queue Priority Override
+ *                Table.
+ *
+ * Fields:
+ *        qPriEn    - GT_TRUE to enable Queue Priority, GT_FALSE otherwise
+ *        qPriority - priority to be overridden ( 0 ~ 3 ) only if qPriEn is GT_TRUE
+ *                    When qPriEn is GT_FALSE, qPriority should be ignored.
+ *
+ * Notes: If device does not support qPriAvbEn, qPriAvbEn and qAvbPriority fields
+ *        will be ignored.
+ */
+typedef struct
+{
+    MV_BOOL        qPriEn;
+    MV_U32        qPriority;
+}GT_QPRI_TBL_ENTRY;
+
+
+/*
+ * Typedef: struct GT_FPRI_TBL_ENTRY
+ *
+ * Description: This structure is used for the entry of Frame Priority Override
+ *                Table.
+ *
+ * Fields:
+ *        fPriEn    - GT_TRUE to enable Frame Priority, GT_FALSE otherwise
+ *        fPriority - priority to be overridden ( 0 ~ 7 ) only if fPriEn is GT_TRUE
+ *                    When fPriEn is GT_FALSE, fPriority should be ignored.
+ */
+typedef struct
+{
+    MV_BOOL        fPriEn;
+    MV_U32        fPriority;
+}GT_FPRI_TBL_ENTRY;
+
+
+/* Maximam number of ports a switch may have. */
+#define MAX_SWITCH_PORTS    11
+#define VERSION_MAX_LEN     30
+#define MAX_QOS_WEIGHTS        128
+
+/*
+ * Typedef: struct GT_QoS_WEIGHT
+ *
+ * Description: This structure is used for Programmable Round Robin Weights.
+ *
+ * Fields:
+ *      len    - length of the valid queue data
+ *        queue  - upto 128 queue data
+ */
+typedef struct
+{
+    MV_U32        len;
+    MV_U8        queue[MAX_QOS_WEIGHTS];
+}GT_QoS_WEIGHT;
+
+
+
+/*
+ * Typedef: struct GT_VERSION
+ *
+ * Description: This struct holds the package version.
+ *
+ * Fields:
+ *      version - string array holding the version.
+ *
+ */
+typedef struct
+{
+    MV_U8   version[VERSION_MAX_LEN];
+}GT_VERSION;
+
+
+/*
+ * typedef: struct GT_RMU
+ *
+ * Description: This struct holds the Remote Management Unit mode.
+ *
+ * Fields:
+ *        rmuEn    - enable or disable RMU
+ *        port    - logical port where RMU is enabled
+ */
+typedef struct
+{
+    MV_BOOL        rmuEn;
+    GT_LPORT    port;
+} GT_RMU;
+
+
+
+/*
+ * Typedef:
+ *
+ * Description: Defines the different sizes of the Mac address table.
+ *
+ * Fields:
+ *      ATU_SIZE_256    -   256 entries Mac address table.
+ *      ATU_SIZE_512    -   512 entries Mac address table.
+ *      ATU_SIZE_1024   -   1024 entries Mac address table.
+ *      ATU_SIZE_2048   -   2048 entries Mac address table.
+ *      ATU_SIZE_4096   -   4096 entries Mac address table.
+ *      ATU_SIZE_8192   -   8192 entries Mac address table.
+ *
+ */
+typedef enum
+{
+    ATU_SIZE_256,
+    ATU_SIZE_512,
+    ATU_SIZE_1024,
+    ATU_SIZE_2048,
+    ATU_SIZE_4096,
+    ATU_SIZE_8192
+}ATU_SIZE;
+
+
+/*
+ * typedef: enum GT_PORT_STP_STATE
+ *
+ * Description: Enumeration of the port spanning tree state.
+ *
+ * Enumerations:
+ *   GT_PORT_DISABLE    - port is disabled.
+ *   GT_PORT_BLOCKING   - port is in blocking/listening state.
+ *   GT_PORT_LEARNING   - port is in learning state.
+ *   GT_PORT_FORWARDING - port is in forwarding state.
+ */
+typedef enum
+{
+    GT_PORT_DISABLE = 0,
+    GT_PORT_BLOCKING,
+    GT_PORT_LEARNING,
+    GT_PORT_FORWARDING
+} GT_PORT_STP_STATE;
+
+
+/*
+ * typedef: enum GT_EGRESS_MODE
+ *
+ * Description: Enumeration of the port egress mode.
+ *
+ * Enumerations:
+ *   GT_UNMODIFY_EGRESS - frames are transmited unmodified.
+ *   GT_TAGGED_EGRESS   - all frames are transmited tagged.
+ *   GT_UNTAGGED_EGRESS - all frames are transmited untagged.
+ *   GT_ADD_TAG         - always add a tag. (or double tag)
+ */
+typedef enum
+{
+    GT_UNMODIFY_EGRESS = 0,
+    GT_UNTAGGED_EGRESS,
+    GT_TAGGED_EGRESS,
+    GT_ADD_TAG
+} GT_EGRESS_MODE;
+
+/*  typedef: enum GT_DOT1Q_MODE */
+
+typedef enum
+{
+    GT_DISABLE = 0,
+    GT_FALLBACK,
+    GT_CHECK,
+    GT_SECURE
+} GT_DOT1Q_MODE;
+
+
+/* typedef: enum GT_SW_MODE */
+
+typedef enum
+{
+    GT_CPU_ATTATCHED = 0, /* ports come up disabled */
+    GT_BACKOFF,           /* EEPROM attac mode with old half duplex backoff mode */
+    GT_STAND_ALONE,       /* ports come up enabled, ignore EEPROM */
+    GT_EEPROM_ATTATCHED   /* EEPROM defined prot states */
+} GT_SW_MODE;
+
+
+/*
+ * Typedef: enum GT_ATU_OPERARION
+ *
+ * Description: Defines the different ATU and VTU operations
+ *
+ * Fields:
+ *      FLUSH_ALL           - Flush all entries.
+ *      FLUSH_UNLOCKED      - Flush all unlocked entries in ATU.
+ *      LOAD_PURGE_ENTRY    - Load / Purge entry.
+ *      GET_NEXT_ENTRY      - Get next ATU or VTU  entry.
+ *      FLUSH_ALL_IN_DB     - Flush all entries in a particular DBNum.
+ *      FLUSH_UNLOCKED_IN_DB - Flush all unlocked entries in a particular DBNum.
+ *      SERVICE_VIOLATONS   - sevice violations of VTU
+ *
+ */
+typedef enum
+{
+    FLUSH_ALL = 1,        /* for both atu and vtu */
+    FLUSH_UNLOCKED,        /* for atu only */
+    LOAD_PURGE_ENTRY,    /* for both atu and vtu */
+    GET_NEXT_ENTRY,        /* for both atu and vtu */
+    FLUSH_ALL_IN_DB,    /* for atu only */
+    FLUSH_UNLOCKED_IN_DB,    /* for atu only */
+    SERVICE_VIOLATIONS     /* for vtu only */
+} GT_ATU_OPERATION, GT_VTU_OPERATION;
+
+
+/*
+ * typedef: enum GT_FLUSH_CMD
+ *
+ * Description: Enumeration of the address translation unit flush operation.
+ *
+ * Enumerations:
+ *   GT_FLUSH_ALL       - flush all entries.
+ *   GT_FLUSH_ALL_UNBLK - flush all unblocked (or unlocked).
+ *   GT_FLUSH_ALL_UNLOCKED - flush all unblocked (or unlocked).
+ */
+typedef enum
+{
+    GT_FLUSH_ALL       = 1,
+    GT_FLUSH_ALL_UNBLK = 2,
+    GT_FLUSH_ALL_UNLOCKED = 2
+}GT_FLUSH_CMD;
+
+/*
+ * typedef: enum GT_MOVE_CMD
+ *
+ * Description: Enumeration of the address translation unit move or remove operation.
+ *     When destination port is set to 0xF, Remove operation occurs.
+ *
+ * Enumerations:
+ *   GT_MOVE_ALL       - move all entries.
+ *   GT_MOVE_ALL_UNBLK - move all unblocked (or unlocked).
+ *   GT_MOVE_ALL_UNLOCKED - move all unblocked (or unlocked).
+ */
+typedef enum
+{
+    GT_MOVE_ALL       = 1,
+    GT_MOVE_ALL_UNBLK = 2,
+    GT_MOVE_ALL_UNLOCKED = 2
+}GT_MOVE_CMD;
+
+
+/*
+ * typedef: enum GT_ATU_UC_STATE
+ *
+ * Description:
+ *      Enumeration of the address translation unit entry state of unicast
+ *      entris.
+ *
+ * Enumerations:
+ *        GT_UC_INVALID   - invalid entry.
+ *        GT_UC_DYNAMIC   - unicast dynamic entry.
+ *        GT_UC_NO_PRI_TO_CPU_STATIC_NRL
+ *                - static unicast entry that will be forwarded to CPU without
+ *                    forcing priority and without rate limiting.
+ *        GT_UC_TO_CPU_STATIC_NRL
+ *                - static unicast entry that will be forwarded to CPU without
+ *                    rate limiting.
+ *        GT_UC_NO_PRI_STATIC_NRL
+ *                - static unicast entry without forcing priority and without.
+ *                    rate limiting.
+ *        GT_UC_NO_PRI_STATIC_AVB_ENTRY
+ *                - static unicast AVB entry without forcing priority if MacAvb is enabled.
+ *        GT_UC_STATIC_NRL    - static unicast entry without rate limiting.
+ *        GT_UC_STATIC_AVB_ENTRY - static unicast AVB entry if MacAvb is enabled .
+ *        GT_UC_NO_PRI_TO_CPU_STATIC
+ *                - static unicast entry that will be forwarded to CPU without
+ *                    forcing priority.
+ *        GT_UC_TO_CPU_STATIC - static unicast entry that will be forwarded to CPU.
+ *        GT_UC_NO_PRI_STATIC - static unicast entry without forcing priority.
+ *        GT_UC_STATIC    - static unicast entry.
+ *
+ * Note: Please refer to the device datasheet for detailed unicast entry states
+ *        that are supported by the device.
+ */
+typedef enum
+{
+    GT_UC_INVALID      = 0,
+    GT_UC_DYNAMIC      = 0x1,
+
+    GT_UC_NO_PRI_TO_CPU_STATIC_NRL    = 0x8,
+    GT_UC_TO_CPU_STATIC_NRL            = 0x9,
+    GT_UC_NO_PRI_STATIC_NRL            = 0xA,
+    GT_UC_NO_PRI_STATIC_AVB_ENTRY    = 0xA,
+    GT_UC_STATIC_NRL                 = 0xB,
+    GT_UC_STATIC_AVB_ENTRY            = 0xB,
+
+    GT_UC_NO_PRI_TO_CPU_STATIC    = 0xC,
+    GT_UC_TO_CPU_STATIC         = 0xD,
+    GT_UC_NO_PRI_STATIC         = 0xE,
+    GT_UC_STATIC                  = 0xF
+} GT_ATU_UC_STATE;
+
+
+/*
+ * typedef: enum GT_ATU_MC_STATE
+ *
+ * Description:
+ *      Enumeration of the address translation unit entry state of multicast
+ *      entris.
+ *
+ * Enumerations:
+ *      GT_MC_INVALID         - invalid entry.
+ *      GT_MC_MGM_STATIC      - static multicast management entries.
+ *      GT_MC_STATIC          - static multicast regular entris.
+ *      GT_MC_STATIC_AVB_ENTRY- static AVB entry if MacAvb is enalbed.
+ *      GT_MC_PRIO_MGM_STATIC - static multicast management entries with
+ *                              priority.
+ *      GT_MC_PRIO_STATIC     - static multicast regular entris with priority.
+ *      GT_MC_PRIO_STATIC_AVB_ENTRY      - static multicast AVB Entry with priority if MacAvb is enabled
+ *      GT_MC_PRIO_STATIC_UNLIMITED_RATE - static multicast regular entris with priority
+ *                                            and without rate limiting.
+ *      GT_MC_MGM_STATIC_UNLIMITED_RATE     - static multicast management entries without
+ *                                            rate limiting.
+ *      GT_MC_STATIC_UNLIMITED_RATE      - static multicast regular entris without
+ *                                            rate limiting.
+ *      GT_MC_PRIO_MGM_STATIC_UNLIMITED_RATE - static multicast management entries with
+ *                              priority and without rate limiting.
+ *
+ * Note: Please refer to the device datasheet for detailed multicast entry states
+ *        that are supported by the device.
+ */
+typedef enum
+{
+    GT_MC_INVALID         = 0,
+    GT_MC_MGM_STATIC_UNLIMITED_RATE = 0x4,
+    GT_MC_STATIC_UNLIMITED_RATE    = 0x5,
+    GT_MC_STATIC_AVB_ENTRY    = 0x5,
+    GT_MC_MGM_STATIC      = 0x6,
+    GT_MC_STATIC          = 0x7,
+    GT_MC_PRIO_MGM_STATIC_UNLIMITED_RATE = 0xC,
+    GT_MC_PRIO_STATIC_UNLIMITED_RATE    = 0xD,
+    GT_MC_PRIO_STATIC_AVB_ENTRY    = 0xD,
+    GT_MC_PRIO_MGM_STATIC = 0xE,
+    GT_MC_PRIO_STATIC     = 0xF
+} GT_ATU_MC_STATE;
+
+
+/*
+ *  typedef: struct GT_ATU_EXT_PRI
+ *
+ *  Description:
+ *        Extanded priority information for the address tarnslaton unit entry.
+ *
+ *        macFPri data is used to override the frame priority on any frame associated
+ *        with this MAC, if the useMacFPri is GT_TRUE and the port's SA and/or
+ *        DA FPriOverride are enabled. SA Frame Priority Overrides can only occur on
+ *        MAC addresses that are Static or where the Port is Locked, and where the port
+ *        is mapped source port for the MAC address.
+ *
+ *        macQPri data is used to override the queue priority on any frame associated
+ *        with this MAC, if the EntryState indicates Queue Priority Override and the
+ *        port's SA and/or DA QPriOverride are enabled.
+ *
+ *  Fields:
+ *      useMacFPri - Use MAC frame priority override. When this is GT_TRUE,
+ *                     MacFPri data can be used to override the frame priority on
+ *                     any frame associated with this MAC.
+ *      macFPri    - MAC frame priority data (0 ~ 7).
+ *      macQPri    - MAC queue priority data (0 ~ 3).
+ *
+ *  Comment:
+ *      Please refer to the device datasheet to find out if this feature is supported.
+ *        When this structure is implemented, the followings are the devices supporting
+ *        this feature:
+ *            88E6065, 88E6035, and 88E6055 support all extanded priority data.
+ *            88E6061 and 88E6031 support only macQPri data
+ *            88EC000 and 88E3020 family use only macFPri data
+ */
+typedef struct
+{
+    MV_BOOL            useMacFPri;
+    MV_U8             macFPri;
+    MV_U8             macQPri;
+} GT_ATU_EXT_PRI;
+
+
+/*
+ *  typedef: struct GT_ATU_ENTRY
+ *
+ *  Description: address tarnslaton unit Entry
+ *
+ *  Fields:
+ *      macAddr    - mac address
+ *      trunkMember- GT_TRUE if entry belongs to a Trunk. This field will be
+ *                     ignored if device does not support Trunk.
+ *      portVec    - port Vector.
+ *                     If trunkMember field is GT_TRUE, this value represents trunk ID.
+ *      prio       - entry priority.
+ *      entryState - the entry state.
+ *        DBNum       - ATU MAC Address Database number. If multiple address
+ *                     databases are not being used, DBNum should be zero.
+ *                     If multiple address databases are being used, this value
+ *                     should be set to the desired address database number.
+ *        exPrio     - extanded priority information. If device support extanded
+ *                     priority, prio field should be ignored.
+ *
+ *  Comment:
+ *      The entryState union Type is determine according to the Mac Type.
+ */
+typedef struct
+{
+    MV_U8            macAddr[6];
+    MV_BOOL            trunkMember;
+    MV_U32            portVec;
+    MV_U8            prio;
+    MV_U8            reserved;
+    MV_U16            DBNum;
+    union
+    {
+        GT_ATU_UC_STATE ucEntryState;
+        GT_ATU_MC_STATE mcEntryState;
+    } entryState;
+    GT_ATU_EXT_PRI    exPrio;
+} GT_ATU_ENTRY;
+
+
+/*
+ *  typedef: struct GT_VTU_DATA
+ *
+ *  Description: VLAN  tarnslaton unit Data Register
+ *
+ *  Fields:
+ *      memberTagP - Membership and Egress Tagging
+ *                   memberTagP[0] is for Port 0, MemberTagP[1] is for port 1, and so on
+ *
+ *  Comment:
+ *     MAX_SWITCH_PORTS is 10 for Octane.
+ *     In the case of FullSail, there are 3 ports. So, the rest 7 is ignored in memeberTagP
+ */
+typedef struct
+{
+    MV_U8     memberTagP[MAX_SWITCH_PORTS];
+    MV_U8     portStateP[MAX_SWITCH_PORTS];
+} GT_VTU_DATA;
+
+/*
+ *  definition for MEMBER_TAG
+ */
+#define MEMBER_EGRESS_UNMODIFIED    0
+#define NOT_A_MEMBER                1
+#define MEMBER_EGRESS_UNTAGGED        2
+#define MEMBER_EGRESS_TAGGED        3
+
+/*
+ *  typedef: struct GT_VTU_EXT_INFO
+ *
+ *  Description:
+ *        Extanded VTU Entry information for Priority Override and Non Rate Limit.
+ *        Frame Priority is used to as the tag's PRI bits if the frame egresses
+ *        the switch tagged. The egresss queue the frame is switch into is not
+ *        modified by the Frame Priority Override.
+ *        Queue Priority is used to determine the egress queue the frame is
+ *        switched into. If the frame egresses tagged, the priority in the frame
+ *        will not be modified by a Queue Priority Override.
+ *        NonRateLimit for VID is used to indicate any frames associated with this
+ *        VID are to bypass ingress and egress rate limiting, if the ingress
+ *        port's VID NRateLimit is also enabled.
+ *
+ *  Fields:
+ *      useVIDFPri - Use VID frame priority override. When this is GT_TRUE and
+ *                     VIDFPriOverride of the ingress port of the frame is enabled,
+ *                     vidFPri data is used to override the frame priority on
+ *                     any frame associated with this VID.
+ *      vidFPri    - VID frame priority data (0 ~ 7).
+ *      useVIDQPri - Use VID queue priority override. When this is GT_TRUE and
+ *                     VIDQPriOverride of the ingress port of the frame is enabled,
+ *                     vidQPri data can be used to override the queue priority on
+ *                     any frame associated with this VID.
+ *      vidQPri    - VID queue priority data (0 ~ 3).
+ *      vidNRateLimit - bypass rate ingress and egress limiting
+ *
+ *  Comment:
+ *      Please refer to the device datasheet to find out if this feature is supported.
+ *        When this structure is implemented, the followings are the devices supporting
+ *        this feature:
+ *            88E6065, 88E6035, and 88E6055 support all data.
+ *            88E6061 and 88E6031 support only vidNRateLimit.
+ */
+typedef struct
+{
+    MV_BOOL            useVIDFPri;
+    MV_U8             vidFPri;
+    MV_BOOL            useVIDQPri;
+    MV_U8             vidQPri;
+    MV_BOOL            vidNRateLimit;
+} GT_VTU_EXT_INFO;
+
+
+/*
+ *  typedef: struct GT_VTU_ENTRY
+ *
+ *  Description: VLAN tarnslaton unit Entry
+ *        Each field in the structure is device specific, i.e., some fields may not
+ *        be supported by the used switch device. In such case, those fields are
+ *        ignored by the DSDT driver. Please refer to the datasheet for the list of
+ *        supported fields.
+ *
+ *  Fields:
+ *      DBNum      - database number or FID (forwarding information database)
+ *      vid        - VLAN ID
+ *      vtuData    - VTU data
+ *        vidPriOverride - override the priority on any frame associated with this VID
+ *        vidPriority - VID Priority bits (0 ~ 7)
+ *        sid           - 802.1s Port State Database ID
+ *        vidPolicy  - indicate that the frame with this VID uses VID Policy
+ *                     (see gprtSetPolicy API).
+ *        vidExInfo  - extanded information for VTU entry. If the device supports extanded
+ *                     information, vidPriorityOverride and vidPriority values are
+ *                     ignored.
+ */
+typedef struct
+{
+    MV_U16        DBNum;
+    MV_U16        vid;
+    GT_VTU_DATA   vtuData;
+    MV_BOOL          vidPriOverride;
+    MV_U8          vidPriority;
+    MV_U8          sid;
+    MV_BOOL          vidPolicy;
+    GT_VTU_EXT_INFO    vidExInfo;
+} GT_VTU_ENTRY;
+
+
+/*
+ * Typedef: enum GT_STU_OPERARION
+ *
+ * Description: Defines the STU operations
+ *
+ * Fields:
+ *      LOAD_PURGE_STU_ENTRY    - Load / Purge entry.
+ *      GET_NEXT_STU_ENTRY      - Get next STU  entry.
+ *
+ */
+typedef enum
+{
+    LOAD_PURGE_STU_ENTRY = 5,
+    GET_NEXT_STU_ENTRY =6
+} GT_STU_OPERATION;
+
+
+/*
+ *  typedef: struct GT_STU_ENTRY
+ *
+ *  Description: 802.1s Port State Information Database (STU) Entry
+ *
+ *  Fields:
+ *      sid       - STU ID
+ *        portState - Per VLAN Port States for each port.
+ */
+typedef struct
+{
+    MV_U16                sid;
+    GT_PORT_STP_STATE    portState[MAX_SWITCH_PORTS];
+} GT_STU_ENTRY;
+
+
+/*
+ *  typedef: struct GT_VTU_INT_STATUS
+ *
+ *  Description: VLAN tarnslaton unit interrupt status
+ *
+ *  Fields:
+ *      intCause  - VTU Interrupt Cause
+ *                    GT_VTU_FULL_VIOLATION,GT_MEMEBER_VIOLATION,or
+ *                    GT_MISS_VIOLATION
+ *      SPID      - source port number
+ *                     if intCause is GT_VTU_FULL_VIOLATION, it means nothing
+ *      vid       - VLAN ID
+ *                     if intCause is GT_VTU_FULL_VIOLATION, it means nothing
+ */
+typedef struct
+{
+    MV_U16   vtuIntCause;
+    MV_U8    spid;
+    MV_U16   vid;
+} GT_VTU_INT_STATUS;
+
+/*
+ *  typedef: struct GT_ATU_INT_STATUS
+ *
+ *  Description: VLAN tarnslaton unit interrupt status
+ *
+ *  Fields:
+ *      intCause  - ATU Interrupt Cause
+ *                    GT_FULL_VIOLATION,GT_MEMEBER_VIOLATION,
+ *                    GT_MISS_VIOLATION, GT_AGE_VIOLATION, or
+ *                    GT_AGE_OUT_VIOLATION
+ *      SPID      - source port number
+ *                     if intCause is GT_FULL_VIOLATION, it means nothing
+ *      DBNum     - DB Num (or FID)
+ *                     if intCause is GT_FULL_VIOLATION, it means nothing
+ *        macAddr      - MAC Address
+ */
+typedef struct
+{
+    MV_U16   atuIntCause;
+    MV_U8    spid;
+    MV_U8    dbNum;
+    MV_8     macAddr[6];
+} GT_ATU_INT_STATUS;
+
+/*
+* Definition for VTU interrupt
+*/
+#define GT_MEMBER_VIOLATION        0x4
+#define GT_MISS_VIOLATION        0x2
+#define GT_VTU_FULL_VIOLATION    0x1
+/*
+* Definitions for ATU interrupt in Gigabit switch are the same as
+* the ones for VTU interrupt. Here we just redefine the FULL_VIOLATION for
+* both VTU and ATU.
+*/
+#define GT_FULL_VIOLATION        0x1
+
+#define GT_AGE_VIOLATION        0x8
+#define GT_AGE_OUT_VIOLATION    0x10
+
+
+/*
+
+  * Typedef: enum GT_PVT_OPERATION
+ *
+ * Description: Defines the PVT (Cross Chip Port VLAN Table) Operation type
+ *
+ * Fields:
+ *      PVT_INITIALIZE - Initialize all resources to the inital state
+ *      PVT_WRITE      - Write to the selected PVT entry
+ *      PVT_READ       - Read from the selected PVT entry
+ */
+typedef enum
+{
+    PVT_INITIALIZE     = 0x1,
+    PVT_WRITE        = 0x3,
+    PVT_READ        = 0x4
+} GT_PVT_OPERATION;
+
+
+/*
+ *  typedef: struct GT_PVT_OP_DATA
+ *
+ *  Description: data required by PVT (Cross Chip Port VLAN Table) Operation
+ *
+ *  Fields:
+ *      pvtAddr - pointer to the desired entry of PVT
+ *      pvtData - Cross Chip Port VLAN data for the entry pointed by pvtAddr
+ */
+typedef struct
+{
+    MV_U32    pvtAddr;
+    MV_U32    pvtData;
+} GT_PVT_OP_DATA;
+
+
+/*
+ *  typedef: enum GT_PIRL_FC_DEASSERT
+ *
+ *  Description: Enumeration of the port flow control de-assertion mode on PIRL.
+ *
+ *  Enumerations:
+ *      GT_PIRL_FC_DEASSERT_EMPTY -
+ *                De-assert when the ingress rate resource has become empty
+ *        GT_PIRL_FC_DEASSERT_CBS_LIMIT -
+ *                De-assert when the ingress rate resource has enough room as
+ *                specified by the CBSLimit.
+ */
+typedef enum
+{
+    GT_PIRL_FC_DEASSERT_EMPTY = 0,
+    GT_PIRL_FC_DEASSERT_CBS_LIMIT
+} GT_PIRL_FC_DEASSERT;
+
+
+/*
+ *  typedef: enum GT_PIRL_ELIMIT_MODE
+ *
+ *  Description: Enumeration of the port egress rate limit counting mode.
+ *
+ *  Enumerations:
+ *      GT_PIRL_ELIMIT_FRAME -
+ *                Count the number of frames
+ *      GT_PIRL_ELIMIT_LAYER1 -
+ *                Count all Layer 1 bytes:
+ *                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+ *      GT_PIRL_ELIMIT_LAYER2 -
+ *                Count all Layer 2 bytes: Frame's DA to CRC
+ *      GT_PIRL_ELIMIT_LAYER3 -
+ *                Count all Layer 3 bytes:
+ *                Frame's DA to CRC - 18 - 4 (if frame is tagged)
+ */
+typedef enum
+{
+    GT_PIRL_ELIMIT_FRAME = 0,
+    GT_PIRL_ELIMIT_LAYER1,
+    GT_PIRL_ELIMIT_LAYER2,
+    GT_PIRL_ELIMIT_LAYER3
+} GT_PIRL_ELIMIT_MODE;
+
+
+/* typedef: enum GT_RATE_LIMIT_MODE
+ * The ingress limit mode in the rate control register (0xA)
+ */
+
+typedef enum
+{
+    GT_LIMT_ALL = 0,         /* limit and count all frames */
+    GT_LIMIT_FLOOD,          /* limit and count Broadcast, Multicast and flooded unicast frames */
+    GT_LIMIT_BRDCST_MLTCST,    /* limit and count Broadcast and Multicast frames */
+    GT_LIMIT_BRDCST           /* limit and count Broadcast frames */
+} GT_RATE_LIMIT_MODE;
+
+/* typedef: enum GT_PRI0_RATE
+ * The ingress data rate limit for priority 0 frames
+ */
+
+typedef enum
+{
+    GT_NO_LIMIT = 0,     /* Not limited   */
+    GT_128K,              /* 128K bits/sec */
+    GT_256K,              /* 256K bits/sec */
+    GT_512K,              /* 512 bits/sec */
+    GT_1M,              /* 1M  bits/sec */
+    GT_2M,              /* 2M  bits/sec */
+    GT_4M,              /* 4M  bits/sec */
+    GT_8M,              /* 8M  bits/sec */
+    GT_16M,              /* 16M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+    GT_32M,              /* 32M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+    GT_64M,              /* 64M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+    GT_128M,              /* 128M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+    GT_256M              /* 256M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+} GT_PRI0_RATE,GT_EGRESS_RATE;
+
+
+/*
+ * Typedef: union GT_ERATE_TYPE
+ *
+ * Description: Egress Rate
+ *
+ * Fields:
+ *      definedRate - GT_EGRESS_RATE enum type should be used on the following devices:
+ *                        88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183, 88E6093
+ *                        88E6095, 88E6185, 88E6108, 88E6065, 88E6061, and their variations.
+ *      kbRate      - rate in kbps that should be used on the following devices:
+ *                        88E6097, 88E6096 with count mode of non frame, such as
+ *                                    ALL_LAYER1, ALL_LAYER2, and ALL_LAYER3
+ *                        64kbps ~ 1Mbps    : increments of 64kbps,
+ *                        1Mbps ~ 100Mbps   : increments of 1Mbps, and
+ *                        100Mbps ~ 1000Mbps: increments of 10Mbps
+ *                        Therefore, the valid values are:
+ *                            64, 128, 192, 256, 320, 384,..., 960,
+ *                            1000, 2000, 3000, 4000, ..., 100000,
+ *                            110000, 120000, 130000, ..., 1000000.
+ *      fRate         - frame per second that should be used on the following devices:
+ *                        88E6097, 88E6096 with count mode of frame (GT_PIRL_COUNT_FRAME)
+ */
+typedef union
+{
+    GT_EGRESS_RATE    definedRate;
+    MV_U32            kbRate;
+    MV_U32            fRate;
+} GT_ERATE_TYPE;
+
+/*
+ * Formula for Rate Limit of Gigabit Switch family and Enhanced FastEthernet Switch
+ */
+#define GT_GET_RATE_LIMIT(_kbps)    \
+        ((_kbps)?(8000000 / (28 * (_kbps))):0)
+#define GT_GET_RATE_LIMIT2(_kbps)    \
+        ((_kbps)?(8000000 / (32 * (_kbps)) + (8000000 % (32 * (_kbps))?1:0)):0)
+#define GT_GET_RATE_LIMIT3(_kbps)    \
+        ((_kbps)?(8000000 / (40 * (_kbps)) + (8000000 % (40 * (_kbps))?1:0)):0)
+
+#define MAX_RATE_LIMIT        256000    /* unit of Kbps */
+#define MIN_RATE_LIMIT        65        /* unit of Kbps */
+
+
+#define GT_GET_RATE_LIMIT_PER_FRAME(_frames, _dec)    \
+        ((_frames)?(1000000000 / (32 * (_frames)) + (1000000000 % (32 * (_frames))?1:0)):0)
+
+#define GT_GET_RATE_LIMIT_PER_BYTE(_kbps, _dec)    \
+        ((_kbps)?((8000000*(_dec)) / (32 * (_kbps)) + ((8000000*(_dec)) % (32 * (_kbps))?1:0)):0)
+
+/*
+ * typedef: enum GT_BURST_SIZE
+ * The ingress data rate limit burst size windows selection
+ */
+
+typedef enum
+{
+    GT_BURST_SIZE_12K = 0,     /* 12K byte burst size */
+    GT_BURST_SIZE_24K,        /* 24K byte burst size */
+    GT_BURST_SIZE_48K,        /* 48K byte burst size */
+    GT_BURST_SIZE_96K          /* 96K byte burst size */
+} GT_BURST_SIZE;
+
+/*
+ * typedef: enum GT_BURST_RATE
+ * The ingress data rate limit based on burst size
+ */
+
+typedef enum
+{
+    GT_BURST_NO_LIMIT = 0,     /* Not limited   */
+    GT_BURST_64K,          /* 64K bits/sec */
+    GT_BURST_128K,      /* 128K bits/sec */
+    GT_BURST_256K,      /* 256K bits/sec */
+    GT_BURST_384K,      /* 384K bits/sec */
+    GT_BURST_512K,      /* 512 bits/sec */
+    GT_BURST_640K,      /* 640K bits/sec */
+    GT_BURST_768K,      /* 768K bits/sec */
+    GT_BURST_896K,      /* 896K bits/sec */
+    GT_BURST_1M,        /* 1M  bits/sec */
+    GT_BURST_1500K,      /* 1.5M bits/sec */
+    GT_BURST_2M,        /* 2M  bits/sec */
+    GT_BURST_4M,        /* 4M  bits/sec */
+    GT_BURST_8M,           /* 8M  bits/sec */
+    GT_BURST_16M,          /* 16M  bits/sec */
+    GT_BURST_32M,          /* 32M  bits/sec */
+    GT_BURST_64M,          /* 64M  bits/sec */
+    GT_BURST_128M,         /* 128M  bits/sec */
+    GT_BURST_256M          /* 256M  bits/sec */
+} GT_BURST_RATE;
+
+/*
+ * Formula for burst based Rate Limit
+ */
+#define GT_GET_BURST_RATE_LIMIT(_bsize,_kbps)    \
+        ((_kbps)?(((_bsize)+1)*8000000 / (32 * (_kbps)) +         \
+                (((_bsize)+1)*8000000 % (32 * (_kbps))?1:0))    \
+                :0)
+
+/*
+ * Typedef: enum GT_PIRL_OPERATION
+ *
+ * Description: Defines the PIRL (Port Ingress Rate Limit) Operation type
+ *
+ * Fields:
+ *      PIRL_INIT_ALL_RESOURCE - Initialize all resources to the inital state
+ *      PIRL_INIT_RESOURCE     - Initialize selected resources to the inital state
+ *      PIRL_WRITE_RESOURCE    - Write to the selected resource/register
+ *      PIRL_READ_RESOURCE     - Read from the selected resource/register
+ */
+typedef enum
+{
+    PIRL_INIT_ALL_RESOURCE     = 0x1,
+    PIRL_INIT_RESOURCE        = 0x2,
+    PIRL_WRITE_RESOURCE        = 0x3,
+    PIRL_READ_RESOURCE        = 0x4
+} GT_PIRL_OPERATION, GT_PIRL2_OPERATION;
+
+
+/*
+ *  typedef: struct GT_PIRL_OP_DATA
+ *
+ *  Description: data required by PIRL Operation
+ *
+ *  Fields:
+ *      irlUnit   - Ingress Rate Limit Unit that defines one of IRL resources.
+ *      irlReg    - Ingress Rate Limit Register.
+ *      irlData   - Ingress Rate Limit Data.
+ */
+typedef struct
+{
+    MV_U32    irlUnit;
+    MV_U32    irlReg;
+    MV_U32    irlData;
+} GT_PIRL_OP_DATA;
+
+/*
+ *  typedef: struct GT_PIRL2_OP_DATA
+ *
+ *  Description: data required by PIRL Operation
+ *
+ *  Fields:
+ *      irlPort   - Ingress Rate Limiting port (physical port number).
+ *      irlRes    - Ingress Rate Limit Resource.
+ *      irlReg    - Ingress Rate Limit Register.
+ *      irlData   - Ingress Rate Limit Data.
+ */
+typedef struct
+{
+    MV_U32    irlPort;
+    MV_U32    irlRes;
+    MV_U32    irlReg;
+    MV_U32    irlData;
+} GT_PIRL2_OP_DATA;
+
+/*
+ * Typedef: enum GT_PIRL_ACTION
+ *
+ * Description: Defines the Action that should be taken when
+ *        there there are not enough tokens to accept the entire incoming frame
+ *
+ * Fields:
+ *        PIRL_ACTION_ACCEPT - accept the frame
+ *        PIRL_ACTION_USE_LIMIT_ACTION - use ESB Limit Action
+ */
+typedef enum
+{
+    PIRL_ACTION_USE_LIMIT_ACTION = 0x0,
+    PIRL_ACTION_ACCEPT     = 0x1
+} GT_PIRL_ACTION;
+
+/*
+ * Typedef: enum GT_ESB_LIMIT_ACTION
+ *
+ * Description: Defines the ESB Limit Action that should be taken when
+ *        the incoming port information rate exceeds the EBS_Limit.
+ *
+ * Fields:
+ *        ESB_LIMIT_ACTION_DROP - drop packets
+ *        ESB_LIMIT_ACTION_FC   - send flow control packet
+ */
+typedef enum
+{
+    ESB_LIMIT_ACTION_DROP     = 0x0,
+    ESB_LIMIT_ACTION_FC        = 0x1
+} GT_ESB_LIMIT_ACTION;
+
+
+/*
+ * Typedef: enum GT_BUCKET_RATE_TYPE
+ *
+ * Description: Defines the Bucket Rate Type
+ *
+ * Fields:
+ *        BUCKET_TYPE_TRAFFIC_BASED    - bucket is traffic type based
+ *        BUCKET_TYPE_RATE_BASED        - bucket is rate based
+ */
+typedef enum
+{
+    BUCKET_TYPE_TRAFFIC_BASED    = 0x0,
+    BUCKET_TYPE_RATE_BASED        = 0x1
+} GT_BUCKET_RATE_TYPE;
+
+/*
+ * Definition for GT_BUCKET_TYPE_TRAFFIC_BASED
+ *
+ * Description: Defines the Traffic Type that is used when Bucket Rate Type
+ *        is traffic type based (BUCKET_TYPE_TRAFFIC_BASED).
+ *        Please refer to the device datasheet in order to check which traffic
+ *        types are supported.
+ *
+ * Definition:
+ *        BUCKET_TRAFFIC_UNKNOWN_UNICAST    - unknown unicast frame
+ *        BUCKET_TRAFFIC_UNKNOWN_MULTICAST- unknown multicast frame
+ *        BUCKET_TRAFFIC_BROADCAST        - broadcast frame
+ *        BUCKET_TRAFFIC_MULTICAST        - multicast frame
+ *        BUCKET_TRAFFIC_UNICAST            - unicast frame
+ *        BUCKET_TRAFFIC_MGMT_FRAME        - management frame
+ *        BUCKET_TRAFFIC_ARP                - arp frame
+ *        BUCKET_TRAFFIC_TCP_DATA            - TCP Data
+ *        BUCKET_TRAFFIC_TCP_CTRL            - TCP Ctrl (if any of the TCP Flags[5:0] are set)
+ *        BUCKET_TRAFFIC_UDP                - UDP
+ *        BUCKET_TRAFFIC_NON_TCPUDP        - covers IGMP,ICMP,GRE,IGRP,L2TP
+ *        BUCKET_TRAFFIC_IMS                - Ingress Monitor Source
+ *        BUCKET_TRAFFIC_POLICY_MIRROR    - Policy Mirror
+ *        BUCKET_TRAFFIC_PLICY_TRAP        - Policy Trap
+ */
+#define BUCKET_TRAFFIC_UNKNOWN_UNICAST      0x01
+#define BUCKET_TRAFFIC_UNKNOWN_MULTICAST    0x02
+#define BUCKET_TRAFFIC_BROADCAST            0x04
+#define BUCKET_TRAFFIC_MULTICAST            0x08
+#define BUCKET_TRAFFIC_UNICAST                0x10
+#define BUCKET_TRAFFIC_MGMT_FRAME            0x20
+#define BUCKET_TRAFFIC_ARP                    0x40
+#define BUCKET_TRAFFIC_TCP_DATA                0x100
+#define BUCKET_TRAFFIC_TCP_CTRL                0x200
+#define BUCKET_TRAFFIC_UDP                    0x400
+#define BUCKET_TRAFFIC_NON_TCPUDP            0x800
+#define BUCKET_TRAFFIC_IMS                    0x1000
+#define BUCKET_TRAFFIC_POLICY_MIRROR        0x2000
+#define BUCKET_TRAFFIC_PLICY_TRAP            0x4000
+
+/*
+ *  typedef: enum GT_PIRL_COUNT_MODE
+ *
+ *  Description: Enumeration of the port egress rate limit counting mode.
+ *
+ *  Enumerations:
+ *      GT_PIRL_COUNT_ALL_LAYER1 -
+ *                Count all Layer 1 bytes:
+ *                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+ *      GT_PIRL_COUNT_ALL_LAYER2 -
+ *                Count all Layer 2 bytes: Frame's DA to CRC
+ *      GT_PIRL_COUNT_ALL_LAYER3 -
+ *                Count all Layer 3 bytes:
+ *                Frame's DA to CRC - 18 - 4 (if frame is tagged)
+ */
+typedef enum
+{
+    GT_PIRL_COUNT_ALL_LAYER1 = 0,
+    GT_PIRL_COUNT_ALL_LAYER2,
+    GT_PIRL_COUNT_ALL_LAYER3
+} GT_PIRL_COUNT_MODE;
+
+/*
+ *  typedef: enum GT_PIRL2_COUNT_MODE
+ *
+ *  Description: Enumeration of the port egress rate limit counting mode.
+ *
+ *  Enumerations:
+ *      GT_PIRL2_COUNT_FRAME -
+ *                Count the number of frames
+ *      GT_PIRL2_COUNT_ALL_LAYER1 -
+ *                Count all Layer 1 bytes:
+ *                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+ *      GT_PIRL2_COUNT_ALL_LAYER2 -
+ *                Count all Layer 2 bytes: Frame's DA to CRC
+ *      GT_PIRL2_COUNT_ALL_LAYER3 -
+ *                Count all Layer 3 bytes:
+ *                Frame's DA to CRC - 18 - 4 (if frame is tagged)
+ */
+typedef enum
+{
+    GT_PIRL2_COUNT_FRAME = 0,
+    GT_PIRL2_COUNT_ALL_LAYER1,
+    GT_PIRL2_COUNT_ALL_LAYER2,
+    GT_PIRL2_COUNT_ALL_LAYER3
+} GT_PIRL2_COUNT_MODE;
+
+
+
+/*
+ *  typedef: struct GT_PIRL_RESOURCE
+ *
+ *  Description: data structure that represents a PIRL Resource
+ *
+ *  Fields:
+ *      accountQConf    - account discarded frames due to queue congestion
+ *      accountFiltered - account filtered frames
+ *        ebsLimitAction  - action should be taken when the incoming rate exceeds
+ *                          the ebsLimit.
+ *                                ESB_LIMIT_ACTION_DROP - drop packets
+ *                                ESB_LIMIT_ACTION_FC   - send flow control packet
+ *        ebsLimit        - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
+ *        cbsLimit        - Committed BUrst Size limit (expected to be 2kBytes)
+ *        bktRateFactor   - bucket rate factor = bucketDecrement/updateInterval,
+ *                          where updateInterval indicates the rate at which the
+ *                          bucket needs to be updated with tokens, or 1/CIR,
+ *                          where CIR is the committed information rate in kbps.
+ *                          bucketDecrement indicates the amount of tokens that
+ *                          need to be removed per each bucket decrement.
+ *        bktIncrement    - the amount of tokens that need to be added for each
+ *                          byte of packet information.
+ *        bktRateType        - bucket is either rate based or traffic type based.
+ *                                BUCKET_TYPE_RATE_BASED, or
+ *                                BUCKET_TYPE_TRAFFIC_BASED
+ *        bktTypeMask        - used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED.
+ *                          any combination of the following definitions:
+ *                                BUCKET_TRAFFIC_UNKNOWN_UNICAST,
+ *                                BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
+ *                                BUCKET_TRAFFIC_BROADCAST,
+ *                                BUCKET_TRAFFIC_MULTICAST,
+ *                                BUCKET_TRAFFIC_UNICAST,
+ *                                BUCKET_TRAFFIC_MGMT_FRAME, and
+ *                                BUCKET_TRAFFIC_ARP
+ *        byteTobeCounted    - bytes to be counted for accounting
+ *                                GT_PIRL_COUNT_ALL_LAYER1,
+ *                                GT_PIRL_COUNT_ALL_LAYER2, or
+ *                                GT_PIRL_COUNT_ALL_LAYER3
+ *
+ */
+typedef struct
+{
+    MV_BOOL        accountQConf;
+    MV_BOOL        accountFiltered;
+    GT_ESB_LIMIT_ACTION ebsLimitAction;
+    MV_U32        ebsLimit;
+    MV_U32        cbsLimit;
+    MV_U32        bktRateFactor;
+    MV_U32        bktIncrement;
+    GT_BUCKET_RATE_TYPE    bktRateType;
+    MV_U32        bktTypeMask;
+    GT_PIRL_COUNT_MODE    byteTobeCounted;
+} GT_PIRL_RESOURCE;
+
+/*
+ *  typedef: struct GT_PIRL_CUSTOM_RATE_LIMIT
+ *
+ *  Description: The parameters that decides Ingress Rate Limit vary depending on
+ *                the application. Since DSDT driver cannot cover all the cases,
+ *                this structure is provided for the custom parameter setting.
+ *                However, in most cases, user may ingore this structure by setting
+ *                isValid to GT_FALSE. If Ingress Rate Limit is too much off from
+ *                the expected rate, please contact FAE and gets the correct ebsLimit,
+ *                cbsLimit,bktIncrement, and bktRateFactor value and use this structure
+ *                to do custom parameter setting.
+ *
+ *        isValid         - If GT_TRUE, the paramers in this structure are used
+ *                          to program PIRL Resource's Rate Limit. And ingressRate
+ *                          in GT_PIRL_BUCKET_DATA structure are ignored.
+ *                          If GT_FALSE, ingressRate in GT_PIRL_BUCKET_DATA structure
+ *                          is used for Resource's Rate Limit.
+ *        ebsLimit        - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
+ *        cbsLimit        - Committed Burst Size limit (expected to be 2kBytes)
+ *        bktIncrement    - the amount of tokens that need to be added for each
+ *                          byte of packet information.
+ *        bktRateFactor   - bucket rate factor = bucketDecrement/updateInterval,
+ *                          where updateInterval indicates the rate at which the
+ *                          bucket needs to be updated with tokens, or 1/CIR,
+ *                          where CIR is the committed information rate in kbps.
+ *                          bucketDecrement indicates the amount of tokens that
+ *                          need to be removed per each bucket decrement.
+*/
+typedef struct
+{
+    MV_BOOL        isValid;
+    MV_U32        ebsLimit;
+    MV_U32        cbsLimit;
+    MV_U32        bktIncrement;
+    MV_U32        bktRateFactor;
+} GT_PIRL_CUSTOM_RATE_LIMIT;
+
+/*
+ *  typedef: struct GT_PIRL_BUCKET_DATA
+ *
+ *  Description: data structure for PIRL Bucket programing that is resource based
+ *
+ *  Fields:
+ *        ingressRate       - commited ingress rate in kbps.
+ *                          64kbps ~ 1Mbps    : increments of 64kbps,
+ *                          1Mbps ~ 100Mbps   : increments of 1Mbps, and
+ *                          100Mbps ~ 200Mbps : increments of 10Mbps
+ *                          Therefore, the valid values are:
+ *                                64, 128, 192, 256, 320, 384,..., 960,
+ *                                1000, 2000, 3000, 4000, ..., 100000,
+ *                                110000, 120000, 130000, ..., 200000.
+ *        customSetup       - custom ingress rate parameter setup. please refer to
+ *                          GT_PIRL_CUSTOM_RATE_LIMIT structure.
+ *      accountQConf    - account discarded frames due to queue congestion
+ *      accountFiltered - account filtered frames
+ *        esbLimitAction     - action should be taken when the incoming rate exceeds
+ *                          the limit.
+ *                                ESB_LIMIT_ACTION_DROP - drop packets
+ *                                ESB_LIMIT_ACTION_FC   - send flow control packet
+ *        fcDeassertMode    - port flow control de-assertion mode when limitAction is
+ *                          set to ESB_LIMIT_ACTION_FC.
+ *                          fcDeassertMode[0] for port 0, fcDeassertMode[1] for
+ *                          port 1, etc. If port x does not share the bucket,
+ *                          fcDeassertMode[x] data will be ignored.
+ *                                GT_PIRL_FC_DEASSERT_EMPTY -
+ *                                    De-assert when the ingress rate resource has
+ *                                    become empty.
+ *                                GT_PIRL_FC_DEASSERT_CBS_LIMIT -
+ *                                    De-assert when the ingress rate resource has
+ *                                    enough room as specified by the CBSLimit.
+ *        bktRateType        - bucket is either rate based or traffic type based.
+ *                                BUCKET_TYPE_RATE_BASED, or
+ *                                BUCKET_TYPE_TRAFFIC_BASED
+ *        bktTypeMask        - used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED.
+ *                          any combination of the following definitions:
+ *                                BUCKET_TRAFFIC_UNKNOWN_UNICAST,
+ *                                BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
+ *                                BUCKET_TRAFFIC_BROADCAST,
+ *                                BUCKET_TRAFFIC_MULTICAST,
+ *                                BUCKET_TRAFFIC_UNICAST,
+ *                                BUCKET_TRAFFIC_MGMT_FRAME, and
+ *                                BUCKET_TRAFFIC_ARP
+ *        byteTobeCounted    - bytes to be counted for accounting
+ *                                GT_PIRL_COUNT_ALL_LAYER1,
+ *                                GT_PIRL_COUNT_ALL_LAYER2, or
+ *                                GT_PIRL_COUNT_ALL_LAYER3
+ *
+ */
+typedef struct
+{
+    MV_U32        ingressRate;
+    GT_PIRL_CUSTOM_RATE_LIMIT customSetup;
+    MV_BOOL        accountQConf;
+    MV_BOOL        accountFiltered;
+    GT_ESB_LIMIT_ACTION ebsLimitAction;
+    GT_PIRL_FC_DEASSERT fcDeassertMode[MAX_SWITCH_PORTS];
+    GT_BUCKET_RATE_TYPE    bktRateType;
+    MV_U32        bktTypeMask;
+    GT_PIRL_COUNT_MODE    byteTobeCounted;
+} GT_PIRL_DATA;
+
+
+/*
+ *  typedef: struct GT_PIRL2_RESOURCE
+ *
+ *  Description: data structure that represents a PIRL Resource
+ *
+ *  Fields:
+ *      accountQConf    - account discarded frames due to queue congestion
+ *      accountFiltered - account filtered frames
+ *      mgmtNrlEn         - exclude management frame from ingress rate limiting calculation
+ *      saNrlEn         - exclude from ingress rate limiting calculation if the SA of the
+ *                          frame is in ATU with EntryState that indicates Non Rate Limited.
+ *      daNrlEn         - exclude from ingress rate limiting calculation if the DA of the
+ *                          frame is in ATU with EntryState that indicates Non Rate Limited.
+ *        samplingMode    - sample one out of so many frames/bytes for a stream of frames
+ *        actionMode        - action should be taken when there are not enough tokens
+ *                          to accept the entire incoming frame
+ *                                PIRL_ACTION_ACCEPT - accept the frame
+ *                                PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
+ *        ebsLimitAction  - action should be taken when the incoming rate exceeds
+ *                          the ebsLimit.
+ *                                ESB_LIMIT_ACTION_DROP - drop packets
+ *                                ESB_LIMIT_ACTION_FC   - send flow control packet
+ *        ebsLimit        - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
+ *        cbsLimit        - Committed BUrst Size limit (expected to be 2kBytes)
+ *        bktRateFactor   - bucket rate factor = bucketDecrement/updateInterval,
+ *                          where updateInterval indicates the rate at which the
+ *                          bucket needs to be updated with tokens, or 1/CIR,
+ *                          where CIR is the committed information rate in kbps.
+ *                          bucketDecrement indicates the amount of tokens that
+ *                          need to be removed per each bucket decrement.
+ *        bktIncrement    - the amount of tokens that need to be added for each
+ *                          byte of packet information.
+ *        fcDeassertMode    - flow control de-assertion mode when limitAction is
+ *                          set to ESB_LIMIT_ACTION_FC.
+ *                                GT_PIRL_FC_DEASSERT_EMPTY -
+ *                                    De-assert when the ingress rate resource has
+ *                                    become empty.
+ *                                GT_PIRL_FC_DEASSERT_CBS_LIMIT -
+ *                                    De-assert when the ingress rate resource has
+ *                                    enough room as specified by the CBSLimit.
+ *        bktRateType        - bucket is either rate based or traffic type based.
+ *                                BUCKET_TYPE_RATE_BASED, or
+ *                                BUCKET_TYPE_TRAFFIC_BASED
+ *      priORpt         - determine the incoming frames that get rate limited using
+ *                          this ingress rate resource.
+ *                                  GT_TRUE - typeMask OR priMask
+ *                                  GT_FALSE - typeMask AND priMask
+ *        priMask         - priority bit mask that each bit indicates one of the four
+ *                          queue priorities. Setting each one of these bits indicates
+ *                          that this particular rate resource is slated to account for
+ *                          incoming frames with the enabled bits' priority.
+ *        bktTypeMask        - used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED.
+ *                          any combination of the following definitions:
+ *                                BUCKET_TRAFFIC_UNKNOWN_UNICAST,
+ *                                BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
+ *                                BUCKET_TRAFFIC_BROADCAST,
+ *                                BUCKET_TRAFFIC_MULTICAST,
+ *                                BUCKET_TRAFFIC_UNICAST,
+ *                                BUCKET_TRAFFIC_MGMT_FRAME,
+ *                                BUCKET_TRAFFIC_ARP,
+ *                                BUCKET_TRAFFIC_TCP_DATA,
+ *                                BUCKET_TRAFFIC_TCP_CTRL,
+ *                                BUCKET_TRAFFIC_UDP,
+ *                                BUCKET_TRAFFIC_NON_TCPUDP,
+ *                                BUCKET_TRAFFIC_IMS,
+ *                                BUCKET_TRAFFIC_POLICY_MIRROR, and
+ *                                BUCKET_TRAFFIC_PLICY_TRAP
+ *        byteTobeCounted    - bytes to be counted for accounting
+ *                                GT_PIRL2_COUNT_FRAME,
+ *                                GT_PIRL2_COUNT_ALL_LAYER1,
+ *                                GT_PIRL2_COUNT_ALL_LAYER2, or
+ *                                GT_PIRL2_COUNT_ALL_LAYER3
+ *
+ */
+typedef struct
+{
+    MV_BOOL        accountQConf;
+    MV_BOOL        accountFiltered;
+    MV_BOOL        mgmtNrlEn;
+    MV_BOOL        saNrlEn;
+    MV_BOOL        daNrlEn;
+    MV_BOOL        samplingMode;
+    GT_PIRL_ACTION    actionMode;
+    GT_ESB_LIMIT_ACTION ebsLimitAction;
+    MV_U32        ebsLimit;
+    MV_U32        cbsLimit;
+    MV_U32        bktRateFactor;
+    MV_U32        bktIncrement;
+    GT_PIRL_FC_DEASSERT fcDeassertMode;
+    GT_BUCKET_RATE_TYPE    bktRateType;
+    MV_BOOL        priORpt;
+    MV_U32        priMask;
+    MV_U32        bktTypeMask;
+    GT_PIRL2_COUNT_MODE    byteTobeCounted;
+} GT_PIRL2_RESOURCE;
+
+
+/*
+ *  typedef: struct GT_PIRL2_BUCKET_DATA
+ *
+ *  Description: data structure for PIRL2 Bucket programing that is port based.
+ *
+ *  Fields:
+ *        ingressRate       - commited ingress rate in kbps.
+ *                          64kbps ~ 1Mbps    : increments of 64kbps,
+ *                          1Mbps ~ 100Mbps   : increments of 1Mbps, and
+ *                          100Mbps ~ 200Mbps : increments of 10Mbps
+ *                          Therefore, the valid values are:
+ *                                64, 128, 192, 256, 320, 384,..., 960,
+ *                                1000, 2000, 3000, 4000, ..., 100000,
+ *                                110000, 120000, 130000, ..., 200000.
+ *        customSetup       - custom ingress rate parameter setup. please refer to
+ *                          GT_PIRL_CUSTOM_RATE_LIMIT structure.
+ *      accountQConf    - account discarded frames due to queue congestion
+ *      accountFiltered - account filtered frames
+ *      mgmtNrlEn         - exclude management frame from ingress rate limiting calculation
+ *      saNrlEn         - exclude from ingress rate limiting calculation if the SA of the
+ *                          frame is in ATU with EntryState that indicates Non Rate Limited.
+ *      daNrlEn         - exclude from ingress rate limiting calculation if the DA of the
+ *                          frame is in ATU with EntryState that indicates Non Rate Limited.
+ *        samplingMode    - sample one out of so many frames/bytes for a stream of frames
+ *        actionMode        - action should be taken when there are not enough tokens
+ *                          to accept the entire incoming frame
+ *                                PIRL_ACTION_ACCEPT - accept the frame
+ *                                PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
+ *        ebsLimitAction     - action should be taken when the incoming rate exceeds
+ *                          the limit.
+ *                                ESB_LIMIT_ACTION_DROP - drop packets
+ *                                ESB_LIMIT_ACTION_FC   - send flow control packet
+ *        fcDeassertMode    - flow control de-assertion mode when limitAction is
+ *                          set to ESB_LIMIT_ACTION_FC.
+ *                                GT_PIRL_FC_DEASSERT_EMPTY -
+ *                                    De-assert when the ingress rate resource has
+ *                                    become empty.
+ *                                GT_PIRL_FC_DEASSERT_CBS_LIMIT -
+ *                                    De-assert when the ingress rate resource has
+ *                                    enough room as specified by the CBSLimit.
+ *        bktRateType        - bucket is either rate based or traffic type based.
+ *                                BUCKET_TYPE_RATE_BASED, or
+ *                                BUCKET_TYPE_TRAFFIC_BASED
+ *      priORpt         - determine the incoming frames that get rate limited using
+ *                          this ingress rate resource.
+ *                                  GT_TRUE - typeMask OR priMask
+ *                                  GT_FALSE - typeMask AND priMask
+ *        priMask         - priority bit mask that each bit indicates one of the four
+ *                          queue priorities. Setting each one of these bits indicates
+ *                          that this particular rate resource is slated to account for
+ *                          incoming frames with the enabled bits' priority.
+ *        bktTypeMask        - used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED.
+ *                          any combination of the following definitions:
+ *                                BUCKET_TRAFFIC_UNKNOWN_UNICAST,
+ *                                BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
+ *                                BUCKET_TRAFFIC_BROADCAST,
+ *                                BUCKET_TRAFFIC_MULTICAST,
+ *                                BUCKET_TRAFFIC_UNICAST,
+ *                                BUCKET_TRAFFIC_MGMT_FRAME,
+ *                                BUCKET_TRAFFIC_ARP,
+ *                                BUCKET_TRAFFIC_TCP_DATA,
+ *                                BUCKET_TRAFFIC_TCP_CTRL,
+ *                                BUCKET_TRAFFIC_UDP,
+ *                                BUCKET_TRAFFIC_NON_TCPUDP,
+ *                                BUCKET_TRAFFIC_IMS,
+ *                                BUCKET_TRAFFIC_POLICY_MIRROR, and
+ *                                BUCKET_TRAFFIC_PLICY_TRAP
+ *        byteTobeCounted    - bytes to be counted for accounting
+ *                                GT_PIRL2_COUNT_FRAME,
+ *                                GT_PIRL2_COUNT_ALL_LAYER1,
+ *                                GT_PIRL2_COUNT_ALL_LAYER2, or
+ *                                GT_PIRL2_COUNT_ALL_LAYER3
+ *
+ */
+typedef struct
+{
+    MV_U32        ingressRate;
+    GT_PIRL_CUSTOM_RATE_LIMIT customSetup;
+    MV_BOOL        accountQConf;
+    MV_BOOL        accountFiltered;
+    MV_BOOL        mgmtNrlEn;
+    MV_BOOL        saNrlEn;
+    MV_BOOL        daNrlEn;
+    MV_BOOL        samplingMode;
+    GT_PIRL_ACTION    actionMode;
+    GT_ESB_LIMIT_ACTION ebsLimitAction;
+    GT_PIRL_FC_DEASSERT fcDeassertMode;
+    GT_BUCKET_RATE_TYPE    bktRateType;
+    MV_BOOL        priORpt;
+    MV_U32        priMask;
+    MV_U32        bktTypeMask;
+    GT_PIRL2_COUNT_MODE    byteTobeCounted;
+} GT_PIRL2_DATA;
+
+
+
+/*
+ *  typedef: struct GT_PIRL_CUSTOM_TSM_CFG
+ *
+ *  Description: The parameters that decides Ingress Rate Limit for AVB frames vary
+ *                 depending on the application. Since DSDT driver cannot cover all the cases,
+ *                this structure is provided for the custom parameter setting.
+ *                However, in most cases, user may ingore this structure by setting
+ *                isValid to GT_FALSE. If Ingress Rate Limit is too much off from
+ *                the expected rate, please contact FAE and gets the correct ebsLimit,
+ *                cbsLimit, CTS interval, and action mode value and use this structure
+ *                to do custom parameter setting.
+ *
+ *        isValid         - If GT_TRUE, the paramers in this structure are used
+ *                          to program PIRL Resource's Rate Limit. And ingressRate
+ *                          in GT_PIRL_TSM_DATA structure are ignored.
+ *                          If GT_FALSE, ingressRate in GT_PIRL_TSM_DATA structure
+ *                          is used for Resource's Rate Limit.
+ *        ebsLimit        - Excess Burst Size limit (0 ~ 0xFFFF)
+ *        cbsLimit        - Committed Burst Size limit (0 ~ 0xFFFF)
+ *        ctsIntv         - Class Time Slot Interval
+ *                          0 - interval is 62.5us
+ *                          1 - interval is 125us
+ *                          2 - interval is 250us
+ *                          3 - interval is 1000us
+ *        actionMode        - action should be taken when there are not enough tokens
+ *                          to accept the entire incoming frame
+ *                                PIRL_ACTION_ACCEPT - accept the frame
+ *                                PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
+*/
+typedef struct
+{
+    MV_BOOL        isValid;
+    MV_U32        ebsLimit;
+    MV_U32        cbsLimit;
+    MV_U32        ctsIntv;
+    GT_PIRL_ACTION        actionMode;
+} GT_PIRL_CUSTOM_TSM_CFG;
+
+
+/*
+ *  typedef: struct GT_PIRL2_TSM_DATA
+ *
+ *  Description: data structure for PIRL2 TSM Ingress Rate Limit.
+ *
+ *  Fields:
+ *        ebsLimit        - Excess Burst Size limit (0 ~ 0xFFFF)
+ *        cbsLimit        - Committed Burst Size limit (0 ~ 0xFFFF)
+ *        ctsIntv         - Class Time Slot Interval
+ *                          0 - interval is 62.5us
+ *                          1 - interval is 125us
+ *                          2 - interval is 250us
+ *                          3 - interval is 1000us
+ *        actionMode        - action should be taken when there are not enough tokens
+ *                          to accept the entire incoming frame
+ *                                PIRL_ACTION_ACCEPT - accept the frame
+ *                                PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
+ *         mgmtNrlEn         - exclude management frame from ingress rate limiting calculation
+ *        priMask         - priority bit mask that each bit indicates one of the four
+ *                          queue priorities. Setting each one of these bits indicates
+ *                          that this particular rate resource is slated to account for
+ *                          incoming frames with the enabled bits' priority.
+ *
+ */
+typedef struct
+{
+    MV_BOOL        tsmMode;
+    MV_U32        ebsLimit;
+    MV_U32        cbsLimit;
+    MV_U32        ctsIntv;
+    GT_PIRL_ACTION        actionMode;
+    MV_BOOL        mgmtNrlEn;
+    MV_U32        priMask;
+} GT_PIRL2_TSM_RESOURCE;
+
+
+
+/*
+ *  typedef: struct GT_PIRL2_TSM_DATA
+ *
+ *  Description: data structure for PIRL2 TSM Ingress Rate Limit.
+ *
+ *  Fields:
+ *        tsmMode            - enable/disable TSM mode.
+ *                          The following fields are ignored if diable
+ *        ingressRate       - commited ingress rate in kbps.(min 64 for 64kbps)
+ *        customSetup       - custom ingress rate parameter setup. please refer to
+ *                          GT_PIRL_CUSTOM_TSM_CFG structure.
+ *        mgmtNrlEn        - exclude management frame from ingress rate limiting calculation
+ *        priMask         - priority bit mask that each bit indicates one of the four
+ *                          queue priorities. Setting each one of these bits indicates
+ *                          that this particular rate resource is slated to account for
+ *                          incoming frames with the enabled bits' priority.
+ *
+ */
+typedef struct
+{
+    MV_BOOL        tsmMode;
+    MV_U32        ingressRate;
+    GT_PIRL_CUSTOM_TSM_CFG customSetup;
+    MV_BOOL        mgmtNrlEn;
+    MV_U32        priMask;
+} GT_PIRL2_TSM_DATA;
+
+
+
+#define MAX_PTP_CONSECUTIVE_READ    4
+
+
+/*
+ * Typedef: enum GT_PTP_OPERATION
+ *
+ * Description: Defines the PTP (Precise Time Protocol) Operation type
+ *
+ * Fields:
+ *      PTP_WRITE_DATA             - Write data to the PTP register
+ *      PTP_READ_DATA            - Read data from PTP register
+ *      PTP_READ_MULTIPLE_DATA    - Read multiple data from PTP register
+ *      PTP_READ_TIMESTAMP_DATA    - Read timestamp data from PTP register
+ *                    valid bit will be reset after read
+ */
+typedef enum
+{
+    PTP_WRITE_DATA             = 0x3,
+    PTP_READ_DATA              = 0x4,
+    PTP_READ_MULTIPLE_DATA    = 0x6,
+    PTP_READ_TIMESTAMP_DATA    = 0x8,
+} GT_PTP_OPERATION;
+
+
+/*
+ * Typedef: enum GT_PTP_SPEC
+ *
+ * Description: Defines the PTP (Precise Time Protocol) SPEC type
+ *
+ * Fields:
+ *      PTP_IEEE_1588         - IEEE 1588
+ *      PTP_IEEE_802_1AS    - IEEE 802.1as
+ */
+typedef enum
+{
+    PTP_IEEE_1588        = 0x0,
+    PTP_IEEE_802_1AS    = 0x1
+} GT_PTP_SPEC;
+
+
+/*
+ *  typedef: struct GT_PTP_OP_DATA
+ *
+ *  Description: data required by PTP Operation
+ *
+ *  Fields:
+ *      ptpPort        - physical port of the device
+ *      ptpAddr     - register address
+ *      ptpData     - data for ptp register.
+ *      ptpMultiData- used for multiple read operation.
+ *      nData         - number of data to be read on multiple read operation.
+ */
+typedef struct
+{
+    MV_U32    ptpPort;
+    MV_U32    ptpBlock;
+    MV_U32    ptpAddr;
+    MV_U32    ptpData;
+    MV_U32    ptpMultiData[MAX_PTP_CONSECUTIVE_READ];
+    MV_U32    nData;
+} GT_PTP_OP_DATA;
+
+
+
+/*
+ *  typedef: struct GT_PTP_GLOBAL_CONFIG
+ *
+ *  Description: PTP global configuration parameters
+ *
+ *  Fields:
+ *      ptpEType    - PTP Ether Type
+ *      msgIdTSEn     - Message IDs that needs time stamp
+ *      tsArrPtr     - Time stamp arrival time counter pointer (either Arr0Time or Arr1Time)
+ */
+typedef struct
+{
+    MV_U32    ptpEType;
+    MV_U32    msgIdTSEn;
+    MV_U32    tsArrPtr;
+} GT_PTP_GLOBAL_CONFIG;
+
+
+/*
+ *  typedef: struct GT_PTP_PORT_CONFIG
+ *
+ *  Description: PTP configuration parameters for each port
+ *
+ *  Fields:
+ *      transSpec    - This is to differentiate between various timing protocols.
+ *      disTSpec     - Disable Transport specific check
+ *      etJump         - offset to Ether type start address in bytes
+ *      ipJump         - offset to IP header start address counting from Ether type offset
+ *      ptpArrIntEn    - PTP port arrival interrupt enable
+ *      ptpDepIntEn    - PTP port departure interrupt enable
+ *      disTSOverwrite - disable time stamp counter overwriting until the corresponding
+ *                          timer valid bit is cleared.
+ *      arrTSMode      - PTP arrival TS mode.
+ */
+typedef struct
+{
+    GT_PTP_SPEC    transSpec;
+    MV_BOOL        disTSpec;
+    MV_U32         etJump;
+    MV_U32         ipJump;
+    MV_BOOL        ptpArrIntEn;
+    MV_BOOL        ptpDepIntEn;
+    MV_BOOL        disTSOverwrite;
+	MV_U32         arrTSMode;
+} GT_PTP_PORT_CONFIG;
+
+/*
+ *  typedef: struct GT_PTP_CONFIG
+ *
+ *  Description: PTP configuration parameters
+ *
+ *  Fields:
+ *      ptpEType    - PTP Ether Type
+ *      msgIdTSEn     - Message IDs that needs time stamp
+ *      tsArrPtr     - Time stamp arrival time counter pointer (either Arr0Time or Arr1Time)
+ *      ptpArrIntEn    - PTP port arrival interrupt enable
+ *      ptpDepIntEn    - PTP port departure interrupt enable
+ *      transSpec    - This is to differentiate between various timing protocols.
+ *      msgIdStartBit     - Message ID starting bit in the PTP common header
+ *      disTSOverwrite     - disable time stamp counter overwriting until the corresponding
+ *                          timer valid bit is cleared.
+ *      ptpPortConfig      - PTP port configuration array.
+ */
+typedef struct
+{
+    MV_U32    ptpEType;
+    MV_U32    msgIdTSEn;
+    MV_U32    tsArrPtr;
+
+    MV_U32    ptpArrIntEn;
+    MV_U32    ptpDepIntEn;
+    GT_PTP_SPEC    transSpec;
+    MV_U32    msgIdStartBit;
+    MV_BOOL    disTSOverwrite;
+	GT_PTP_PORT_CONFIG      ptpPortConfig[MAX_SWITCH_PORTS];
+} GT_PTP_CONFIG;
+
+
+/*
+ * Typedef: enum GT_PTP_TIME
+ *
+ * Description: Defines the PTP Time to be read
+ *
+ * Fields:
+ *      PTP_WRITE_DATA             - Write data to the PTP register
+ *      PTP_READ_DATA            - Read data from PTP register
+ *      PTP_READ_MULTIPLE_DATA    - Read multiple data from PTP register
+ */
+typedef enum
+{
+    PTP_ARR0_TIME = 0x0,
+    PTP_ARR1_TIME = 0x1,
+    PTP_DEP_TIME = 0x2
+} GT_PTP_TIME;
+
+
+/*
+ * Typedef: enum GT_PTP_INT_STATUS
+ *
+ * Description: Defines the PTP Port interrupt status for time stamp
+ *
+ * Fields:
+ *      PTP_INT_NORMAL        - No error condition occurred
+ *      PTP_INT_OVERWRITE     - PTP logic has to process more than one PTP frame
+ *                                  that needs time stamping before the current read.
+ *                                Only the latest one is saved.
+ *      PTP_INT_DROP          - PTP logic has to process more than one PTP frame
+ *                                  that needs time stamping before the current read.
+ *                                Only the oldest one is saved.
+ *
+ */
+typedef enum
+{
+    PTP_INT_NORMAL         = 0x0,
+    PTP_INT_OVERWRITE     = 0x1,
+    PTP_INT_DROP         = 0x2
+} GT_PTP_INT_STATUS;
+
+
+/*
+ *  typedef: struct GT_PTP_TS_STATUS
+ *
+ *  Description: PTP port status of time stamp
+ *
+ *  Fields:
+ *      isValid        - time stamp is valid
+ *      status        - time stamp error status
+ *      timeStamped    - time stamp value of a PTP frame that needs to be time stamped
+ *      ptpSeqId    - sequence ID of the frame whose time stamp information has been captured
+ */
+typedef struct
+{
+    MV_BOOL    isValid;
+    MV_U32    timeStamped;
+    MV_U32    ptpSeqId;
+    GT_PTP_INT_STATUS    status;
+} GT_PTP_TS_STATUS;
+
+
+/*
+ *  typedef: struct GT_PTP_PORT_DISCARD_STATS
+ *
+ *  Description: PTP port discard statistics. The counter (4 bit wide) wraps around after 15.
+ *
+ *  Fields:
+ *      tsDepDisCtr    - PTP departure frame discard counter for PTP frames that need time stamping.
+ *      ntsDepDisCtr    - PTP departure frame discard counter for PTP frames that do not need time stamping.
+ *      tsArrDisCtr    - PTP arrival frame discard counter for PTP frames that need time stamping.
+ *      ntsArrDisCtr    - PTP arrival frame discard counter for PTP frames that do not need time stamping.
+ */
+typedef struct
+{
+    MV_U32    tsDepDisCtr;
+    MV_U32    ntsDepDisCtr;
+    MV_U32    tsArrDisCtr;
+    MV_U32    ntsArrDisCtr;
+} GT_PTP_PORT_DISCARD_STATS;
+
+/* From Agate, to add arrival TS mode, to insert TS into frame */
+typedef enum
+{
+    PTP_ARR_TS_MODE_DIABLE  = 0,   /* PTP Arrival mode: disable TS mode modification */
+    PTP_ARR_TS_MODE_FRM_END = 1,   /* PTP Arrival mode: TS at end of frame */
+    PTP_ARR_TS_MODE_LOC_5   = 4,   /* PTP Arrival mode: TS at offset 5 in common header */
+    PTP_ARR_TS_MODE_LOC_17  = 16,  /* PTP Arrival mode: TS at offset 17 in common header */
+    PTP_ARR_TS_MODE_LOC_35  = 34,  /* PTP Arrival mode: TS at offset 35 in common header */
+    PTP_ARR_TS_MODE_LOC_ff         /* PTP Arrival mode: TS at the end of the frame */
+} GT_PTP_ARR_TS_MODE;
+
+
+
+#ifdef CONFIG_AVB_FPGA
+
+typedef enum
+{
+    PTP_CLOCK_SRC_AD_DEVICE = 0,    /* PTP Clock source is from A/D device */
+    PTP_CLOCK_SRC_FPGA                /* PTP Clock source is from Cesium FPGA */
+} GT_PTP_CLOCK_SRC;
+
+typedef enum
+{
+    PTP_P9_MODE_GMII = 0,     /* Port 9 uses GMII connect to 88E1111 */
+    PTP_P9_MODE_MII,        /* Port 9 uses MII connect to 88E1111 */
+    PTP_P9_MODE_MII_CONNECTOR,        /* Port 9 connect to MII connector */
+    PTP_P9_MODE_JUMPER        /* Use Jumper setup */
+} GT_PTP_P9_MODE;
+
+typedef enum
+{
+    GT_PTP_SIGN_NEGATIVE = 0,    /* apply Minus sign to the Duty Cycle */
+    GT_PTP_SIGN_PLUS            /* apply Plus sign to the Duty Cycle */
+} GT_PTP_SIGN;
+
+typedef struct
+{
+    GT_PTP_SIGN    adjSign;    /* determine the plus/minus sign of the duty cycle adj */
+    MV_U32    cycleStep;        /* number of steps which will be applied in adjusting the duty cycle high time
+                                of the 8KHz clock cycle.
+                                valid values are 0 ~ 7 */
+    MV_U32    cycleInterval;    /* define the interval of clock cycles for which a duty cycle adj will occur */
+    MV_U32    cycleAdjust;    /* define the number of 8KHz clock cycles for which duty cycle adj will occur
+                                within each PTP clock clycle interval.
+                                Note that (cycleAdjust <= cycleInterval) for proper operation */
+} GT_PTP_CLOCK_ADJUSTMENT;
+
+#endif
+
+/*
+ *  typedef: struct GT_TAI_EVENT_CONFIG
+ *
+ *  Description: TAI event capture configuration parameters
+ *
+ *  Fields:
+ *      eventOverwrite    - event capture overwrite
+ *      eventCtrStart     - event counter start
+ *      eventPhase        - event phase, When 0x1 the active phase of the PTP_EVREQ input
+ *        is inverted to be active low. When 0x0 the active phase of the PTP_EVREQ input
+ *        is normal activehigh
+ *      intEn             - event capture interrupt enable
+ */
+typedef struct
+{
+    MV_BOOL    eventOverwrite;
+    MV_BOOL    eventCtrStart;
+    MV_BOOL    eventPhase;
+    MV_BOOL    intEn;
+} GT_TAI_EVENT_CONFIG;
+
+
+/*
+ *  typedef: struct GT_TAI_EVENT_STATUS
+ *
+ *  Description: TAI event capture status
+ *
+ *  Fields:
+ *      isValid        - eventTime is valid
+ *      eventTime     - PTP global time when event is registered.
+ *      eventCtr    - event capture counter. increamented only if eventCtrStart is set.
+ *      eventErr    - isValid is already set when a new event is observed.
+ */
+typedef struct
+{
+    MV_BOOL    isValid;
+    MV_U32    eventTime;
+    MV_U32    eventCtr;
+    MV_BOOL    eventErr;
+} GT_TAI_EVENT_STATUS;
+
+
+typedef enum
+{
+    GT_TAI_TRIG_PERIODIC_PURSE = 0,    /* generate periodic purse */
+    GT_TAI_TRIG_ON_GIVEN_TIME        /* generate purse when
+                                    PTP global time matches with given time */
+} GT_TAI_TRIG_MODE;
+
+typedef enum
+{
+    GT_TAI_MULTI_PTP_SYNC_DISABLE = 0,  /* the EventRequest and TriggerGen interfaces operate normally. */
+    GT_TAI_MULTI_PTP_SYNC_ENABLE        /* the logic detects a low to high transition on
+										the EventRequest (GPIO) and transfers the value
+										in TrigGenAmt[31:0] (TAI Global Config 0x2, 0x3) into
+										the PTP Global Time register[31:0]. The EventCapTime[31:0]
+										(TAI global Status 0xA, 0xB) is also updated at that
+										instant. */
+} GT_TAI_MULTI_PTP_SYNC_MODE;
+
+
+/*
+ *  typedef: struct GT_TAI_CLOCK_SELECT
+ *
+ *  Description: TAI Clock select
+ *
+ *  Fields:
+ *      priRecClkSel      - Synchronous Ethernet Primary Recovered Clock Select.
+ *        This field indicates the internal PHY number whose recovered clock will be
+ *        presented on the SE_RCLK0 pin. The reset value of 0x7 selects no clock and
+ *        the pin is tri-stated.
+ *      syncRecClkSel     - Synchronous Ethernet Secondary Recovered Clock Select.
+ *      ptpExtClk         - PTP external Clock select
+ */
+typedef struct
+{
+    MV_U8    priRecClkSel;
+    MV_U8    syncRecClkSel;
+    MV_BOOL  ptpExtClk;
+} GT_TAI_CLOCK_SELECT;
+
+/*
+ *  typedef: struct GT_TAI_TRIGGER_CONFIG
+ *
+ *  Description: TAI trigger generator configuration parameters
+ *
+ *  Fields:
+ *      intEn         - trigger generator interrupt enable
+ *      trigPhase     - trigger phase, When 0x1 the active phase of the PTP_TRIG output
+ *        is inverted to be active low. When 0x0 the active phase of the PTP_TRIG output
+ *        is normal active high.
+ *      mode        - trigger mode, either GT_TAI_TRIG_PERIODIC_PURSE or
+ *                      GT_TAI_TRIG_ON_GIVEN_TIME
+ *      trigGenAmt     - if mode is GT_TAI_TRIG_PERIODIC_PURSE,
+ *                      this value is used as a clock period in TSClkPer increments
+ *                      If mode is GT_TAI_TRIG_ON_GIVEN_TIME,
+ *                      this value is used to compare with PTP global time.
+ *      pulseWidth        - pulse width in units of TSClkPer.
+ *                      this value should be 1 ~ 0xF. If it's 0, no changes made.
+ *                      this value is valid only in GT_TAI_TRIG_ON_GIVEN_TIME mode.
+ *      trigClkComp    - trigger mode clock compensation amount in pico sec.
+ *                      this value is valid only in GT_TAI_TRIG_PERIODIC_PURSE mode.
+ */
+typedef struct
+{
+    MV_BOOL    intEn;
+    MV_BOOL    trigPhase;
+    GT_TAI_TRIG_MODE     mode;
+    MV_U32    trigGenAmt;
+    MV_U32    pulseWidth;
+    MV_U32    trigClkComp;
+} GT_TAI_TRIGGER_CONFIG;
+
+
+
+/* AVB functions */
+typedef enum
+{
+    GT_AVB_HI_FPRI,        /* AVB Hi Frame Priority */
+    GT_AVB_HI_QPRI,        /* AVB Hi Queue Priority */
+    GT_AVB_LO_FPRI,        /* AVB Lo Frame Priority */
+    GT_AVB_LO_QPRI,        /* AVB Lo Queue Priority */
+    GT_LEGACY_HI_FPRI,    /* Legacy Hi Frame Priority */
+    GT_LEGACY_HI_QPRI,    /* Legacy Hi Queue Priority */
+    GT_LEGACY_LO_FPRI,    /* Legacy Lo Frame Priority */
+    GT_LEGACY_LO_QPRI    /* Legacy Lo Queue Priority */
+} GT_AVB_PRI_TYPE;
+
+
+typedef enum
+{
+    GT_AVB_LEGACY_MODE,            /* all frames entering the port are considered
+                                    legacy */
+    GT_AVB_STANDARD_AVB_MODE,    /* any tagged frame that ends up with an AVB frame
+                                    priority is considered AVB */
+    GT_AVB_ENHANCED_AVB_MODE,    /* any frame that ends up with an AVB frame priority
+                                    whose DA is contained in the ATU with an AVB Entry
+                                    state is considered AVB */
+    GT_AVB_SECURE_AVB_MODE        /* any frame that ends up with an AVB frame priority
+                                    whose DA is contained in the ATU with an AVB
+                                    entry state and whose DPV has this source port's
+                                    bit set to a one is considered AVB. */
+} GT_AVB_MODE;
+
+
+/*
+ * Typedef: enum GT_AVB_FRAME_POLICY
+ *
+ * Description: Defines the policy of the frame
+ *
+ * Fields:
+ *      AVB_FRAME_POLICY_NONE - Normal frame switching
+ *      AVB_FRAME_POLICY_MIRROR - Mirror(copy) frame to the MirrorDest port
+ *      AVB_FRAME_POLICY_TRAP - Trap(re-direct) frame to the CPUDest port
+ *
+ */
+typedef enum
+{
+    AVB_FRAME_POLICY_NONE = 0,
+    AVB_FRAME_POLICY_MIRROR,
+    AVB_FRAME_POLICY_TRAP
+} GT_AVB_FRAME_POLICY;
+
+
+/*
+ * Typedef: enum GT_AVB_FRAME_TYPE
+ *
+ * Description:
+ *        Defines the AVB frame type.
+ *        AVB Hi Frame is one that DA of the frame is contained in the ATU with an
+ *        Entry State that indicates AVB with priority override where the overridden
+ *        priority equals the Hi AVB frame priority(refer to gavbGetPriority API) and
+ *        when the port's DA AvbOverride is enabled.
+ *        AVB Lo Frame is one that DA of the frame is contained in the ATU with an
+ *        Entry State that indicates AVB with priority override where the overridden
+ *        priority equals the Lo AVB frame priority(refer to gavbGetPriority API) and
+ *        when the port's DA AvbOverride is enabled.
+ *
+ * Fields:
+ *      AVB_HI_FRAME    - AVB Hi Frame
+ *      AVB_LO_FRAME    - AVB Lo Frame
+ */
+typedef enum
+{
+    AVB_HI_FRAME,
+    AVB_LO_FRAME
+} GT_AVB_FRAME_TYPE;
+
+
+/*
+ * Typedef: enum GT_TCAM_OPERATION
+ *
+ * Description: Defines the TCAM (Ternary Content Addressable Memory) Operation type
+ *
+ * Fields:
+ *   TCAM_FLUSH_ALL       - Flush all entries
+ *   TCAM_FLUSH_ENTRY     - Flush or invalidate a single TCAM entry
+ *   TCAM_LOAD_ENTRY      - Load qn entry's page - or Purge an entry
+ *   TCAM_GET_NEXT_ENTRY  - Get Next (read next valid entry - all pages)
+ *   TCAM_READ_ENTRY      - Read an entry's page (perform a direct read of an entry)
+ */
+typedef enum
+{
+    TCAM_FLUSH_ALL       = 0x1,
+    TCAM_FLUSH_ENTRY     = 0x2,
+    TCAM_LOAD_ENTRY      = 0x3,
+    TCAM_PURGE_ENTRY     = 0x6,
+    TCAM_GET_NEXT_ENTRY  = 0x4,
+    TCAM_READ_ENTRY      = 0x5
+} GT_TCAM_OPERATION;
+
+typedef enum
+{
+    FRAME_TYPE_NORMAL  = 0,
+    FRAME_TYPE_DSA     = 1,
+    FRAME_TYPE_PROVIDE = 2,
+    FRAME_TYPE_RES = 3,
+} GT_FRAME_TYPE;
+
+/* The P3 register 31 work as follows in the following example sequence:
+o 0x00FF = Reset state, no hits yet
+o 0x0000 = 48-byte TCAM hit on Entry 0x00
+o 0x0201 = 96-byte TCAM hit on Entries 0x01 (low) and 0x02 (high)
+o 0x0003 = 48-byte TCAM hit on Entry 0x03
+o 0x0809 = 96-byte TCAM hit on Entries 0x09 (low) and 0x08 (high)
+o 0x0009 = 48-byte TCAM hit on Entry 0x09 with a TCAM miss on the high 48-bytes
+o 0x00FF = Miss on 1st 48 byte lookup
+*/
+typedef enum
+{
+    TCAM_HIT_RESET  = 0xFF,
+    TCAM_HIT_48_E0  = 0x00,
+    TCAM_HIT_96_E1  = 0x201,
+    TCAM_HIT_48_E3  = 0x03,
+    TCAM_HIT_96_E9  = 0x809,
+    TCAM_HIT_48_MISS  = 0x0FF,
+} GT_TCAM_HIT_STATUS;
+
+
+
+/*
+ *  typedef: struct GT_TCAM_DATA
+ *
+ *  Description: TCAM Key Data and Frame Match Data.
+ *  The bytes are in the lower 8 bits of each 16-bit register. The upper 8 bits of
+ *  each register are the Mask bits for the lower 8 bits where bit 15 is the mask
+ *  for bit 7, bit 14 is the mask for bit 6, etc. The individual pairs of data bits
+ *  and mask bits work together as follows:
+ *    Mask Data Meaning
+ *      0 0 Dont Care. The data bit can be a one or a zero for a TCAM hit to occur.
+ *      1 0 Hit on 0. The data bit must be a zero for a TCAM hit to occur.
+ *      1 1 Hit on 1. The data bit must be a one for a TCAM hit to occur.
+ *      0 1 Never Hit. Used to prevent a TCAM hit from occurring from this entry.
+ *    The Never Hit value is used to Flush the TCAM or Purge a TCAM entry.
+ *    On a TCAM Flush or Purge, this value it written to the 1st TCAM byte only
+ *    (offset 0x02 on TCAM page 1). On a TCAM Flush All or on a TCAM Flush
+ *    an entry, all other TCAM data and mask bytes are written to a value of 0x0000
+ *    and so are the Action bytes.
+ *
+ *  Fields:
+ *      frameType      - Frame Type. These bits are used to define the Frame type or mode
+ *      frameTypeMask  - Frame Type Mask.
+ *      spv      - Source Port Vector. These bits are used to define which switch ports
+ *                 can use this TCAM entry.
+ *      spvMask  - Source Port Vector Mask.
+ *      ppri      - When the TCAM entrys FrameMode bits are Provider Tagged, these bits are
+ *                  Provider Priority bits.
+ *      ppriMask  - Provider Priority Mask.
+ *      pvid      - When the TCAM entrys FrameMode bits are Provider Tagged, these bits are
+ *                  Provider VID bits..
+ *      pvidMask  - Provider VID Mask.
+ *      frameOctet      - Frame Octet 1-48 or 49-96. These are the match data for octet
+ *                        1-48 of the frame if the TCAM entry is for the first 48 bytes
+ *                        of a frame. If this TCAM entry is for the second 48 bytes of
+ *                        a frame this is the match data for octet 49 (or 97).
+ *      frameOctetMask  - Frame Octet Mask.
+ *      continu  - Continue this TCAM entry. This bit should only be a 1 on TCAM entries
+ *                that cover the first 48 bytes of a frame that needs to be extended to
+ *                also match bytes 49 to 96 of the frame or on any subsequent continuation
+ *                beyond byte 96 of the frame.
+ *      interrupt  - Interrupt on a TCAM hit. When this bit is set to a one on a TCAM entry
+ *                   (where the Continue bit is a zero), a TCAM hit interrupt will be
+ *                   generated whenever a match occurs to this entry.
+ *      IncTcamCtr   - Increment the ports TCAM Counter on a TCAM hit.
+ *      vidOverride  - VID Override Enable.
+ *      vidData    - VID Override Data.
+ *      nextId     - Next Index or Flow ID.
+ *      qpriOverride  - QPRI Override Enable.
+ *      qpriData      - QPRI Override Data.
+ *      fpriOverride  - FPRI Override Enable.
+ *      fpriData      - FPRI Override Data.
+ *      qpriAvbOverride  - QPRI_AVB Override Enable.
+ *      qpriAvbData      - QPRI_AVB Override Data.
+ *      dpvOverride  - DPV Override Enable.
+ *      dpvData      - DPV Override Data.
+ *      factionOverride  - Frame Action Override Enable.
+ *      factionData      - Frame Action Override Data.
+ *      ldBalanceOverride  - Load Balance Override Enable.
+ *      ldBalanceData      - Load Balance Override Data.
+ *      debugPort    - Debug Port Number.
+ *      highHit      - TCAM Entry for High 48-byte Hit..
+ *      lowHit       - TCAM Entry for High 48-byte Hit..
+*/
+
+
+typedef union
+/*typedef struct */
+{
+	MV_U8  frame[248];
+	struct _PARA {
+    MV_U8        frameType;
+    MV_U8        frameTypeMask;
+    MV_U8        spv;
+    MV_U8        spvMask;
+    MV_U8        ppri;
+    MV_U8        ppriMask;
+    MV_U16       pvid;
+    MV_U16       pvidMask;
+    MV_U8        frameOctet[48];
+    MV_U8        frameOctetMask[48];
+    MV_U8        continu;
+    MV_U8        interrupt;
+    MV_U8        IncTcamCtr;
+    MV_U8        vidOverride;
+    MV_U16       vidData;
+    MV_U8        nextId;
+    MV_U8        qpriOverride;
+    MV_U8        qpriData;
+    MV_U8        fpriOverride;
+    MV_U8        fpriData;
+    MV_U8        qpriAvbOverride;
+    MV_U8        qpriAvbData;
+    MV_U8        dpvOverride;
+    MV_U8        dpvData;
+    MV_U8        factionOverride;
+    MV_U16       factionData;
+    MV_U8        ldBalanceOverride;
+    MV_U8        ldBalanceData;
+    MV_U8        debugPort;
+    MV_U8        highHit;
+    MV_U8        lowHit;
+	}  paraFrm;
+} GT_TCAM_DATA;
+
+/*
+ *  typedef: struct GT_TCAM_OP_DATA
+ *
+ *  Description: data required by TCAM (Ternary Content Addressable Memory) Operation
+ *
+ *  Fields:
+ *      tcamPage - page  of TCAM
+ *      tcamEntry - pointer to the desired entry of TCAM
+ *      tcamData - TCAM data for the entry pointed by tcamEntry
+ */
+
+typedef struct
+{
+    MV_U32    tcamPage;
+    MV_U32    tcamEntry;
+    GT_TCAM_DATA    *tcamDataP;
+} GT_TCAM_OP_DATA;
+
+
+/*
+ * typedef: enum GT_EVENT_TYPE
+ *
+ * Description: Enumeration of the available hardware driven events.
+ *
+ * Enumerations:
+ *   GT_AVB_INT    - AVB Interrupt Enable
+ *   GT_DEVICE_INT - Device Interrupt (GT_DEVICE_INT_TYPE) Enable
+ *   GT_STATS_DONE - Statistics Operation Done interrrupt Enable
+ *   GT_VTU_PROB - VLAN Problem/Violation Interrupt Enable
+ *   GT_VTU_DONE - VALN Table Operation Done Interrupt Enable
+ *   GT_ATU_PROB - ATU Problem/Violation Interrupt Enable, for Gigabit Switch
+ *   GT_ATU_FULL - ATU full interrupt enable, for Fast Ethernet Switch
+ *   GT_ATU_DONE - ATU Done interrupt enable.
+ *   GT_PHY_INT  - PHY interrupt enable, for Fast Ethernet Switch
+ *   GT_EE_INT   - EEPROM Done interrupt enable.
+ */
+#define GT_AVB_INT               0x100
+#define GT_DEVICE_INT           0x80
+#define GT_STATS_DONE           0x40
+#define GT_VTU_PROB             0x20
+#define GT_VTU_DONE             0x10
+#define GT_ATU_PROB         0x8
+#define GT_ATU_FULL         0x8
+#define GT_ATU_DONE            0x4
+#define GT_PHY_INTERRUPT    0x2        /* Device may not support PHY Int. Please refer to datasheet. */
+#define GT_EE_INTERRUPT        0x1
+
+#define GT_INT_MASK            \
+        (GT_AVB_INT | GT_DEVICE_INT | GT_STATS_DONE | GT_VTU_PROB | GT_VTU_DONE | GT_ATU_FULL |     \
+        GT_ATU_DONE | GT_PHY_INTERRUPT | GT_EE_INTERRUPT)
+#define GT_NO_INTERNAL_PHY_INT_MASK        \
+        (GT_AVB_INT | GT_DEVICE_INT | GT_STATS_DONE | GT_VTU_PROB | GT_VTU_DONE | GT_ATU_PROB |     \
+        GT_ATU_DONE | GT_EE_INTERRUPT)
+
+
+/*
+ *  typedef: struct GT_DEV_EVENT
+ *
+ *  Description: Device interrupt status
+ *
+ *  Fields:
+ *      event     - Device Interrupts to be enabled
+ *                    GT_DEV_INT_WATCHDOG, GT_DEV_INT_JAMLIMIT,
+ *                    GT_DEV_INT_DUPLEX_MISMATCH, and/or GT_DEV_INT_SERDES_LINK
+ *      portList  - SERDES port list where GT_DEV_INT_SERDES_LINK interrupt needs
+ *                    to be asserted. It's in vector format, Bit 10 is for port 10,
+ *                    Bit 9 is for port 9, etc.
+ *                    valid only if GT_DEV_INT_SERDES_LINK bit is set.
+ *      phyList   - Phy list where GT_DEV_INT_PHY interrupt needs to be asserted.
+ *                    It's in vector format, Bit 0 is for port 0,
+ *                    Bit 1 is for port 1, etc.
+ *                    valid only if GT_DEV_INT_PHY bit is set.
+ */
+typedef struct
+{
+    MV_U32        event;
+    MV_U32        portList;
+    MV_U32        phyList;
+} GT_DEV_EVENT;
+
+
+/*
+ *  typedef: struct GT_DEV_INT_STATUS
+ *
+ *  Description: Device interrupt status
+ *
+ *  Fields:
+ *      intCause  - Device Interrupt Cause
+ *                    GT_DEV_INT_WATCHDOG, GT_DEV_INT_JAMLIMIT,
+ *                    GT_DEV_INT_DUPLEX_MISMATCH, and/or GT_DEV_INT_SERDES_LINK
+ *        port      - logical port where GT_DEV_INT_DUPLEX_MISMATCH occurred.
+ *                    valid only if GT_DEV_INT_DUPLEX_MISMATCH is set.
+ *      linkInt   - SERDES port list where GT_DEV_INT_SERDES_LINK interrupt is
+ *                    asserted. It's in vector format, Bit 10 is for port 10,
+ *                    Bit 9 is for port 9, etc.
+ *                    valid only if GT_DEV_INT_SERDES_LINK bit is set.
+ *                    These bits are only valid of the port that is in 1000Base-X mode.
+ */
+typedef struct
+{
+    MV_U32        devIntCause;
+    GT_LPORT    port;
+    MV_U32        linkInt;
+    MV_U32        phyInt;
+} GT_DEV_INT_STATUS;
+
+
+/*
+* GT_DEVICE_INT
+*
+* Description: Enumeration of Device interrupt
+*    GT_DEV_INT_WATCHDOG        - WatchDog event interrupt (WatchDog event can be
+*                              configured with gwdSetEvent API)
+*    GT_DEV_INT_JAMLIMIT        - any of the ports detect an Ingress Jam Limit violation
+*                              (gprtSetPauseLimitIn API)
+*    GT_DEV_INT_DUPLEX_MISMATCH    - any of the ports detect a duplex mismatch
+*                              (i.e., the local port is in half duplex mode while
+*                              the link partner is in full duplex mode)
+*    GT_DEV_INT_SERDES_LINK    - SERDES link chage interrupt.
+*                              An interrupt occurs when a SERDES port changes link
+*                              status (link up or link down)
+*/
+
+#define GT_DEV_INT_WATCHDOG            0x8
+#define GT_DEV_INT_JAMLIMIT            0x4
+#define GT_DEV_INT_DUPLEX_MISMATCH    0x2
+#define GT_DEV_INT_SERDES_LINK        0x1
+#define GT_DEV_INT_WAKE_EVENT         0x1
+#define GT_DEV_INT_PHY                0x10
+
+/*
+* GT_WATCHDOG_EVENT
+*
+* Description: Enumeration of WatchDog event
+*        GT_WD_QC  - Queue Controller Watch Dog enable.
+*                    When enabled, the QC's watch dog circuit checks for link
+*                    list errors and any errors found in the QC.
+*        GT_WD_EGRESS - Egress Watch Dog enable.
+*                    When enabled, each port's egress circuit checks for problems
+*                    between the port and the Queue Controller.
+*        GT_WD_FORCE - Force a Watch Dog event.
+*/
+
+#define GT_WD_QC        0x1
+#define GT_WD_EGRESS    0x2
+#define GT_WD_FORCE        0x4
+
+
+/*
+* typedef: struct GT_WD_EVENT_HISTORY
+*
+* Description: WatchDog Event History (cleared only by a hardware reset)
+*        wdEvent   - When it's set to GT_TRUE, some enabled Watch Dog event occurred.
+*                    The following events are possible:
+*                        QC WatchDog Event (GT_WD_QC)
+*                        Egress WatchDog Event (GT_WD_EGRESS)
+*                        Forced WatchDog Event (GT_WD_FORCE)
+*        egressEvent-If any port's egress logic detects an egress watch dog issue,
+*                    this field is set to GT_TRUE, regardless of the enabling GT_WD_EGRESS
+*                    event.
+*/
+typedef struct
+{
+    MV_BOOL    wdEvent;
+    MV_BOOL egressEvent;
+} GT_WD_EVENT_HISTORY;
+
+
+/*
+* typedef: enum GT_PHY_INT
+*
+* Description: Enumeration of PHY interrupt
+*/
+
+#define GT_SPEED_CHANGED         0x4000
+#define GT_DUPLEX_CHANGED        0x2000
+#define GT_PAGE_RECEIVED        0x1000
+#define GT_AUTO_NEG_COMPLETED    0x800
+#define GT_LINK_STATUS_CHANGED    0x400
+#define GT_SYMBOL_ERROR            0x200
+#define GT_FALSE_CARRIER        0x100
+#define GT_FIFO_FLOW            0x80
+#define GT_CROSSOVER_CHANGED    0x40
+#define GT_POLARITY_CHANGED        0x2
+#define GT_JABBER                0x1
+
+#define GT_AUTO_NEG_ERROR        0x8000
+#define GT_DOWNSHIFT_DETECT        0x20
+#define GT_ENERGY_DETECT        0x10
+
+/*
+* typedef: enum GT_PHY_AUTO_MODE
+*
+* Description: Enumeration of Autonegotiation mode.
+*    Auto for both speed and duplex.
+*    Auto for speed only and Full duplex.
+*    Auto for speed only and Half duplex. (1000Mbps is not supported)
+*    Auto for duplex only and speed 1000Mbps.
+*    Auto for duplex only and speed 100Mbps.
+*    Auto for duplex only and speed 10Mbps.
+*    1000Mbps Full duplex.
+*    100Mbps Full duplex.
+*    100Mbps Half duplex.
+*    10Mbps Full duplex.
+*    10Mbps Half duplex.
+*/
+
+typedef enum
+{
+    SPEED_AUTO_DUPLEX_AUTO,
+    SPEED_1000_DUPLEX_AUTO,
+    SPEED_100_DUPLEX_AUTO,
+    SPEED_10_DUPLEX_AUTO,
+    SPEED_AUTO_DUPLEX_FULL,
+    SPEED_AUTO_DUPLEX_HALF,
+    SPEED_1000_DUPLEX_FULL,
+    SPEED_1000_DUPLEX_HALF,
+    SPEED_100_DUPLEX_FULL,
+    SPEED_100_DUPLEX_HALF,
+    SPEED_10_DUPLEX_FULL,
+    SPEED_10_DUPLEX_HALF
+}GT_PHY_AUTO_MODE;
+
+
+/*
+* typedef: enum GT_PHY_PAUSE_MODE
+*
+* Description: Enumeration of Pause Mode in the Phy.
+*
+* Enumerations:
+*    GT_PHY_NO_PAUSE        - disable pause
+*    GT_PHY_PAUSE        - support pause
+*    GT_PHY_ASYMMETRIC_PAUSE    - support asymmetric pause
+*    GT_PHY_BOTH_PAUSE    - support both pause and asymmetric pause
+*/
+typedef enum
+{
+    GT_PHY_NO_PAUSE = 0,
+    GT_PHY_PAUSE,
+    GT_PHY_ASYMMETRIC_PAUSE,
+    GT_PHY_BOTH_PAUSE
+} GT_PHY_PAUSE_MODE;
+
+
+/*
+* typedef: enum GT_PHY_SPEED
+*
+* Description: Enumeration of Phy Speed
+*
+* Enumerations:
+*    PHY_SPEED_10_MBPS   - 10Mbps
+*    PHY_SPEED_100_MBPS    - 100Mbps
+*    PHY_SPEED_1000_MBPS - 1000Mbps
+*/
+typedef enum
+{
+    PHY_SPEED_10_MBPS,
+    PHY_SPEED_100_MBPS,
+    PHY_SPEED_1000_MBPS
+} GT_PHY_SPEED;
+
+
+/*
+* typedef: enum GT_SERDES_MODE
+*
+* Description: Enumeration of Serdes mode
+*
+* Enumerations:
+*    PHY_SERDES_100FX     - 100 FX
+*    PHY_SERDES_1000X     - 1000 X
+*    PHY_SERDES_SGMII_PHY - SGMII PHY
+*    PHY_SERDES_SGMII_MAC - SGMII MAC
+*/
+typedef enum
+{
+    PHY_SERDES_100FX = 0,
+    PHY_SERDES_1000X,
+    PHY_SERDES_SGMII_PHY,
+    PHY_SERDES_SGMII_MAC
+} GT_SERDES_MODE;
+
+
+/*
+* typedef: enum GT_EDETECT_MODE
+*
+* Description: Enumeration of Energy Detect mode
+*
+* Enumerations:
+*    GT_EDETECT_OFF        - Energy Detect disabled
+*    GT_EDETECT_SENSE_PULSE    - Energy Detect enabled with sense and pulse
+*    GT_EDETECT_SENSE    - Energy Detect enabled only with sense
+*/
+typedef enum
+{
+    GT_EDETECT_OFF = 0,
+    GT_EDETECT_SENSE_PULSE,
+    GT_EDETECT_SENSE
+} GT_EDETECT_MODE;
+
+/*
+ * typedef: enum GT_INGRESS_MODE
+ *
+ * Description: Enumeration of the port ingress mode.
+ *
+ * Enumerations:
+ *   GT_UNMODIFY_INGRESS - frames are receive unmodified.
+ *   GT_TRAILER_INGRESS  - all frames are received with trailer.
+ *   GT_UNTAGGED_INGRESS  - remove tag on receive (for double tagging).
+ *   GT_CPUPORT_INGRESS - no trailer. used to identify the CPU port for IGMP/MLD Snooping
+ */
+typedef enum
+{
+    GT_UNMODIFY_INGRESS = 0,  /* 0x00 */
+    GT_TRAILER_INGRESS,       /* 0x01 */
+    GT_UNTAGGED_INGRESS,      /* 0x10 */
+    GT_CPUPORT_INGRESS        /* 0x11 */
+} GT_INGRESS_MODE;
+
+
+/*
+ * typedef: enum GT_EGRESS_FLOOD
+ *
+ * Description: Enumeration of the port ingress mode.
+ *
+ * Enumerations:
+ *   GT_BLOCK_EGRESS_UNKNOWN - do not egress frame with unknown DA
+ *   GT_BLOCK_EGRESS_UNKNOWN_MULTICAST - do not egress frame with unknown multicast DA
+ *   GT_BLOCK_EGRESS_UNKNOWN_UNIICAST - do not egress frame with unknown unicast DA
+ *   GT_BLOCK_EGRESS_NONE - egress all frames with unknown DA
+ */
+typedef enum
+{
+    GT_BLOCK_EGRESS_UNKNOWN = 0,
+    GT_BLOCK_EGRESS_UNKNOWN_MULTICAST,
+    GT_BLOCK_EGRESS_UNKNOWN_UNICAST,
+    GT_BLOCK_EGRESS_NONE
+} GT_EGRESS_FLOOD;
+
+
+/*
+ *  typedef: enum GT_MC_RATE
+ *
+ *  Description: Enumeration of the port ingress mode.
+ *
+ *  Enumerations:
+ *      GT_MC_3_PERCENT_RL   - multicast rate is limited to 3 percent.
+ *      GT_MC_6_PERCENT_RL   - multicast rate is limited to 6 percent.
+ *      GT_MC_12_PERCENT_RL  - multicast rate is limited to 12 percent.
+ *      GT_MC_100_PERCENT_RL - unlimited multicast rate.
+ */
+typedef enum
+{
+    GT_MC_3_PERCENT_RL = 0,
+    GT_MC_6_PERCENT_RL,
+    GT_MC_12_PERCENT_RL,
+    GT_MC_100_PERCENT_RL,
+} GT_MC_RATE;
+
+
+/*
+ *  typedef: enum GT_INGRESS_RATE_MODE
+ *
+ *  Description: Enumeration of the port ingress rate limit mode.
+ *
+ *  Enumerations:
+ *      GT_RATE_PRI_BASE   - Priority based rate limiting
+ *        GT_RATE_BURST_BASE - Burst Size based rate limiting
+ */
+typedef enum
+{
+    GT_RATE_PRI_BASE = 0,
+    GT_RATE_BURST_BASE
+} GT_INGRESS_RATE_MODE;
+
+
+/*
+ *  typedef: enum GT_PORT_SCHED_MODE
+ *
+ *  Description: Enumeration of port scheduling mode
+ *
+ *  Fields:
+ *         GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
+ *         GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
+ *         GT_PORT_SCHED_STRICT_PRI3 - use a strict for priority 3 and weighted
+ *                                    round robin for the priority 2,1,and 0
+ *         GT_PORT_SCHED_STRICT_PRI2_3 - use a strict for priority 2,3 and weighted
+ *                                    round robin for the priority 1,and 0
+ *
+ *  Comment:
+ */
+typedef enum
+{
+    GT_PORT_SCHED_WEIGHTED_RRB = 0,
+    GT_PORT_SCHED_STRICT_PRI,
+    GT_PORT_SCHED_STRICT_PRI3,
+    GT_PORT_SCHED_STRICT_PRI2_3
+} GT_PORT_SCHED_MODE;
+
+
+/*
+ *  typedef: struct GT_PORT_STAT
+ *
+ *  Description: port statistic struct.
+ *
+ *  Fields:
+ *      rxCtr   - port receive counter.
+ *      txCtr   - port transmit counter.
+ *      dropped - dropped frame counter.
+ *
+ *  Comment:
+ *        dropped frame counter is supported by only limited devices.
+ *        At this moment, 88E6061/88E6065 are the devices supporting
+ *        dropped frame counter.
+ */
+typedef struct
+{
+    MV_U16  rxCtr;
+    MV_U16  txCtr;
+    MV_U16  dropped;
+} GT_PORT_STAT;
+
+/*
+ *  typedef: struct GT_PORT_STAT2
+ *
+ *  Description: port statistic struct.
+ *
+ *  Fields:
+ *      inDiscardLo - InDiscards Low Frame Counter
+ *      inDiscardHi - InDiscards High Frame Counter
+ *      inFiltered  - InFiltered Frame Counter
+ *      outFiltered - OutFiltered Frame Counter
+ *
+ *  Comment:
+ */
+typedef struct
+{
+    MV_U16  inDiscardLo;
+    MV_U16  inDiscardHi;
+    MV_U16  inFiltered;
+    MV_U16  outFiltered;
+} GT_PORT_STAT2;
+
+
+/*
+ **  typedef: struct GT_PORT_Q_COUNTERS
+ **
+ **  Description: port queue statistic struct.
+ **
+ **  Fields:
+ **      OutQ_Size - port egress queue size coi
+ **      Rsv_Size  - ingress reserved e counter
+ **
+ **/
+typedef struct
+{
+    MV_U16  OutQ_Size;
+    MV_U16  Rsv_Size;
+} GT_PORT_Q_STAT;
+
+/*
+ * typedef: enum GT_CTR_MODE
+ *
+ * Description: Enumeration of the port counters mode.
+ *
+ * Enumerations:
+ *   GT_CTR_ALL    - In this mode the counters counts Rx receive and transmit
+ *                   frames.
+ *   GT_CTR_ERRORS - In this mode the counters counts Rx Errors and collisions.
+ */
+typedef enum
+{
+    GT_CTR_ALL = 0,
+    GT_CTR_ERRORS,
+} GT_CTR_MODE;
+
+typedef struct _GT_QD_DEV GT_QD_DEV;
+
+/*
+ * semaphore related definitions.
+ * User Applications may register Semaphore functions using following definitions
+ */
+typedef enum
+{
+    GT_SEM_EMPTY,
+    GT_SEM_FULL
+} GT_SEM_BEGIN_STATE;
+
+typedef GT_SEM (*FGT_SEM_CREATE)(
+                        GT_SEM_BEGIN_STATE state);
+typedef MV_STATUS (*FGT_SEM_DELETE)(
+                        GT_SEM semId);
+typedef MV_STATUS (*FGT_SEM_TAKE)(
+                        GT_SEM semId, MV_U32 timOut);
+typedef MV_STATUS (*FGT_SEM_GIVE)(
+                        GT_SEM semId);
+
+typedef struct
+{
+    FGT_SEM_CREATE    semCreate;     /* create semapore */
+    FGT_SEM_DELETE    semDelete;     /* delete the semapore */
+    FGT_SEM_TAKE    semTake;    /* try to get a semapore */
+    FGT_SEM_GIVE    semGive;    /* return semaphore */
+}GT_SEM_ROUTINES;
+
+/*
+ * definitions for registering Hardware access function.
+ *
+*/
+/*#ifdef GT_RMGMT_ACCESS */
+#if 1
+/*
+ *  * Definition for the direction in HW_DEV_RW_REG structure.
+ *  */
+#define HW_REG_READ                     0
+#define HW_REG_WRITE            1
+#define HW_REG_WAIT_TILL_0      2
+#define HW_REG_WAIT_TILL_1      3
+
+/* HW_ACCESS_READ_REG and HW_ACCESS_WRITE_REG */
+typedef struct _HW_DEV_RW_REG
+{
+  unsigned long cmd;  /*INPUT:HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1 */
+  unsigned long addr; /*INPUT:SMI Address */
+  unsigned long reg;  /*INPUT:Register offset */
+  unsigned long data; /*INPUT,OUTPUT:Value in the Register or Bit number */
+} HW_DEV_RW_REG;
+
+#define  MAX_ACCESS_REG_NUM  12
+
+typedef struct _HW_DEV_REG_ACCESS
+{
+        unsigned long   entries;
+        HW_DEV_RW_REG   rw_reg_list[MAX_ACCESS_REG_NUM]; /* INPUT,OUTPUT: Reg Access information */
+} HW_DEV_REG_ACCESS;
+
+
+typedef MV_BOOL (*FGT_HW_ACCESS)(GT_QD_DEV* dev, HW_DEV_REG_ACCESS *regList);
+#endif
+
+/*
+ * definitions for registering MII access functions.
+ *
+*/
+typedef MV_BOOL (*FGT_READ_MII)(
+                        GT_QD_DEV*   dev,
+                        unsigned int phyAddr,
+                        unsigned int miiReg,
+                        unsigned int* value);
+typedef MV_BOOL (*FGT_WRITE_MII)(
+                        GT_QD_DEV*   dev,
+                        unsigned int phyAddr,
+                        unsigned int miiReg,
+                        unsigned int value);
+typedef MV_BOOL (*FGT_INT_HANDLER)(
+                        GT_QD_DEV*   dev,
+                        MV_U16*);
+
+typedef struct _BSP_FUNCTIONS
+{
+    MV_U32        hwAccessMod;    /* Hardware access mode */
+    FGT_READ_MII     readMii;    /* read MII Registers */
+    FGT_WRITE_MII     writeMii;    /* write MII Registers */
+#ifdef GT_RMGMT_ACCESS
+    FGT_HW_ACCESS   hwAccess;    /* Hardware access function */
+#endif
+    FGT_SEM_CREATE    semCreate;     /* create semapore */
+    FGT_SEM_DELETE    semDelete;     /* delete the semapore */
+    FGT_SEM_TAKE    semTake;    /* try to get a semapore */
+    FGT_SEM_GIVE    semGive;    /* return semaphore */
+}BSP_FUNCTIONS;
+
+
+/*
+ *    Type definition for MIB counter operation
+*/
+typedef enum
+{
+    STATS_FLUSH_ALL,        /* Flush all counters for all ports */
+    STATS_FLUSH_PORT,        /* Flush all counters for a port */
+    STATS_READ_COUNTER,        /* Read a specific counter from a port */
+    STATS_READ_REALTIME_COUNTER,    /* Read a realtime counter from a port */
+    STATS_READ_ALL            /* Read all counters from a port */
+
+} GT_STATS_OPERATION;
+
+typedef struct _GT_STATS_COUNTER_SET
+{
+    MV_U32    InUnicasts;
+    MV_U32    InBroadcasts;
+    MV_U32    InPause;
+    MV_U32    InMulticasts;
+    MV_U32    InFCSErr;
+    MV_U32    AlignErr;
+    MV_U32    InGoodOctets;
+    MV_U32    InBadOctets;
+    MV_U32    Undersize;
+    MV_U32    Fragments;
+    MV_U32    In64Octets;        /* 64 Octets */
+    MV_U32    In127Octets;    /* 65 to 127 Octets */
+    MV_U32    In255Octets;    /* 128 to 255 Octets */
+    MV_U32    In511Octets;    /* 256 to 511 Octets */
+    MV_U32    In1023Octets;    /* 512 to 1023 Octets */
+    MV_U32    InMaxOctets;    /* 1024 to Max Octets */
+    MV_U32    Jabber;
+    MV_U32    Oversize;
+    MV_U32    InDiscards;
+    MV_U32    Filtered;
+    MV_U32    OutUnicasts;
+    MV_U32    OutBroadcasts;
+    MV_U32    OutPause;
+    MV_U32    OutMulticasts;
+    MV_U32    OutFCSErr;
+    MV_U32    OutGoodOctets;
+    MV_U32    Out64Octets;    /* 64 Octets */
+    MV_U32    Out127Octets;    /* 65 to 127 Octets */
+    MV_U32    Out255Octets;    /* 128 to 255 Octets */
+    MV_U32    Out511Octets;    /* 256 to 511 Octets */
+    MV_U32    Out1023Octets;    /* 512 to 1023 Octets */
+    MV_U32    OutMaxOctets;    /* 1024 to Max Octets */
+    MV_U32    Collisions;
+    MV_U32    Late;
+    MV_U32    Excessive;
+    MV_U32    Multiple;
+    MV_U32    Single;
+    MV_U32    Deferred;
+    MV_U32    OutDiscards;
+
+} GT_STATS_COUNTER_SET;
+
+
+typedef enum
+{
+    STATS_InUnicasts = 0,
+    STATS_InBroadcasts,
+    STATS_InPause,
+    STATS_InMulticasts,
+    STATS_InFCSErr,
+    STATS_AlignErr,
+    STATS_InGoodOctets,
+    STATS_InBadOctets,
+    STATS_Undersize,
+    STATS_Fragments,
+    STATS_In64Octets,
+    STATS_In127Octets,
+    STATS_In255Octets,
+    STATS_In511Octets,
+    STATS_In1023Octets,
+    STATS_InMaxOctets,
+    STATS_Jabber,
+    STATS_Oversize,
+    STATS_InDiscards,
+    STATS_Filtered,
+    STATS_OutUnicasts,
+    STATS_OutBroadcasts,
+    STATS_OutPause,
+    STATS_OutMulticasts,
+    STATS_OutFCSErr,
+    STATS_OutGoodOctets,
+    STATS_Out64Octets,
+    STATS_Out127Octets,
+    STATS_Out255Octets,
+    STATS_Out511Octets,
+    STATS_Out1023Octets,
+    STATS_OutMaxOctets,
+    STATS_Collisions,
+    STATS_Late,
+    STATS_Excessive,
+    STATS_Multiple,
+    STATS_Single,
+    STATS_Deferred,
+    STATS_OutDiscards
+
+} GT_STATS_COUNTERS;
+/*
+ * typedef: enum GT_HISTOGRAM_MODE
+ *
+ * Description: Enumeration of the histogram counters mode.
+ *
+ * Enumerations:
+ *   GT_COUNT_RX_ONLY - In this mode, Rx Histogram Counters are counted.
+ *   GT_COUNT_TX_ONLY - In this mode, Tx Histogram Counters are counted.
+ *   GT_COUNT_RX_TX   - In this mode, Rx and Tx Histogram Counters are counted.
+ */
+typedef enum
+{
+    GT_COUNT_RX_ONLY = 0,
+    GT_COUNT_TX_ONLY,
+    GT_COUNT_RX_TX
+} GT_HISTOGRAM_MODE;
+
+/*
+    Counter set 2 is used by 88E6183
+*/
+typedef struct _GT_STATS_COUNTER_SET2
+{
+    MV_U32    InGoodOctetsHi;
+    MV_U32    InGoodOctetsLo;
+    MV_U32    InBadOctets;
+    MV_U32    OutDiscards;
+    MV_U32    InGoodFrames;
+    MV_U32    InBadFrames;
+    MV_U32    InBroadcasts;
+    MV_U32    InMulticasts;
+    /*
+        Histogram Counters : Rx Only, Tx Only, or both Rx and Tx
+        (refer to Histogram Mode)
+    */
+    MV_U32    Octets64;        /* 64 Octets */
+    MV_U32    Octets127;        /* 65 to 127 Octets */
+    MV_U32    Octets255;        /* 128 to 255 Octets */
+    MV_U32    Octets511;        /* 256 to 511 Octets */
+    MV_U32    Octets1023;        /* 512 to 1023 Octets */
+    MV_U32    OctetsMax;        /* 1024 to Max Octets */
+    MV_U32    OutOctetsHi;
+    MV_U32    OutOctetsLo;
+    MV_U32    OutFrames;
+    MV_U32    Excessive;
+    MV_U32    OutMulticasts;
+    MV_U32    OutBroadcasts;
+    MV_U32    InBadMACCtrl;
+
+    MV_U32    OutPause;
+    MV_U32    InPause;
+    MV_U32    InDiscards;
+    MV_U32    Undersize;
+    MV_U32    Fragments;
+    MV_U32    Oversize;
+    MV_U32    Jabber;
+    MV_U32    MACRcvErr;
+    MV_U32    InFCSErr;
+    MV_U32    Collisions;
+    MV_U32    Late;
+
+} GT_STATS_COUNTER_SET2;
+
+
+typedef enum
+{
+    STATS2_InGoodOctetsHi = 0,
+    STATS2_InGoodOctetsLo,
+    STATS2_InBadOctets,
+
+    STATS2_OutDiscards,
+    STATS2_InGoodFrames,
+    STATS2_InBadFrames,
+    STATS2_InBroadcasts,
+    STATS2_InMulticasts,
+    STATS2_64Octets,
+    STATS2_127Octets,
+    STATS2_255Octets,
+    STATS2_511Octets,
+    STATS2_1023Octets,
+    STATS2_MaxOctets,
+    STATS2_OutOctetsHi,
+    STATS2_OutOctetsLo,
+    STATS2_OutFrames,
+    STATS2_Excessive,
+    STATS2_OutMulticasts,
+    STATS2_OutBroadcasts,
+    STATS2_InBadMACCtrl,
+    STATS2_OutPause,
+    STATS2_InPause,
+    STATS2_InDiscards,
+    STATS2_Undersize,
+    STATS2_Fragments,
+    STATS2_Oversize,
+    STATS2_Jabber,
+    STATS2_MACRcvErr,
+    STATS2_InFCSErr,
+    STATS2_Collisions,
+    STATS2_Late
+
+} GT_STATS_COUNTERS2;
+
+/*
+    Counter set 3 is used by 88E6093 and 88E6065
+*/
+typedef struct _GT_STATS_COUNTER_SET3
+{
+    MV_U32    InGoodOctetsLo;    /* offset 0 */
+    MV_U32    InGoodOctetsHi;    /* offset 1, not supported by 88E6065 */
+    MV_U32    InBadOctets;        /* offset 2 */
+    MV_U32    OutFCSErr;            /* offset 3 */
+    MV_U32    InUnicasts;            /* offset 4 */
+    MV_U32    Deferred;            /* offset 5 */
+    MV_U32    InBroadcasts;        /* offset 6 */
+    MV_U32    InMulticasts;        /* offset 7 */
+    /*
+        Histogram Counters : Rx Only, Tx Only, or both Rx and Tx
+        (refer to Histogram Mode)
+    */
+    MV_U32    Octets64;        /* 64 Octets, offset 8 */
+    MV_U32    Octets127;        /* 65 to 127 Octets, offset 9 */
+    MV_U32    Octets255;        /* 128 to 255 Octets, offset 10 */
+    MV_U32    Octets511;        /* 256 to 511 Octets, offset 11 */
+    MV_U32    Octets1023;        /* 512 to 1023 Octets, offset 12 */
+    MV_U32    OctetsMax;        /* 1024 to Max Octets, offset 13 */
+    MV_U32    OutOctetsLo;    /* offset 14 */
+    MV_U32    OutOctetsHi;    /* offset 15, not supported by 88E6065 */
+    MV_U32    OutUnicasts;    /* offset 16 */
+    MV_U32    Excessive;        /* offset 17 */
+    MV_U32    OutMulticasts;    /* offset 18 */
+    MV_U32    OutBroadcasts;    /* offset 19 */
+    MV_U32    Single;            /* offset 20 */
+
+    MV_U32    OutPause;        /* offset 21 */
+    MV_U32    InPause;            /* offset 22 */
+    MV_U32    Multiple;        /* offset 23 */
+    MV_U32    Undersize;        /* offset 24 */
+    MV_U32    Fragments;        /* offset 25 */
+    MV_U32    Oversize;        /* offset 26 */
+    MV_U32    Jabber;            /* offset 27 */
+    MV_U32    InMACRcvErr;    /* offset 28 */
+    MV_U32    InFCSErr;        /* offset 29 */
+    MV_U32    Collisions;        /* offset 30 */
+    MV_U32    Late;                /* offset 31 */
+
+} GT_STATS_COUNTER_SET3;
+
+
+typedef enum
+{
+    STATS3_InGoodOctetsLo = 0,
+    STATS3_InGoodOctetsHi,
+    STATS3_InBadOctets,
+
+    STATS3_OutFCSErr,
+    STATS3_InUnicasts,
+    STATS3_Deferred,            /* offset 5 */
+    STATS3_InBroadcasts,
+    STATS3_InMulticasts,
+    STATS3_64Octets,
+    STATS3_127Octets,
+    STATS3_255Octets,            /* offset 10 */
+    STATS3_511Octets,
+    STATS3_1023Octets,
+    STATS3_MaxOctets,
+    STATS3_OutOctetsLo,
+    STATS3_OutOctetsHi,
+    STATS3_OutUnicasts,        /* offset 16 */
+    STATS3_Excessive,
+    STATS3_OutMulticasts,
+    STATS3_OutBroadcasts,
+    STATS3_Single,
+    STATS3_OutPause,
+    STATS3_InPause,
+    STATS3_Multiple,
+    STATS3_Undersize,            /* offset 24 */
+    STATS3_Fragments,
+    STATS3_Oversize,
+    STATS3_Jabber,
+    STATS3_InMACRcvErr,
+    STATS3_InFCSErr,
+    STATS3_Collisions,
+    STATS3_Late                    /* offset 31 */
+
+} GT_STATS_COUNTERS3;
+
+/* Switch Mac/Wol/Wof definitions */
+
+/*
+ * typedef: struct GT_1000T_MASTER_SLAVE
+ *
+ * Description: 1000Base-T Master/Slave Configuration
+ *
+ * Fields:
+ *      autoConfig   - GT_TRUE for auto-config, GT_FALSE for manual setup.
+ *      masterPrefer - GT_TRUE if Master configuration is preferred.
+ *
+ */
+typedef struct _GT_1000T_MASTER_SLAVE
+{
+    MV_BOOL    autoConfig;
+    MV_BOOL masterPrefer;
+} GT_1000T_MASTER_SLAVE;
+
+
+#define GT_MDI_PAIR_NUM         4    /* (1,2),(3,6),(4,5),(7,8) */
+#define GT_CHANNEL_PAIR_NUM     2    /* (channel A,B),(channel C,D) */
+
+
+/*
+ * typedef: enum GT_PHY_LINK_STATUS
+ *
+ * Description: Enumeration of Link Status
+ *
+ * Enumerations:
+ *        GT_PHY_LINK_OFF        - No Link
+ *        GT_PHY_LINK_COPPER    - Link on Copper
+ *        GT_PHY_LINK_FIBER    - Link on Fiber
+ */
+typedef enum
+{
+    GT_PHY_LINK_OFF = 0,
+    GT_PHY_LINK_COPPER = 1,
+    GT_PHY_LINK_FIBER = 2
+} GT_PHY_LINK_STATUS;
+
+
+/* Definition for packet generator */
+
+/* Payload */
+typedef enum
+{
+    GT_PG_PAYLOAD_RANDOM = 0,    /* Pseudo-random */
+    GT_PG_PAYLOAD_5AA5        /* 5A,A5,5A,A5,... */
+} GT_PG_PAYLOAD;
+
+/* Length */
+typedef enum
+{
+    GT_PG_LENGTH_64 = 0,        /* 64 bytes */
+    GT_PG_LENGTH_1514
+} GT_PG_LENGTH;
+
+/* Error */
+typedef enum
+{
+    GT_PG_TX_NORMAL = 0,        /* No Error */
+    GT_PG_TX_ERROR            /* Tx packets with CRC error and Symbol error */
+} GT_PG_TX;
+
+/* Structure for packet generator */
+typedef struct
+{
+    GT_PG_PAYLOAD  payload;
+    GT_PG_LENGTH   length;
+    GT_PG_TX       tx;
+} GT_PG;
+
+
+/*
+ * typedef: enum GT_TEST_STATUS
+ *
+ * Description: Enumeration of VCT test status
+ *
+ * Enumerations:
+ *      GT_TEST_FAIL    - virtual cable test failed.
+ *      GT_NORMAL_CABLE - normal cable.
+ *      GT_IMPEDANCE_MISMATCH - impedance mismatch.
+ *      GT_OPEN_CABLE   - open in cable.
+ *      GT_SHORT_CABLE  - short in cable.
+ *
+ */
+typedef enum
+{
+    GT_TEST_FAIL,
+    GT_NORMAL_CABLE,
+    GT_IMPEDANCE_MISMATCH,
+    GT_OPEN_CABLE,
+    GT_SHORT_CABLE,
+} GT_TEST_STATUS;
+
+
+/*
+ * typedef: enum GT_NORMAL_CABLE_LEN
+ *
+ * Description: Enumeration for normal cable length
+ *
+ * Enumerations:
+ *      GT_LESS_THAN_50M - cable length less than 50 meter.
+ *      GT_50M_80M       - cable length between 50 - 80 meter.
+ *      GT_80M_110M      - cable length between 80 - 110 meter.
+ *      GT_110M_140M     - cable length between 110 - 140 meter.
+ *      GT_MORE_THAN_140 - cable length more than 140 meter.
+ *      GT_UNKNOWN_LEN   - unknown length.
+ *
+ */
+typedef enum
+{
+    GT_LESS_THAN_50M,
+    GT_50M_80M,
+    GT_80M_110M,
+    GT_110M_140M,
+    GT_MORE_THAN_140,
+    GT_UNKNOWN_LEN,
+
+} GT_NORMAL_CABLE_LEN;
+
+
+/*
+ * typedef: enum GT_CABLE_LEN
+ *
+ * Description: Enumeration cable length
+ *
+ * Enumerations:
+ *      normCableLen - cable lenght for normal cable.
+ *      errCableLen  - for cable failure the estimate fault distance in meters.
+ *
+ */
+typedef union
+{
+    GT_NORMAL_CABLE_LEN normCableLen;
+    MV_U8               errCableLen;
+
+} GT_CABLE_LEN;
+
+/*
+ * typedef: struct GT_CABLE_STATUS
+ *
+ * Description: virtual cable diagnostic status per MDI pair.
+ *
+ * Fields:
+ *      cableStatus - VCT cable status.
+ *      cableLen    - VCT cable length.
+ *    phyType        - type of phy (100M phy or Gigabit phy)
+ */
+typedef struct
+{
+    GT_TEST_STATUS  cableStatus[GT_MDI_PAIR_NUM];
+    GT_CABLE_LEN    cableLen[GT_MDI_PAIR_NUM];
+    MV_U16        phyType;
+
+} GT_CABLE_STATUS;
+
+
+/*
+ * typedef: enum GT_CABLE_TYPE
+ *
+ * Description: Enumeration of Cable Type
+ *
+ * Enumerations:
+ *        GT_STRAIGHT_CABLE    _ straight cable
+ *      GT_CROSSOVER_CABLE     - crossover cable
+ */
+typedef enum
+{
+    GT_STRAIGHT_CABLE,
+    GT_CROSSOVER_CABLE
+
+} GT_CABLE_TYPE;
+
+
+/*
+ * typedef: enum GT_RX_CHANNEL
+ *
+ * Description: Enumeration of Receiver Channel Assignment
+ *
+ * Enumerations:
+ *        GT_CHANNEL_A   - Channel A
+ *        GT_CHANNEL_B   - Channel B
+ *        GT_CHANNEL_C   - Channel C
+ *        GT_CHANNEL_D   - Channel D
+ */
+typedef enum
+{
+    GT_CHANNEL_A,
+    GT_CHANNEL_B,
+    GT_CHANNEL_C,
+    GT_CHANNEL_D
+} GT_RX_CHANNEL;
+
+/*
+ * typedef: enum GT_POLARITY_STATUS
+ *
+ * Description: Enumeration of polarity status
+ *
+ * Enumerations:
+ *        GT_POSITIVE    - positive polarity
+ *      GT_NEGATIVE    - negative polarity
+ */
+typedef enum
+{
+    GT_POSITIVE,
+    GT_NEGATIVE
+
+} GT_POLARITY_STATUS;
+
+
+/*
+ * typedef: struct GT_1000BT_EXTENDED_STATUS
+ *
+ * Description: Currently the 1000Base-T PCS can determine the cable polarity
+ *         on pairs A,B,C,D; crossover on pairs A,B and C,D; and skew among
+ *        the pares. These status enhance the capability of the virtual cable tester
+ *
+ * Fields:
+ *      isValid        - GT_TRUE if this structure have valid information,
+ *                       GT_FALSE otherwise.
+ *                      It is valid only if 1000BASE-T Link is up.
+ *      pairSwap    - GT_CROSSOVER_CABLE, if the cable is crossover,
+ *                      GT_STRAIGHT_CABLE, otherwise
+ *        pairPolarity- GT_POSITIVE, if polarity is positive,
+ *                      GT_NEGATIVE, otherwise
+ *        pairSkew    - pair skew in units of ns
+ */
+typedef struct
+{
+    MV_BOOL                isValid;
+    GT_CABLE_TYPE        pairSwap[GT_CHANNEL_PAIR_NUM];
+    GT_POLARITY_STATUS    pairPolarity[GT_MDI_PAIR_NUM];
+    MV_U32                pairSkew[GT_MDI_PAIR_NUM];
+
+} GT_1000BT_EXTENDED_STATUS;
+
+/*
+ * typedef: struct GT_ADV_EXTENDED_STATUS
+ *
+ * Description: Currently the 1000Base-T PCS can determine the cable polarity
+ *         on pairs A,B,C,D; crossover on pairs A,B and C,D; and skew among
+ *        the pares. These status enhance the capability of the virtual cable tester
+ *
+ * Fields:
+ *      isValid        - GT_TRUE if this structure have valid information,
+ *                       GT_FALSE otherwise.
+ *                      It is valid only if 1000BASE-T Link is up.
+ *      pairSwap    - Receive channel assignement
+ *        pairPolarity- GT_POSITIVE, if polarity is positive,
+ *                      GT_NEGATIVE, otherwise
+ *        pairSkew    - pair skew in units of ns
+ *        cableLen    - cable length based on DSP
+ */
+typedef struct
+{
+    MV_BOOL            isValid;
+    GT_RX_CHANNEL      pairSwap[GT_MDI_PAIR_NUM];
+    GT_POLARITY_STATUS pairPolarity[GT_MDI_PAIR_NUM];
+    MV_U32             pairSkew[GT_MDI_PAIR_NUM];
+    MV_U32                cableLen[GT_MDI_PAIR_NUM];
+} GT_ADV_EXTENDED_STATUS;
+
+
+/*
+ * if isGigPhy in GT_CABLE_STATUS is not GT_TRUE, cableStatus and cableLen
+ * will have only 2 pairs available.
+ * One is RX Pair and the other is TX Pair.
+ */
+#define MDI_RX_PAIR        0    /* cableStatus[0] or cableLen[0] */
+#define MDI_TX_PAIR        1    /* cableStatus[1] or cableLen[1] */
+
+/* definition for Phy Type */
+#define PHY_100M        0 /* 10/100M phy, E3082 or E3083 */
+#define PHY_1000M        1 /* Gigabit phy, the rest phys */
+#define PHY_10000M        2 /* 10 Gigabit phy, unused */
+#define PHY_1000M_B        3 /* Gigabit phy which needs work-around */
+#define PHY_1000M_MP    4 /* Gigabit phy with multiple page mode */
+
+
+/* Definition for Advance Virtual Cable Test */
+
+/*
+ * typedef: enum GT_ADV_VCT_TRANS_CHAN_SEL
+ *
+ * Description: Enumeration of Advanced VCT Transmitter channel select
+ *
+ * Enumerations:
+ *        GT_ADV_VCT_NO_CROSSPAIR - Transmitter channel select is 000
+ *        GT_ADV_VCT_CROSSPAIR    - Transmitter channelselect is 100/101/110/111
+ */
+typedef enum
+{
+    /* Advanced VCT Mode */
+    GT_ADV_VCT_TCS_NO_CROSSPAIR        = 0,
+    GT_ADV_VCT_TCS_CROSSPAIR_0            = 0x4,
+    GT_ADV_VCT_TCS_CROSSPAIR_1            = 0x5,
+    GT_ADV_VCT_TCS_CROSSPAIR_2            = 0x6,
+    GT_ADV_VCT_TCS_CROSSPAIR_3            = 0x7
+} GT_ADV_VCT_TRANS_CHAN_SEL;
+
+
+typedef enum
+{
+    /* Advanced VCT Mode */
+    GT_ADV_VCT_SAVG_2        = 0,
+    GT_ADV_VCT_SAVG_4        = 1,
+    GT_ADV_VCT_SAVG_8        = 2,
+    GT_ADV_VCT_SAVG_16        = 3,
+    GT_ADV_VCT_SAVG_32        = 4,
+    GT_ADV_VCT_SAVG_64        = 5,
+    GT_ADV_VCT_SAVG_128    = 6,
+    GT_ADV_VCT_SAVG_256    = 7
+} GT_ADV_VCT_SAMPLE_AVG;
+
+typedef enum
+{
+    /* Advanced VCT Mode */
+    GT_ADV_VCT_MAX_PEAK        =0x00,
+    GT_ADV_VCT_FIRST_PEAK        =0x01,
+} GT_ADV_VCT_MOD;
+
+
+typedef unsigned int GT_ADV_VCT_PEAKDET_HYST;
+
+/*
+ * typedef: enum GT_ADV_VCT_MODE
+ *
+ * Description: Enumeration of Advanced VCT Mode and Transmitter channel select
+ *
+ * Enumerations:
+ *      GT_ADV_VCT_FIRST_PEAK   - first peak above a certain threshold is reported.
+ *      GT_ADV_VCT_MAX_PEAK     - maximum peak above a certain threshold is reported.
+ *        GT_ADV_VCT_OFFSE         - offset
+ *        GT_ADV_VCT_SAMPLE_POINT - sample point
+ *
+ *        GT_ADV_VCT_NO_CROSSPAIR - Transmitter channel select is 000
+ *        GT_ADV_VCT_CROSSPAIR    - Transmitter channelselect is 100/101/110/111
+ *   Example: mode = GT_ADV_VCT_FIRST_PEAK | GT_ADV_VCT_CROSSPAIR.
+ */
+typedef struct
+{
+    GT_ADV_VCT_MOD                    mode;
+    GT_ADV_VCT_TRANS_CHAN_SEL      transChanSel;
+    GT_ADV_VCT_SAMPLE_AVG            sampleAvg;
+    GT_ADV_VCT_PEAKDET_HYST        peakDetHyst;
+} GT_ADV_VCT_MODE;
+
+
+/*
+ * typedef: enum GT_ADV_VCT_STATUS
+ *
+ * Description: Enumeration of Advanced VCT status
+ *
+ * Enumerations:
+ *      GT_ADV_VCT_FAIL     - advanced virtual cable test failed.
+ *                             cable lengh cannot be determined.
+ *      GT_ADV_VCT_NORMAL   - normal cable.
+ *                             cable lengh may not be determined.
+ *      GT_ADV_VCT_IMP_GREATER_THAN_115 - impedance mismatch > 115 ohms
+ *                             cable lengh is valid.
+ *      GT_ADV_VCT_IMP_LESS_THAN_85 - impedance mismatch < 85 ohms
+ *                             cable lengh is valid.
+ *      GT_ADV_VCT_OPEN      - cable open
+ *                             cable lengh is valid.
+ *      GT_ADV_VCT_SHORT      - cable shorted
+ *                             cable lengh is valid.
+ *      GT_ADV_VCT_CROSS_PAIR_SHORT - cross pair short.
+ *                             cable lengh for each channel is valid.
+ */
+typedef enum
+{
+    GT_ADV_VCT_FAIL,
+    GT_ADV_VCT_NORMAL,
+    GT_ADV_VCT_IMP_GREATER_THAN_115,
+    GT_ADV_VCT_IMP_LESS_THAN_85,
+    GT_ADV_VCT_OPEN,
+    GT_ADV_VCT_SHORT,
+    GT_ADV_VCT_CROSS_PAIR_SHORT
+} GT_ADV_VCT_STATUS;
+
+
+/*
+ * typedef: struct GT_CROSS_PAIR_LIST
+ *
+ * Description: strucuture for cross pair short channels.
+ *
+ * Fields:
+ *      channel - cross pair short channel list
+ *                channel[i] is GT_TRUE if the channel[i] is cross pair short
+ *                with the current channel under test.
+ *      dist2fault - estimated distance to the shorted location.
+ *                   valid only if related channel (above) is GT_TRUE.
+ */
+typedef struct _GT_CROSS_SHORT_LIST
+{
+    MV_BOOL   channel[GT_MDI_PAIR_NUM];
+    MV_16     dist2fault[GT_MDI_PAIR_NUM];
+} GT_CROSS_SHORT_LIST;
+
+
+/*
+ * typedef: struct GT_ADV_CABLE_STATUS
+ *
+ * Description: strucuture for advanced cable status.
+ *
+ * Fields:
+ *      cableStatus - VCT cable status for each channel.
+ *      crossShort  - cross pair short list for each channel.
+ *                    Valid only if relative cableStatus is GT_ADV_VCT_CROSS_PAIR_SHORT.
+ *      dist2fault  - estimated distance to fault for each channel.
+ *                    Valid if relative cableStatus is one of the followings:
+ *                      GT_ADV_VCT_NORMAL
+ *                      GT_ADV_VCT_IMP_GREATER_THAN_115
+ *                      GT_ADV_VCT_IMP_LESS_THAN_85,
+ *                      GT_ADV_VCT_OPEN, or
+ *                        GT_ADV_VCT_SHORT
+  */
+typedef struct
+{
+    GT_ADV_VCT_STATUS   cableStatus[GT_MDI_PAIR_NUM];
+    union {
+        GT_CROSS_SHORT_LIST crossShort;
+        MV_16     dist2fault;
+    }u[GT_MDI_PAIR_NUM];
+} GT_ADV_CABLE_STATUS;
+
+
+/*
+ * Definition:
+ *        GT_LED_LINK_ACT_SPEED     - off = no link, on = link, blink = activity, blink speed = link speed
+ *        GT_LED_LINK_ACT             - off = no link, on = link, blink = activity
+ *        GT_LED_LINK                 - off = no link, on = link
+ *        GT_LED_10_LINK_ACT        - off = no link, on = 10, blink = activity
+ *        GT_LED_10_LINK            - off = no link, on = 10
+ *        GT_LED_100_LINK_ACT        - off = no link, on = 100 link, blink = activity
+ *        GT_LED_100_LINK            - off = no link, on = 100 link
+ *        GT_LED_1000_LINK_ACT    - off = no link, on = 1000 link, blink = activity
+ *        GT_LED_1000_LINK        - off = no link, on = 1000 link
+ *        GT_LED_10_100_LINK_ACT    - off = no link, on = 10 or 100 link, blink = activity
+ *        GT_LED_10_100_LINK        - off = no link, on = 10 or 100 link
+ *        GT_LED_10_1000_LINK_ACT    - off = no link, on = 10 or 1000 link, blink = activity
+ *        GT_LED_10_1000_LINK        - off = no link, on = 10 or 1000 link
+ *        GT_LED_100_1000_LINK_ACT- off = no link, on = 100 or 1000 link, blink = activity
+ *        GT_LED_100_1000_LINK    - off = no link, on = 100 or 1000 link
+ *        GT_LED_SPECIAL            - special leds
+ *        GT_LED_DUPLEX_COL        - off = half duplx, on = full duplex, blink = collision
+ *        GT_LED_ACTIVITY            - off = no link, blink on = activity
+ *        GT_LED_PTP_ACT            - blink on = PTP activity
+ *        GT_LED_FORCE_BLINK        - force blink
+ *        GT_LED_FORCE_OFF        - force off
+ *        GT_LED_FORCE_ON            - force on
+*/
+#define GT_LED_LINK_ACT_SPEED        1
+#define GT_LED_LINK_ACT            2
+#define GT_LED_LINK                3
+#define GT_LED_10_LINK_ACT            4
+#define GT_LED_10_LINK                5
+#define GT_LED_100_LINK_ACT        6
+#define GT_LED_100_LINK            7
+#define GT_LED_1000_LINK_ACT        8
+#define GT_LED_1000_LINK            9
+#define GT_LED_10_100_LINK_ACT        10
+#define GT_LED_10_100_LINK            11
+#define GT_LED_10_1000_LINK_ACT    12
+#define GT_LED_10_1000_LINK        13
+#define GT_LED_100_1000_LINK_ACT    14
+#define GT_LED_100_1000_LINK        15
+#define GT_LED_SPECIAL                16
+#define GT_LED_DUPLEX_COL            17
+#define GT_LED_ACTIVITY            18
+#define GT_LED_PTP_ACT                19
+#define GT_LED_FORCE_BLINK            20
+#define GT_LED_FORCE_OFF            21
+#define GT_LED_FORCE_ON            22
+#define GT_LED_RESERVE                23
+
+
+/*
+ * typedef: enum GT_LED_CFG
+ *
+ * Description: Enumeration for LED configuration type
+ *
+ * Enumerations:
+ *        GT_LED_CFG_LED0        - read/write led0 value (GT_LED_xxx definition)
+ *        GT_LED_CFG_LED1        - read/write led1 value
+ *        GT_LED_CFG_LED2        - read/write led2 value
+ *        GT_LED_CFG_LED3        - read/write led3 value
+ *        GT_LED_CFG_PULSE_STRETCH    - read/write pulse stretch (0 ~ 4)
+ *        GT_LED_CFG_BLINK_RATE        - read/write blink rate    (0 ~ 5)
+ *        GT_LED_CFG_SPECIAL_CONTROL    - read/write special control (port vector)
+ */
+typedef enum
+{
+    GT_LED_CFG_LED0,
+    GT_LED_CFG_LED1,
+    GT_LED_CFG_LED2,
+    GT_LED_CFG_LED3,
+    GT_LED_CFG_PULSE_STRETCH,
+    GT_LED_CFG_BLINK_RATE,
+    GT_LED_CFG_SPECIAL_CONTROL
+} GT_LED_CFG;
+
+
+/*
+ * typedef: enum GT_AVB_RECOVERED_CLOCK
+ *
+ * Description: Enumeration for recovered clock type
+ *
+ * Enumerations:
+ *        GT_PRIMARY_RECOVERED_CLOCK         - primary recovered clock
+ *        GT_SECONDARY_RECOVERED_CLOCK     - secondary recovered clock
+ */
+typedef enum
+{
+    GT_PRIMARY_RECOVERED_CLOCK,
+    GT_SECONDARY_RECOVERED_CLOCK
+} GT_AVB_RECOVERED_CLOCK;
+
+
+/* Define QAV interrupt bits */
+
+#define GT_QAV_INT_STATUS_ENQ_LMT_BIT            0x8000    /* EnQ Limit Interrupt Enable */
+#define GT_QAV_INT_STATUS_ISO_DEL_BIT            0x0400    /* Iso Delay Interrupt Enable */
+#define GT_QAV_INT_STATUS_ISO_DIS_BIT            0x0200  /* Iso Discard Interrupt Enable */
+#define GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT        0x0100  /* Iso Packet Memory Exceeded Interrupt Enable */
+
+#define GT_QAV_INT_ENABLE_ENQ_LMT_BIT            0x80  /* EnQ Limit Interrupt Enable */
+#define GT_QAV_INT_ENABLE_ISO_DEL_BIT            0x04  /* Iso Delay Interrupt Enable */
+#define GT_QAV_INT_ENABLE_ISO_DIS_BIT            0x02  /* Iso Discard Interrupt Enable */
+#define GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT        0x01  /* Iso Packet Memory Exceeded Interrupt Enable */
+
+
+/*
+ * Typedef: enum GT_EEPROM_OPERATION
+ *
+ * Description: Defines the EEPROM Operation type
+ *
+ * Fields:
+ *      PTP_WRITE_DATA             - Write data to the EEPROM register
+ *      PTP_READ_DATA            - Read data from EEPROM register
+ *      PTP_RESTART                - Restart EEPROM oprition
+ */
+typedef enum
+{
+    GT_EEPROM_NO_OP                     = 0x0,
+    GT_EEPROM_WRITE_DATA             = 0x3,
+    GT_EEPROM_READ_DATA              = 0x4,
+    GT_EEPROM_RESTART                = 0x6,
+    GT_EEPROM_HALT                    = 0x7,
+} GT_EEPROM_OPERATION;
+
+
+/*
+ *  typedef: struct GT_EEPROM_OP_DATA
+ *
+ *  Description: data required by EEPROM Operation
+ *
+ *  Fields:
+ *      eepromPort        - physical port of the device
+ *      eepromAddr     - register address
+ *      eepromData     - data for ptp register.
+ */
+typedef struct
+{
+    MV_U32    eepromPort;
+    MV_U32    eepromBlock;
+    MV_U32    eepromAddr;
+    MV_U32    eepromData;
+} GT_EEPROM_OP_DATA;
+
+#define GT_EEPROM_OP_ST_RUNNING_MASK        0x800
+#define GT_EEPROM_OP_ST_WRITE_EN_MASK        0x400
+
+#define GT_SCRAT_MISC_REG_SCRAT_0    0x00 /* Scratch Byte 0 */
+#define GT_SCRAT_MISC_REG_SCRAT_1    0x01 /* Scratch Byte 1 */
+#define GT_SCRAT_MISC_REG_GPIO_CFG    0x60 /* GPIO Configuration */
+                                         /* 0x61 = Reserved for future use */
+#define GT_SCRAT_MISC_REG_GPIO_DIR    0x62 /* GPIO Direction */
+#define GT_SCRAT_MISC_REG_GPIO_DAT    0x63 /* GPIO Data */
+#define GT_SCRAT_MISC_REG_CFG_DAT0    0x70 /* CONFIG Data 0 */
+#define GT_SCRAT_MISC_REG_CFG_DAT1    0x71 /* CONFIG Data 1 */
+#define GT_SCRAT_MISC_REG_CFG_DAT2    0x72 /* CONFIG Data 2 */
+#define GT_SCRAT_MISC_REG_CFG_DAT3    0x73 /* CONFIG Data 3 */
+#define GT_SCRAT_MISC_REG_SYNCE        0x7C /* SyncE & TAICLK125s Drive */
+#define GT_SCRAT_MISC_REG_P5_CLK    0x7D /* P5s & CLK125s Clock Drive */
+#define GT_SCRAT_MISC_REG_P6_CLK    0x7E /* P6s Clock Drive */
+#define GT_SCRAT_MISC_REG_EEPROM    0x7F /* EEPROM Pad drive */
+#define GT_SCRAT_MISC_REG_MAX        0x80 /* Maximun register pointer */
+
+#define GT_GPIO_BIT_0    0x1
+#define GT_GPIO_BIT_1    0x2
+#define GT_GPIO_BIT_2    0x4
+#define GT_GPIO_BIT_3    0x8
+#define GT_GPIO_BIT_4    0x10
+#define GT_GPIO_BIT_5    0x20
+#define GT_GPIO_BIT_6    0x40
+
+typedef struct
+{
+    MV_U8         user : 3;
+    MV_U8         addr : 5;
+}GT_CONFIG_DATA_0;
+
+typedef struct
+{
+    MV_U8         led  : 2;
+    MV_U8         fourcol : 1;
+    MV_U8         normCx : 1;
+    MV_U8         jumbo : 1;
+    MV_U8         ee_we : 1;
+    MV_U8         fd_flow : 1;
+    MV_U8         hd_flow : 1;
+}GT_CONFIG_DATA_1;
+
+typedef struct
+{
+    MV_U8         p5_mod : 3;
+    MV_U8         bit4     : 1;
+    MV_U8         p6_mod : 3;
+}GT_CONFIG_DATA_2;
+
+typedef struct
+{
+    MV_U8         rmu_mod : 2;
+}GT_CONFIG_DATA_3;
+
+typedef struct
+{
+    union {
+        MV_U8                Byte;
+        GT_CONFIG_DATA_0    Data;
+    } cfgData0;
+    union {
+        MV_U8                Byte;
+        GT_CONFIG_DATA_0    Data;
+    } cfgData1;
+    union {
+        MV_U8                Byte;
+        GT_CONFIG_DATA_0    Data;
+    } cfgData2;
+    union {
+        MV_U8                Byte;
+        GT_CONFIG_DATA_0    Data;
+    } cfgData3;
+}GT_CONFIG_DATA;
+
+
+/* definition for Trunking */
+#define IS_TRUNK_ID_VALID(_dev, _id)    (((_id) < 16) ? 1 : 0)
+
+
+/* definition for device scan mode */
+#define SMI_AUTO_SCAN_MODE        0    /* Scan 0 or 0x10 base address to find the QD */
+#define SMI_MANUAL_MODE            1    /* Use QD located at manually defined base addr */
+#define SMI_MULTI_ADDR_MODE        2    /* Use QD at base addr and use indirect access */
+typedef struct
+{
+    MV_U32    scanMode;    /* check definition for device scan mode */
+    MV_U32    baseAddr;    /* meaningful if scanMode is not SMI_AUTO_SCAN_MODE */
+} GT_SCAN_MODE;
+
+
+#define GT_SKIP_INIT_SETUP    0x736b6970
+
+/*
+ * Typedef: struct GT_SYS_CONFIG
+ *
+ * Description: System configuration Parameters struct.
+ *
+ * Fields:
+ *    devNum        - Switch Device Number
+ *  cpuPortNum  - The physical port used to connect the device to CPU.
+ *                This is the port to which packets destined to CPU are
+ *                forwarded.
+ *  initPorts   - Whether to initialize the ports state.
+ *                GT_FALSE    - leave in default state.
+ *                GT_TRUE     - Initialize to Forwarding state.
+ *  skipInitSetup - skip init setup, if value is GT_SKIP_INIT_SETUP
+ *                  perform init setup, otherwise
+ *                    Initializing port state is not affected by this variable.
+ *    BSPFunctions    - Group of BSP specific functions.
+ *                SMI Read/Write and Semaphore Related functions.
+ */
+typedef struct
+{
+    MV_U8         devNum;
+    MV_U8         cpuPortNum;
+    MV_BOOL       initPorts;
+    BSP_FUNCTIONS BSPFunctions;
+    GT_SCAN_MODE  mode;
+    MV_U32        skipInitSetup;
+}GT_SYS_CONFIG;
+
+#ifdef GT_RMGMT_ACCESS
+typedef enum
+{
+ HW_ACCESS_MODE_SMI = 0,    /* Use SMI */
+ HW_ACCESS_MODE_F2R = 1,    /* Use Marvell RMGMT(F2R) function */
+} FGT_HW_ACCESS_MOD;    /* Hardware access mode */
+#endif
+
+/*
+ * Typedef: struct GT_QD_DEV
+ *
+ * Description: Includes Tapi layer switch configuration data.
+ *
+ * Fields:
+ *   deviceId       - The device type identifier.
+ *   revision       - The device revision number.
+ *   baseRegAddr    - Switch Base Register address.
+ *   numOfPorts     - Number of active ports.
+ *   maxPorts       - max ports. This field is only for driver's use.
+ *   cpuPortNum     - Logical port number whose physical port is connected to the CPU.
+ *   maxPhyNum      - max configurable Phy address.
+ *   stpMode        - current switch STP mode (0 none, 1 en, 2 dis)
+ *   accessMode        - shows how to find and access the device.
+ *   phyAddr        - SMI address used to access Switch registers(only for SMI_MULTI_ADDR_MODE).
+ *   validPortVec   - valid port list in vector format
+ *   validPhyVec    - valid phy list in vector format
+ *   validSerdesVec    - valid serdes list in vector format
+ *   devGroup        - the device group
+ *   devName        - name of the device in group 0
+ *   devName1        - name of the device in group 1
+ *   devStorage        - driver internal use (hold various temp information)
+ *   multiAddrSem   - Semaphore for Accessing SMI Device
+ *   atuRegsSem     - Semaphore for ATU access
+ *   vtuRegsSem     - Semaphore for VTU access
+ *   statsRegsSem   - Semaphore for RMON counter access
+ *   pirlRegsSem    - Semaphore for PIRL Resource access
+ *   ptpRegsSem     - Semaphore for PTP Resource access
+ *   tblRegsSem     - Semaphore for various Table Resource access,
+ *                    such as Trunk Tables and Device Table
+ *   eepromRegsSem  - Semaphore for eeprom control access
+ *   phyRegsSem     - Semaphore for PHY Device access
+ *   hwAccessRegsSem - Semaphore for Remote management access
+ *   fgtHwAccessMod - Select register access mode: Read/Write or Hardware access function
+ *   fgtReadMii     - platform specific SMI register Read function
+ *   fgtWriteMii    - platform specific SMI register Write function
+ *   fgtHwAccess    - platform specific register access function
+ *   semCreate      - function to create semapore
+ *   semDelete      - function to delete the semapore
+ *   semTake        - function to get a semapore
+ *   semGive        - function to return semaphore
+ *   appData        - application data that user may use
+ */
+struct _GT_QD_DEV
+{
+    GT_DEVICE   deviceId;
+    GT_LPORT    cpuPortNum;
+    MV_U8       revision;
+    MV_U8        devNum;
+    MV_U8        devEnabled;
+    MV_U8       baseRegAddr;
+    MV_U8       numOfPorts;
+    MV_U8        maxPorts;
+    MV_U8       maxPhyNum;
+    MV_U8        stpMode;
+    MV_U8        accessMode;
+    MV_U8        phyAddr;
+    MV_U16        reserved;
+    MV_U16        validPortVec;
+    MV_U16        validPhyVec;
+    MV_U16        validSerdesVec;
+    MV_U16        devGroup;
+    MV_U32        devName;
+    MV_U32        devName1;
+    MV_U32        devStorage;
+    GT_SEM        multiAddrSem;
+    GT_SEM        atuRegsSem;
+    GT_SEM        vtuRegsSem;
+    GT_SEM        statsRegsSem;
+    GT_SEM        pirlRegsSem;
+    GT_SEM        ptpRegsSem;
+    GT_SEM        tblRegsSem;
+    GT_SEM        eepromRegsSem;
+    GT_SEM        phyRegsSem;
+    GT_SEM        hwAccessRegsSem;
+
+    FGT_READ_MII  fgtReadMii;
+    FGT_WRITE_MII fgtWriteMii;
+#ifdef GT_RMGMT_ACCESS
+    FGT_HW_ACCESS_MOD fgtHwAccessMod;    /* Hardware access mode */
+    FGT_HW_ACCESS fgtHwAccess;    /* Hardware access  */
+#endif
+
+    FGT_SEM_CREATE  semCreate;     /* create semaphore */
+    FGT_SEM_DELETE  semDelete;     /* delete the semaphore */
+    FGT_SEM_TAKE    semTake;    /* try to get a semaphore */
+    FGT_SEM_GIVE    semGive;    /* return semaphore */
+    void*           appData;
+
+    /* Modified to add port mapping functions into device ssystem configuration. */
+#ifdef GT_PORT_MAP_IN_DEV
+    MV_U8           (*lport2port)   (MV_U16 portVec, GT_LPORT port);
+    GT_LPORT        (*port2lport)   (MV_U16 portVec, MV_U8 hwPort);
+    MV_U32          (*lportvec2portvec) (MV_U16 portVec, MV_U32 lVec);
+    MV_U32          (*portvec2lportvec) (MV_U16 portVec, MV_U32 pVec);
+#endif
+
+    MV_BOOL       use_mad;     /* use MAD driver to process Phy */
+#ifdef GT_USE_MAD
+	MAD_DEV	mad_dev;
+#endif
+};
+
+
+typedef struct _EXTRA_OP_DATA
+{
+    MV_U32 moveFrom;
+    MV_U32 moveTo;
+    MV_U32 intCause;
+    MV_U32 reserved;
+} GT_EXTRA_OP_DATA;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __msApi_h */
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/dsdt/msApiPrototype.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/dsdt/msApiPrototype.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/dsdt/msApiPrototype.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/dsdt/msApiPrototype.h	2014-04-11 00:04:06.000000000 +0700
@@ -0,0 +1,22043 @@
+//#include <Copyright.h>
+#include "Copyright.h"
+
+/********************************************************************************
+* msApiPrototype.h
+*
+* DESCRIPTION:
+*       API Prototypes for QuarterDeck Device
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __msApiPrototype_h
+#define __msApiPrototype_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+* portToSmiMapping
+*
+* DESCRIPTION:
+*       This function mapps port to smi address
+*
+* INPUTS:
+*        dev - device context
+*       portNum - Port number to read the register for.
+*        accessType - type of register (Phy, Port, or Global)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       smiAddr    - smi address.
+*
+*******************************************************************************/
+MV_U8 portToSmiMapping
+(
+    IN GT_QD_DEV *dev,
+    IN MV_U8    portNum,
+    IN MV_U32    accessType
+);
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+* gfdbSetAtuSize
+*
+* DESCRIPTION:
+*       Sets the Mac address table size.
+*
+* INPUTS:
+*       size    - Mac address table size.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbSetAtuSize
+(
+    IN GT_QD_DEV *dev,
+    IN ATU_SIZE size
+);
+
+
+/*******************************************************************************
+* gfdbGetAgingTimeRange
+*
+* DESCRIPTION:
+*       Gets the maximal and minimum age times that the hardware can support.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       maxTimeout - max aging time in secounds.
+*       minTimeout - min aging time in secounds.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbGetAgingTimeRange
+(
+    IN GT_QD_DEV *dev,
+    OUT MV_U32 *maxTimeout,
+    OUT MV_U32 *minTimeout
+);
+
+/*******************************************************************************
+* gfdbGetAgingTimeout
+*
+* DESCRIPTION:
+*       Gets the timeout period in seconds for aging out dynamically learned
+*       forwarding information. The returned value may not be the same as the value
+*        programmed with <gfdbSetAgingTimeout>. Please refer to the description of
+*        <gfdbSetAgingTimeout>.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       timeout - aging time in seconds.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbGetAgingTimeout
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U32       *timeout
+);
+
+/*******************************************************************************
+* gfdbSetAgingTimeout
+*
+* DESCRIPTION:
+*       Sets the timeout period in seconds for aging out dynamically learned
+*       forwarding information. The standard recommends 300 sec.
+*        Supported aging timeout values are multiple of time-base, where time-base
+*        is either 15 or 16 seconds, depending on the Switch device. For example,
+*        88E6063 uses time-base 16, and so supported aging timeouts are 0,16,32,
+*        48,..., and 4080. If unsupported timeout value (bigger than 16) is used,
+*        the value will be rounded to the nearest supported value smaller than the
+*        given timeout. If the given timeout is less than 16, minimum timeout value
+*        16 will be used instead. E.g.) 35 becomes 32 and 5 becomes 16.
+*        <gfdbGetAgingTimeRange> function can be used to find the time-base.
+*
+* INPUTS:
+*       timeout - aging time in seconds.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbSetAgingTimeout
+(
+    IN GT_QD_DEV *dev,
+    IN MV_U32 timeout
+);
+
+
+
+/*******************************************************************************
+* gfdbGetAtuDynamicCount
+*
+* DESCRIPTION:
+*       Gets the current number of dynamic unicast entries in this
+*       Filtering Database.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       numDynEntries - number of dynamic entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - vlan does not exist.
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbGetAtuDynamicCount
+(
+    IN GT_QD_DEV *dev,
+    OUT MV_U32 *numDynEntries
+);
+
+
+
+/*******************************************************************************
+* gfdbGetAtuEntryFirst
+*
+* DESCRIPTION:
+*       Gets first lexicographic MAC address entry from the ATU.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       atuEntry - match Address translate unit entry.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - table is empty.
+*
+* COMMENTS:
+*       Search starts from Mac[00:00:00:00:00:00]
+*
+*        DBNum in atuEntry -
+*            ATU MAC Address Database number. If multiple address
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
+*
+*******************************************************************************/
+MV_STATUS gfdbGetAtuEntryFirst
+(
+    IN GT_QD_DEV *dev,
+    OUT GT_ATU_ENTRY    *atuEntry
+);
+
+
+
+/*******************************************************************************
+* gfdbGetAtuEntryNext
+*
+* DESCRIPTION:
+*       Gets next lexicographic MAC address from the specified Mac Addr.
+*
+* INPUTS:
+*       atuEntry - the Mac Address to start the search.
+*
+* OUTPUTS:
+*       atuEntry - match Address translate unit entry.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*       Search starts from atu.macAddr[xx:xx:xx:xx:xx:xx] specified by the
+*       user.
+*
+*        DBNum in atuEntry -
+*            ATU MAC Address Database number. If multiple address
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
+*
+*******************************************************************************/
+MV_STATUS gfdbGetAtuEntryNext
+(
+    IN GT_QD_DEV *dev,
+    INOUT GT_ATU_ENTRY  *atuEntry
+);
+
+
+
+/*******************************************************************************
+* gfdbFindAtuMacEntry
+*
+* DESCRIPTION:
+*       Find FDB entry for specific MAC address from the ATU.
+*
+* INPUTS:
+*       atuEntry - the Mac address to search.
+*
+* OUTPUTS:
+*       found    - GT_TRUE, if the appropriate entry exists.
+*       atuEntry - the entry parameters.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*        DBNum in atuEntry -
+*            ATU MAC Address Database number. If multiple address
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
+*
+*******************************************************************************/
+MV_STATUS gfdbFindAtuMacEntry
+(
+    IN GT_QD_DEV *dev,
+    INOUT GT_ATU_ENTRY  *atuEntry,
+    OUT MV_BOOL         *found
+);
+
+
+
+/*******************************************************************************
+* gfdbFlush
+*
+* DESCRIPTION:
+*       This routine flush all or unblocked addresses from the MAC Address
+*       Table.
+*
+* INPUTS:
+*       flushCmd - the flush operation type.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbFlush
+(
+    IN GT_QD_DEV *dev,
+    IN GT_FLUSH_CMD flushCmd
+);
+
+/*******************************************************************************
+* gfdbFlushInDB
+*
+* DESCRIPTION:
+*       This routine flush all or unblocked addresses from the particular
+*       ATU Database (DBNum). If multiple address databases are being used, this
+*        API can be used to flush entries in a particular DBNum database.
+*
+* INPUTS:
+*       flushCmd - the flush operation type.
+*        DBNum     - ATU MAC Address Database Number.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbFlushInDB
+(
+    IN GT_QD_DEV *dev,
+    IN GT_FLUSH_CMD flushCmd,
+    IN MV_U32 DBNum
+);
+
+/*******************************************************************************
+* gfdbAddMacEntry
+*
+* DESCRIPTION:
+*       Creates the new entry in MAC address table.
+*
+* INPUTS:
+*       macEntry    - mac address entry to insert to the ATU.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK             - on success
+*       GT_FAIL           - on error
+*       GT_NO_RESOURCE    - failed to allocate a t2c struct
+*       GT_OUT_OF_CPU_MEM - oaMalloc failed
+*
+* COMMENTS:
+*        DBNum in atuEntry -
+*            ATU MAC Address Database number. If multiple address
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbAddMacEntry
+(
+    IN GT_QD_DEV *dev,
+    IN GT_ATU_ENTRY *macEntry
+);
+
+
+
+/*******************************************************************************
+* gfdbDelMacEntry
+*
+* DESCRIPTION:
+*       Deletes MAC address entry.
+*
+* INPUTS:
+*       macAddress - mac address.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*       For SVL mode vlan Id is ignored.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbDelMacEntry
+(
+    IN GT_QD_DEV *dev,
+    IN MV_U8     *macAddress
+);
+
+/*******************************************************************************
+* gfdbDelAtuEntry
+*
+* DESCRIPTION:
+*       Deletes ATU entry.
+*
+* INPUTS:
+*       atuEntry - the ATU entry to be deleted.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*        DBNum in atuEntry -
+*            ATU MAC Address Database number. If multiple address
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
+*
+*******************************************************************************/
+MV_STATUS gfdbDelAtuEntry
+(
+    IN GT_QD_DEV *dev,
+    IN GT_ATU_ENTRY  *atuEntry
+);
+
+/*******************************************************************************
+* gfdbLearnEnable
+*
+* DESCRIPTION:
+*       Enable/disable automatic learning of new source MAC addresses on port
+*       ingress.
+*
+* INPUTS:
+*       en - GT_TRUE for enable  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbLearnEnable
+(
+    IN GT_QD_DEV *dev,
+    IN MV_BOOL  en
+);
+
+
+/*******************************************************************************
+* gfdbGetLearnEnable
+*
+* DESCRIPTION:
+*       Get automatic learning status of new source MAC addresses on port ingress.
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       en - GT_TRUE if enabled  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbGetLearnEnable
+(
+    IN GT_QD_DEV    *dev,
+    OUT MV_BOOL  *en
+);
+
+/*******************************************************************************
+* gstpSetMode
+*
+* DESCRIPTION:
+*       This routine Enable the Spanning tree.
+*
+* INPUTS:
+*       en - GT_TRUE for enable, GT_FALSE for disable.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       when enabled, this function sets all port to blocking state, and inserts
+*       the BPDU MAC into the ATU to be captured to CPU, on disable all port are
+*       being modified to be in forwarding state.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gstpSetMode
+(
+    IN GT_QD_DEV *dev,
+    IN MV_BOOL  en
+);
+
+
+
+/*******************************************************************************
+* gstpSetPortState
+*
+* DESCRIPTION:
+*       This routine set the port state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       state - the port state to set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gstpSetPortState
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT           port,
+    IN GT_PORT_STP_STATE  state
+);
+
+
+
+/*******************************************************************************
+* gstpGetPortState
+*
+* DESCRIPTION:
+*       This routine returns the port state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       state - the current port state.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gstpGetPortState
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT           port,
+    OUT GT_PORT_STP_STATE  *state
+);
+
+/*******************************************************************************
+* gprtSetEgressMode
+*
+* DESCRIPTION:
+*       This routine set the egress mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the egress mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetEgressMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT        port,
+    IN GT_EGRESS_MODE  mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetEgressMode
+*
+* DESCRIPTION:
+*       This routine get the egress mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - the egress mode.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetEgressMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    OUT GT_EGRESS_MODE  *mode
+);
+
+
+
+/*******************************************************************************
+* gprtSetVlanTunnel
+*
+* DESCRIPTION:
+*       This routine sets the vlan tunnel mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the vlan tunnel mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetVlanTunnel
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN MV_BOOL  mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetVlanTunnel
+*
+* DESCRIPTION:
+*       This routine get the vlan tunnel mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - the vlan tunnel mode..
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetVlanTunnel
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *mode
+);
+
+
+/*******************************************************************************
+* gprtSetIGMPSnoop
+*
+* DESCRIPTION:
+*         This routine set the IGMP Snoop. When set to one and this port receives
+*        IGMP frame, the frame is switched to the CPU port, overriding all other
+*        switching decisions, with exception for CPU's Trailer.
+*        CPU port is determined by the Ingress Mode bits. A port is considered
+*        the CPU port if its Ingress Mode are either GT_TRAILER_INGRESS or
+*        GT_CPUPORT_INGRESS.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for IGMP Snoop or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetIGMPSnoop
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN MV_BOOL  mode
+);
+
+/*******************************************************************************
+* gprtGetIGMPSnoop
+*
+* DESCRIPTION:
+*        This routine get the IGMP Snoop mode.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: IGMP Snoop enabled
+*              GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetIGMPSnoop
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *mode
+);
+
+/* the following two APIs are added to support clippership */
+
+/*******************************************************************************
+* gprtSetHeaderMode
+*
+* DESCRIPTION:
+*        This routine set ingress and egress header mode of a switch port.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for header mode  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetHeaderMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN MV_BOOL  mode
+);
+
+/*******************************************************************************
+* gprtGetHeaderMode
+*
+* DESCRIPTION:
+*        This routine gets ingress and egress header mode of a switch port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: header mode enabled
+*              GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetHeaderMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *mode
+);
+
+
+/*******************************************************************************
+* gprtSetProtectedMode
+*
+* DESCRIPTION:
+*        This routine set protected mode of a switch port.
+*        When this mode is set to GT_TRUE, frames are allowed to egress port
+*        defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+*        by the port's VLANTable if 802.1Q is enabled on the port. Both must
+*        allow the frame to Egress.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for protected mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetProtectedMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL      mode
+);
+
+/*******************************************************************************
+* gprtGetProtectedMode
+*
+* DESCRIPTION:
+*        This routine gets protected mode of a switch port.
+*        When this mode is set to GT_TRUE, frames are allowed to egress port
+*        defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+*        by the port's VLANTable if 802.1Q is enabled on the port. Both must
+*        allow the frame to Egress.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: header mode enabled
+*              GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetProtectedMode
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetForwardUnknown
+*
+* DESCRIPTION:
+*        This routine set Forward Unknown mode of a switch port.
+*        When this mode is set to GT_TRUE, normal switch operation occurs.
+*        When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+*        will not egress out this port.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for protected mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetForwardUnknown
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT    port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetForwardUnknown
+*
+* DESCRIPTION:
+*        This routine gets Forward Unknown mode of a switch port.
+*        When this mode is set to GT_TRUE, normal switch operation occurs.
+*        When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+*        will not egress out this port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: header mode enabled
+*                GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetForwardUnknown
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtGetSwitchReg
+*
+* DESCRIPTION:
+*       This routine reads Switch Port Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetSwitchReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  MV_U32         regAddr,
+    OUT MV_U16         *data
+);
+
+/*******************************************************************************
+* gprtSetSwitchReg
+*
+* DESCRIPTION:
+*       This routine writes Switch Port Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetSwitchReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  MV_U32         regAddr,
+    IN  MV_U16         data
+);
+
+
+/*******************************************************************************
+* gprtGetGlobalReg
+*
+* DESCRIPTION:
+*       This routine reads Switch Global Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetGlobalReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  MV_U32         regAddr,
+    OUT MV_U16         *data
+);
+
+/*******************************************************************************
+* gprtSetGlobalReg
+*
+* DESCRIPTION:
+*       This routine writes Switch Global Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetGlobalReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  MV_U32         regAddr,
+    IN  MV_U16         data
+);
+
+/*******************************************************************************
+* gvlnSetPortVlanPortMask
+*
+* DESCRIPTION:
+*       This routine sets the port VLAN group port membership list.
+*
+* INPUTS:
+*       port        - logical port number to set.
+*       portMask    - bitmap for port[0..6]
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_FAIL             - on error
+*       MV_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvlnSetPortVlanPortMask
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN MV_U16    portMask
+);
+
+
+/*******************************************************************************
+* gvlnSetPortVlanPorts
+*
+* DESCRIPTION:
+*       This routine sets the port VLAN group port membership list.
+*
+* INPUTS:
+*       port        - logical port number to set.
+*       memPorts    - array of logical ports.
+*       memPortsLen - number of members in memPorts array
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvlnSetPortVlanPorts
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_LPORT memPorts[],
+    IN MV_U8    memPortsLen
+);
+
+
+
+/*******************************************************************************
+* gvlnGetPortVlanPorts
+*
+* DESCRIPTION:
+*       This routine gets the port VLAN group port membership list.
+*
+* INPUTS:
+*       port        - logical port number to set.
+*
+* OUTPUTS:
+*       memPorts    - array of logical ports.
+*       memPortsLen - number of members in memPorts array
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvlnGetPortVlanPorts
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_LPORT memPorts[],
+    OUT MV_U8    *memPortsLen
+);
+
+
+
+
+/*******************************************************************************
+* gvlnSetPortUserPriLsb
+*
+* DESCRIPTION:
+*       This routine Set the user priority (VPT) LSB bit, to be added to the
+*       user priority on the egress.
+*
+* INPUTS:
+*       port       - logical port number to set.
+*       userPriLsb - GT_TRUE for 1, GT_FALSE for 0.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvlnSetPortUserPriLsb
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN MV_BOOL  userPriLsb
+);
+
+
+
+/*******************************************************************************
+* gvlnGetPortUserPriLsb
+*
+* DESCRIPTION:
+*       This routine gets the user priority (VPT) LSB bit.
+*
+* INPUTS:
+*       port       - logical port number to set.
+*
+* OUTPUTS:
+*       userPriLsb - GT_TRUE for 1, GT_FALSE for 0.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvlnGetPortUserPriLsb
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL     *userPriLsb
+);
+
+
+/*******************************************************************************
+* gvlnSetPortVid
+*
+* DESCRIPTION:
+*       This routine Set the port default vlan id.
+*
+* INPUTS:
+*       port - logical port number to set.
+*       vid  - the port vlan id.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvlnSetPortVid
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN MV_U16   vid
+);
+
+
+/*******************************************************************************
+* gvlnGetPortVid
+*
+* DESCRIPTION:
+*       This routine Get the port default vlan id.
+*
+* INPUTS:
+*       port - logical port number to set.
+*
+* OUTPUTS:
+*       vid  - the port vlan id.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvlnGetPortVid
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_U16   *vid
+);
+
+/*******************************************************************************
+* gvlnSetPortVlanDBNum
+*
+* DESCRIPTION:
+*       This routine sets the port VLAN database number (DBNum).
+*
+* INPUTS:
+*       port    - logical port number to set.
+*       DBNum     - database number for this port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:IN GT_INGRESS_MODE mode
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvlnSetPortVlanDBNum
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN MV_U32   DBNum
+);
+
+
+/*******************************************************************************
+* gvlnGetPortVlanDBNum
+*
+* DESCRIPTION:IN GT_INGRESS_MODE mode
+*       This routine gets the port VLAN database number (DBNum).
+*
+* INPUTS:
+*       port     - logical port number to get.
+*
+* OUTPUTS:
+*       DBNum     - database number for this port
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvlnGetPortVlanDBNum
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_U32    *DBNum
+);
+
+/********************************************************************
+* gvlnSetPortVlanDot1qMode
+*
+* DESCRIPTION:
+*       This routine sets the port 802.1q mode (11:10)
+*
+* INPUTS:
+*       port    - logical port number to set.
+*       mode     - 802.1q mode for this port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:IN GT_INGRESS_MODE mode
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvlnSetPortVlanDot1qMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT     port,
+    IN GT_DOT1Q_MODE    mode
+);
+
+/*******************************************************************************
+* gvlnGetPortVlanDot1qMode
+*
+* DESCRIPTION:
+*       This routine gets the port 802.1q mode (bit 11:10).
+*
+* INPUTS:
+*       port     - logical port number to get.
+*
+* OUTPUTS:
+*       mode     - 802.1q mode for this port
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvlnGetPortVlanDot1qMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_DOT1Q_MODE    *mode
+);
+
+
+/********************************************************************
+* gvlnSetPortVlanForceDefaultVID
+*
+* DESCRIPTION:
+*       This routine sets the port 802.1q mode (11:10)
+*
+* INPUTS:
+*       port    - logical port number to set.
+*       mode    - GT_TRUE, force to use default VID
+*                 GT_FAULSE, otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvlnSetPortVlanForceDefaultVID
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL      mode
+);
+
+/*******************************************************************************
+* gvlnGetPortVlanForceDefaultVID
+*
+* DESCRIPTION:
+*       This routine gets the port mode for ForceDefaultVID (bit 12).
+*
+* INPUTS:
+*       port     - logical port number to get.
+*
+* OUTPUTS:
+*       mode     - ForceDefaultVID mode for this port
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvlnGetPortVlanForceDefaultVID
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT      port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* eventSetActive
+*
+* DESCRIPTION:
+*       This routine enables/disables the receive of an hardware driven event.
+*
+* INPUTS:
+*       eventType - the event type. any combination of the folowing:
+*           GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,
+*           GT_ATU_DONE, GT_PHY_INTERRUPT, GT_EE_INTERRUPT, and GT_DEVICE_INT
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Each switch device has its own set of event Types. Please refer to the
+*        device datasheet for the list of event types that the device supports.
+*
+*******************************************************************************/
+MV_STATUS eventSetActive
+(
+    IN GT_QD_DEV     *dev,
+    IN MV_U32         eventType
+);
+
+/*******************************************************************************
+* eventGetIntStatus
+*
+* DESCRIPTION:
+*       This routine reads an hardware driven event status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       intCause -  It provides the source of interrupt of the following:
+*                GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,
+*                GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT.
+*                For Gigabit Switch, GT_ATU_FULL is replaced with GT_ATU_FULL and
+*                GT_PHY_INTERRUPT is not supported.
+*                GT_DEVICE_INT may not be available on the devices, so please refer
+*                to the datasheet for details.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS eventGetIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U16        *intCause
+);
+
+/*******************************************************************************
+* gvtuGetIntStatus
+*
+* DESCRIPTION:
+*         Check to see if a specific type of VTU interrupt occured
+*
+* INPUTS:
+*       intType - the type of interrupt which causes an interrupt.
+*            any combination of
+*            GT_MEMEBER_VIOLATION,
+*            GT_MISS_VIOLATION,
+*            GT_FULL_VIOLATION
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK   - on success
+*         GT_FAIL - on error
+*
+* COMMENTS:
+*         FULL_VIOLATION is only for Fast Ethernet Switch (not for Gigabit Switch).
+*
+*******************************************************************************/
+
+MV_STATUS gvtuGetIntStatus
+(
+    IN  GT_QD_DEV             *dev,
+    OUT GT_VTU_INT_STATUS     *vtuIntStatus
+);
+
+/*******************************************************************************
+* gvtuGetEntryCount
+*
+* DESCRIPTION:
+*       Gets the current number of entries in the VTU table
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       numEntries - number of VTU entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - vlan does not exist.
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvtuGetEntryCount
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U32         *numEntries
+);
+
+/*******************************************************************************
+* gvtuGetEntryFirst
+*
+* DESCRIPTION:
+*       Gets first lexicographic entry from the VTU.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       vtuEntry - match VTU entry.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - table is empty.
+*
+* COMMENTS:
+*       Search starts from vid of all one's
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvtuGetEntryFirst
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_VTU_ENTRY    *vtuEntry
+);
+
+/*******************************************************************************
+* gvtuGetEntryNext
+*
+* DESCRIPTION:
+*       Gets next lexicographic VTU entry from the specified VID.
+*
+* INPUTS:
+*       vtuEntry - the VID to start the search.
+*
+* OUTPUTS:
+*       vtuEntry - match VTU  entry.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*       Search starts from the VID specified by the user.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvtuGetEntryNext
+(
+    IN  GT_QD_DEV         *dev,
+    INOUT GT_VTU_ENTRY  *vtuEntry
+);
+
+/*******************************************************************************
+* gvtuFindVidEntry
+*
+* DESCRIPTION:
+*       Find VTU entry for a specific VID, it will return the entry, if found,
+*       along with its associated data
+*
+* INPUTS:
+*       vtuEntry - contains the VID to search for.
+*
+* OUTPUTS:
+*       found    - GT_TRUE, if the appropriate entry exists.
+*       vtuEntry - the entry parameters.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvtuFindVidEntry
+(
+    IN GT_QD_DEV         *dev,
+    INOUT GT_VTU_ENTRY  *vtuEntry,
+    OUT MV_BOOL         *found
+);
+
+/*******************************************************************************
+* gvtuFlush
+*
+* DESCRIPTION:
+*       This routine removes all entries from VTU Table.
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvtuFlush
+(
+    IN GT_QD_DEV *dev
+);
+
+/*******************************************************************************
+* gvtuAddEntry
+*
+* DESCRIPTION:
+*       Creates the new entry in VTU table based on user input.
+*
+* INPUTS:
+*       vtuEntry    - vtu entry to insert to the VTU.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK             - on success
+*       GT_FAIL           - on error
+*       GT_FULL              - vtu table is full
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvtuAddEntry
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_VTU_ENTRY *vtuEntry
+);
+
+/*******************************************************************************
+* gvtuDelEntry
+*
+* DESCRIPTION:
+*       Deletes VTU entry specified by user.
+*
+* INPUTS:
+*       vtuEntry - the VTU entry to be deleted
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvtuDelEntry
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_VTU_ENTRY *vtuEntry
+);
+
+/* gtPhyCtrl.c */
+
+/*******************************************************************************
+* gprtPhyReset
+*
+* DESCRIPTION:
+*        This routine preforms PHY reset.
+*        After reset, phy will be in Autonegotiation mode.
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+* COMMENTS:
+*         data sheet register 0.15 - Reset
+*         data sheet register 0.13 - Speed
+*         data sheet register 0.12 - Autonegotiation
+*         data sheet register 0.8  - Duplex Mode
+*
+*******************************************************************************/
+
+MV_STATUS gprtPhyReset
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_LPORT     port
+);
+
+
+/*******************************************************************************
+* gprtSetPortLoopback
+*
+* DESCRIPTION:
+* Enable/Disable Internal Port Loopback.
+* For 10/100 Fast Ethernet PHY, speed of Loopback is determined as follows:
+*   If Auto-Negotiation is enabled, this routine disables Auto-Negotiation and
+*   forces speed to be 10Mbps.
+*   If Auto-Negotiation is disabled, the forced speed is used.
+*   Disabling Loopback simply clears bit 14 of control register(0.14). Therefore,
+*   it is recommended to call gprtSetPortAutoMode for PHY configuration after
+*   Loopback test.
+* For 10/100/1000 Gigagbit Ethernet PHY, speed of Loopback is determined as follows:
+*   If Auto-Negotiation is enabled and Link is active, the current speed is used.
+*   If Auto-Negotiation is disabled, the forced speed is used.
+*   All other cases, default MAC Interface speed is used. Please refer to the data
+*   sheet for the information of the default MAC Interface speed.
+*
+* INPUTS:
+*         port - logical port number
+*         enable - If GT_TRUE, enable loopback mode
+*                     If GT_FALSE, disable loopback mode
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.14 - Loop_back
+*
+*******************************************************************************/
+
+MV_STATUS gprtSetPortLoopback
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL         enable
+);
+
+
+/*******************************************************************************
+* gprtSetPortSpeed
+*
+* DESCRIPTION:
+*         Sets speed for a specific logical port. This function will keep the duplex
+*        mode and loopback mode to the previous value, but disable others, such as
+*        Autonegotiation.
+*
+* INPUTS:
+*         port  - logical port number
+*         speed - port speed.
+*                PHY_SPEED_10_MBPS for 10Mbps
+*                PHY_SPEED_100_MBPS for 100Mbps
+*                PHY_SPEED_1000_MBPS for 1000Mbps
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* data sheet register 0.13 - Speed Selection (LSB)
+* data sheet register 0.6  - Speed Selection (MSB)
+*
+*******************************************************************************/
+
+MV_STATUS gprtSetPortSpeed
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_LPORT     port,
+    IN GT_PHY_SPEED    speed
+);
+
+
+/*******************************************************************************
+* gprtPortAutoNegEnable
+*
+* DESCRIPTION:
+*         Enable/disable an Auto-Negotiation for duplex mode on specific
+*         logical port. When Autonegotiation is disabled, phy will be in 10Mbps Half
+*        Duplex mode. Enabling Autonegotiation will set 100BASE-TX Full Duplex,
+*        100BASE-TX Full Duplex, 100BASE-TX Full Duplex, and 100BASE-TX Full Duplex
+*        in AutoNegotiation Advertisement register.
+*
+* INPUTS:
+*         port - logical port number
+*         state - GT_TRUE for enable Auto-Negotiation for duplex mode,
+*                     GT_FALSE otherwise
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.12 - Auto-Negotiation Enable
+*         data sheet register 4.8, 4.7, 4.6, 4.5 - Auto-Negotiation Advertisement
+*
+*******************************************************************************/
+
+MV_STATUS gprtPortAutoNegEnable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL         state
+);
+
+
+/*******************************************************************************
+* gprtPortPowerDown
+*
+* DESCRIPTION:
+*         Enable/disable (power down) on specific logical port. When this function
+*        is called with normal operation request, phy will set to Autonegotiation
+*        mode.
+*
+* INPUTS:
+*         port    - logical port number
+*         state    -  GT_TRUE: power down
+*                     GT_FALSE: normal operation
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.11 - Power Down
+*
+*******************************************************************************/
+
+MV_STATUS gprtPortPowerDown
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN MV_BOOL        state
+);
+
+
+/*******************************************************************************
+* gprtPortRestartAutoNeg
+*
+* DESCRIPTION:
+*         Restart AutoNegotiation. If AutoNegotiation is not enabled, it'll enable
+*        it. Loopback and Power Down will be disabled by this routine.
+*
+* INPUTS:
+*         port - logical port number
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.9 - Restart Auto-Negotiation
+*
+*******************************************************************************/
+
+MV_STATUS gprtPortRestartAutoNeg
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+);
+
+
+/*******************************************************************************
+* gprtSetPortDuplexMode
+*
+* DESCRIPTION:
+*         Sets duplex mode for a specific logical port. This function will keep
+*        the speed and loopback mode to the previous value, but disable others,
+*        such as Autonegotiation.
+*
+* INPUTS:
+*         port     - logical port number
+*         dMode    - dulpex mode
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.8 - Duplex Mode
+*
+*******************************************************************************/
+
+MV_STATUS gprtSetPortDuplexMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN MV_BOOL        dMode
+);
+
+
+/*******************************************************************************
+* gprtSetPortAutoMode
+*
+* DESCRIPTION:
+*         This routine sets up the port with given Auto Mode.
+*        Supported mode is as follows:
+*        - Auto for both speed and duplex.
+*        - Auto for speed only and Full duplex.
+*        - Auto for speed only and Half duplex.
+*        - Auto for duplex only and speed 1000Mbps.
+*        - Auto for duplex only and speed 100Mbps.
+*        - Auto for duplex only and speed 10Mbps.
+*        - Speed 1000Mbps and Full duplex.
+*        - Speed 1000Mbps and Half duplex.
+*        - Speed 100Mbps and Full duplex.
+*        - Speed 100Mbps and Half duplex.
+*        - Speed 10Mbps and Full duplex.
+*        - Speed 10Mbps and Half duplex.
+*
+*
+* INPUTS:
+*         port - The logical port number
+*         mode - Auto Mode to be written
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+* COMMENTS:
+*         data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement
+*         data sheet register 4.6, 4.5 Autonegotiation Advertisement for 1000BX
+*         data sheet register 9.9, 9.8 Autonegotiation Advertisement for 1000BT
+*******************************************************************************/
+
+MV_STATUS gprtSetPortAutoMode
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_LPORT     port,
+    IN GT_PHY_AUTO_MODE mode
+);
+
+/*******************************************************************************
+* gprtSetPause
+*
+* DESCRIPTION:
+*       This routine will set the pause bit in Autonegotiation Advertisement
+*        Register. And restart the autonegotiation.
+*
+* INPUTS:
+* port - The logical port number
+* state - GT_PHY_PAUSE_MODE enum value.
+*            GT_PHY_NO_PAUSE        - disable pause
+*             GT_PHY_PAUSE        - support pause
+*            GT_PHY_ASYMMETRIC_PAUSE    - support asymmetric pause
+*            GT_PHY_BOTH_PAUSE    - support both pause and asymmetric pause
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+* COMMENTS:
+* data sheet register 4.10 Autonegotiation Advertisement Register
+*******************************************************************************/
+
+MV_STATUS gprtSetPause
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_PHY_PAUSE_MODE state
+);
+
+/*******************************************************************************
+* gprtGetPhyReg
+*
+* DESCRIPTION:
+*       This routine reads Phy Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPhyReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  MV_U32         regAddr,
+    OUT MV_U16         *data
+);
+
+/*******************************************************************************
+* gprtSetPhyReg
+*
+* DESCRIPTION:
+*       This routine writes Phy Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetPhyReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  MV_U32         regAddr,
+    IN  MV_U16         data
+);
+
+
+/*******************************************************************************
+* gprtPhyIntEnable
+*
+* DESCRIPTION:
+* Enable/Disable one PHY Interrupt
+* This register determines whether the INT# pin is asserted when an interrupt
+* event occurs. When an interrupt occurs, the corresponding bit is set and
+* remains set until register 19 is read via the SMI. When interrupt enable
+* bits are not set in register 18, interrupt status bits in register 19 are
+* still set when the corresponding interrupt events occur. However, the INT#
+* is not asserted.
+*
+* INPUTS:
+* port    - logical port number
+* intType - the type of interrupt to enable/disable. any combination of
+*            GT_SPEED_CHANGED,
+*            GT_DUPLEX_CHANGED,
+*            GT_PAGE_RECEIVED,
+*            GT_AUTO_NEG_COMPLETED,
+*            GT_LINK_STATUS_CHANGED,
+*            GT_SYMBOL_ERROR,
+*            GT_FALSE_CARRIER,
+*            GT_FIFO_FLOW,
+*            GT_CROSSOVER_CHANGED,
+*            GT_POLARITY_CHANGED, and
+*            GT_JABBER
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* 88E3081 data sheet register 18
+*
+*******************************************************************************/
+
+MV_STATUS gprtPhyIntEnable
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT   port,
+IN MV_U16    intType
+);
+
+
+/*******************************************************************************
+* gprtGetPhyIntStatus
+*
+* DESCRIPTION:
+* Check to see if a specific type of  interrupt occured
+*
+* INPUTS:
+* port - logical port number
+* intType - the type of interrupt which causes an interrupt.
+*            any combination of
+*            GT_SPEED_CHANGED,
+*            GT_DUPLEX_CHANGED,
+*            GT_PAGE_RECEIVED,
+*            GT_AUTO_NEG_COMPLETED,
+*            GT_LINK_STATUS_CHANGED,
+*            GT_SYMBOL_ERROR,
+*            GT_FALSE_CARRIER,
+*            GT_FIFO_FLOW,
+*            GT_CROSSOVER_CHANGED,
+*            GT_POLARITY_CHANGED, and
+*            GT_JABBER
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* 88E3081 data sheet register 19
+*
+*******************************************************************************/
+
+MV_STATUS gprtGetPhyIntStatus
+(
+IN GT_QD_DEV *dev,
+IN  GT_LPORT port,
+OUT  MV_U16* intType
+);
+
+/*******************************************************************************
+* gprtGetPhyIntPortSummary
+*
+* DESCRIPTION:
+* Lists the ports that have active interrupts. It provides a quick way to
+* isolate the interrupt so that the MAC or switch does not have to poll the
+* interrupt status register (19) for all ports. Reading this register does not
+* de-assert the INT# pin
+*
+* INPUTS:
+* none
+*
+* OUTPUTS:
+* MV_U8 *intPortMask - bit Mask with the bits set for the corresponding
+* phys with active interrupt. E.g., the bit number 0 and 2 are set when
+* port number 0 and 2 have active interrupt
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* 88E3081 data sheet register 20
+*
+*******************************************************************************/
+
+MV_STATUS gprtGetPhyIntPortSummary
+(
+IN GT_QD_DEV *dev,
+OUT MV_U16 *intPortMask
+);
+
+
+
+/*******************************************************************************
+* gprtSetForceFc
+*
+* DESCRIPTION:
+*       This routine set the force flow control state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetForceFc
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN MV_BOOL  force
+);
+
+
+
+/*******************************************************************************
+* gprtGetForceFc
+*
+* DESCRIPTION:
+*       This routine get the force flow control state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetForceFc
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *force
+);
+
+
+
+/*******************************************************************************
+* gprtSetTrailerMode
+*
+* DESCRIPTION:
+*       This routine set the egress trailer mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for add trailer or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetTrailerMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN MV_BOOL  mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetTrailerMode
+*
+* DESCRIPTION:
+*       This routine get the egress trailer mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for add trailer or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetTrailerMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *mode
+);
+
+
+
+/*******************************************************************************
+* gprtSetIngressMode
+*
+* DESCRIPTION:
+*       This routine set the ingress mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the ingress mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetIngressMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT        port,
+    IN GT_INGRESS_MODE mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetIngressMode
+*
+* DESCRIPTION:
+*       This routine get the ingress mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - the ingress mode.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetIngressMode
+(
+    IN GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_INGRESS_MODE *mode
+);
+
+
+
+/*******************************************************************************
+* gprtSetMcRateLimit
+*
+* DESCRIPTION:
+*       This routine set the port multicast rate limit.
+*
+* INPUTS:
+*       port - the logical port number.
+*       rate - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetMcRateLimit
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT     port,
+    IN GT_MC_RATE   rate
+);
+
+
+
+/*******************************************************************************
+* gprtGetMcRateLimit
+*
+* DESCRIPTION:
+*       This routine Get the port multicast rate limit.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       rate - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetMcRateLimit
+(
+    IN GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_MC_RATE  *rate
+);
+
+
+
+/*******************************************************************************
+* gprtSetCtrMode
+*
+* DESCRIPTION:
+*       This routine sets the port counters mode of operation.
+*
+* INPUTS:
+*       mode  - the counter mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetCtrMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_CTR_MODE  mode
+);
+
+
+
+/*******************************************************************************
+* gprtClearAllCtr
+*
+* DESCRIPTION:
+*       This routine clears all port counters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtClearAllCtr
+(
+    IN GT_QD_DEV *dev
+);
+
+
+/*******************************************************************************
+* gprtGetPortCtr
+*
+* DESCRIPTION:
+*       This routine gets the port counters.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       ctr - the counters value.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPortCtr
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    OUT GT_PORT_STAT    *ctr
+);
+
+
+
+
+/*******************************************************************************
+* gprtGetPartnerLinkPause
+*
+* DESCRIPTION:
+*       This routine retrives the link partner pause state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for enable  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPartnerLinkPause
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *state
+);
+
+
+
+/*******************************************************************************
+* gprtGetSelfLinkPause
+*
+* DESCRIPTION:
+*       This routine retrives the link pause state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for enable  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetSelfLinkPause
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *state
+);
+
+
+
+/*******************************************************************************
+* gprtGetResolve
+*
+* DESCRIPTION:
+*       This routine retrives the resolve state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for Done  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetResolve
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *state
+);
+
+
+
+/*******************************************************************************
+* gprtGetLinkState
+*
+* DESCRIPTION:
+*       This routine retrives the link state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for Up  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetLinkState
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *state
+);
+
+
+
+/*******************************************************************************
+* gprtGetPortMode
+*
+* DESCRIPTION:
+*       This routine retrives the port mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for MII  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPortMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetPhyMode
+*
+* DESCRIPTION:
+*       This routine retrives the PHY mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for MII PHY  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPhyMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetDuplex
+*
+* DESCRIPTION:
+*       This routine retrives the port duplex mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for Full  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetDuplex
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetSpeed
+*
+* DESCRIPTION:
+*       This routine retrives the port speed.
+*
+* INPUTS:
+*       speed - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for 100Mb/s  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetSpeed
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *speed
+);
+
+/*******************************************************************************
+* gprtSetDuplex
+*
+* DESCRIPTION:
+*       This routine sets the duplex mode of MII/SNI/RMII ports.
+*
+* INPUTS:
+*       port -     the logical port number.
+*                (for FullSail, it will be port 2, and for ClipperShip,
+*                it could be either port 5 or port 6.)
+*       mode -  GT_TRUE for Full Duplex,
+*                GT_FALSE for Half Duplex.
+*
+* OUTPUTS: None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetDuplex
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    IN  MV_BOOL  mode
+);
+
+
+/*******************************************************************************
+* gqosSetPortDefaultTc
+*
+* DESCRIPTION:
+*       Sets the default traffic class for a specific port.
+*
+* INPUTS:
+*       port      - logical port number
+*       trafClass - default traffic class of a port.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gcosSetPortDefaultTc
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN MV_U8    trafClass
+);
+
+
+/*******************************************************************************
+* gcosGetPortDefaultTc
+*
+* DESCRIPTION:
+*       Gets the default traffic class for a specific port.
+*
+* INPUTS:
+*       port      - logical port number
+*
+* OUTPUTS:
+*       trafClass - default traffic class of a port.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gcosGetPortDefaultTc
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    OUT MV_U8     *trafClass
+);
+
+
+/*******************************************************************************
+* gqosSetPrioMapRule
+*
+* DESCRIPTION:
+*       This routine sets priority mapping rule.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosSetPrioMapRule
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN MV_BOOL  mode
+);
+
+
+
+/*******************************************************************************
+* gqosGetPrioMapRule
+*
+* DESCRIPTION:
+*       This routine get the priority mapping rule.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosGetPrioMapRule
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *mode
+);
+
+
+
+/*******************************************************************************
+* gqosIpPrioMapEn
+*
+* DESCRIPTION:
+*       This routine enables the IP priority mapping.
+*
+* INPUTS:
+*       port - the logical port number.
+*       en   - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosIpPrioMapEn
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN MV_BOOL  en
+);
+
+
+
+/*******************************************************************************
+* gqosGetIpPrioMapEn
+*
+* DESCRIPTION:
+*       This routine return the IP priority mapping state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       en    - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosGetIpPrioMapEn
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *en
+);
+
+
+
+/*******************************************************************************
+* gqosUserPrioMapEn
+*
+* DESCRIPTION:
+*       This routine enables the user priority mapping.
+*
+* INPUTS:
+*       port - the logical port number.
+*       en   - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosUserPrioMapEn
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN MV_BOOL  en
+);
+
+
+
+/*******************************************************************************
+* gqosGetUserPrioMapEn
+*
+* DESCRIPTION:
+*       This routine return the user priority mapping state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       en    - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosGetUserPrioMapEn
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *en
+);
+
+
+
+/*******************************************************************************
+* gcosGetUserPrio2Tc
+*
+* DESCRIPTION:
+*       Gets the traffic class number for a specific 802.1p user priority.
+*
+* INPUTS:
+*       userPrior - user priority
+*
+* OUTPUTS:
+*       trClass - The Traffic Class the received frame is assigned.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*       Table - UserPrio2Tc
+*
+*******************************************************************************/
+MV_STATUS gcosGetUserPrio2Tc
+(
+    IN GT_QD_DEV *dev,
+    IN  MV_U8    userPrior,
+    OUT MV_U8   *trClass
+);
+
+
+/*******************************************************************************
+* gcosSetUserPrio2Tc
+*
+* DESCRIPTION:
+*       Sets the traffic class number for a specific 802.1p user priority.
+*
+* INPUTS:
+*       userPrior - user priority of a port.
+*       trClass   - the Traffic Class the received frame is assigned.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*       Table - UserPrio2Tc
+*
+*******************************************************************************/
+MV_STATUS gcosSetUserPrio2Tc
+(
+    IN GT_QD_DEV *dev,
+    IN MV_U8    userPrior,
+    IN MV_U8    trClass
+);
+
+
+/*******************************************************************************
+* gcosGetDscp2Tc
+*
+* DESCRIPTION:
+*       This routine retrieves the traffic class assigned for a specific
+*       IPv4 Dscp.
+*
+* INPUTS:
+*       dscp    - the IPv4 frame dscp to query.
+*
+* OUTPUTS:
+*       trClass - The Traffic Class the received frame is assigned.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*       Table - UserPrio2Tc
+*
+*******************************************************************************/
+MV_STATUS gcosGetDscp2Tc
+(
+    IN GT_QD_DEV *dev,
+    IN  MV_U8   dscp,
+    OUT MV_U8   *trClass
+);
+
+
+/*******************************************************************************
+* gcosSetDscp2Tc
+*
+* DESCRIPTION:
+*       This routine sets the traffic class assigned for a specific
+*       IPv4 Dscp.
+*
+* INPUTS:
+*       dscp    - the IPv4 frame dscp to map.
+*       trClass - the Traffic Class the received frame is assigned.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*       Table - UserPrio2Tc
+*
+*******************************************************************************/
+MV_STATUS gcosSetDscp2Tc
+(
+    IN GT_QD_DEV *dev,
+    IN MV_U8    dscp,
+    IN MV_U8    trClass
+);
+
+
+/*******************************************************************************
+* qdLoadDriver
+*
+* DESCRIPTION:
+*       QuarterDeck Driver Initialization Routine.
+*       This is the first routine that needs be called by system software.
+*       It takes sysCfg from system software, and retures a pointer (*dev)
+*       to a data structure which includes infomation related to this QuarterDeck
+*       device. This pointer (*dev) is then used for all the API functions.
+*
+* INPUTS:
+*       sysCfg      - Holds system configuration parameters.
+*
+* OUTPUTS:
+*       dev         - Holds general system information.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_ALREADY_EXIST    - if device already started
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*     qdUnloadDriver is provided when the driver is not to be used anymore.
+*
+*******************************************************************************/
+MV_STATUS qdLoadDriver
+(
+    IN  GT_SYS_CONFIG   *sysCfg,
+    OUT GT_QD_DEV    *dev
+);
+
+
+/*******************************************************************************
+* qdUnloadDriver
+*
+* DESCRIPTION:
+*       This function unloads the QuaterDeck Driver.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       1.  This function should be called only after successful execution of
+*           qdLoadDriver().
+*
+*******************************************************************************/
+MV_STATUS qdUnloadDriver
+(
+    IN GT_QD_DEV* dev
+);
+
+
+/*******************************************************************************
+* sysEnable
+*
+* DESCRIPTION:
+*       This function enables the system for full operation.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS sysEnable
+(
+    IN GT_QD_DEV* dev
+);
+
+
+/*******************************************************************************
+* gsysSwReset
+*
+* DESCRIPTION:
+*       This routine preforms switch software reset.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSwReset
+(
+    IN GT_QD_DEV* dev
+);
+
+
+/*******************************************************************************
+* gsysSetDiscardExcessive
+*
+* DESCRIPTION:
+*       This routine set the Discard Excessive state.
+*
+* INPUTS:
+*       en - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetDiscardExcessive
+(
+    IN GT_QD_DEV* dev,
+    IN MV_BOOL en
+);
+
+
+
+/*******************************************************************************
+* gsysGetDiscardExcessive
+*
+* DESCRIPTION:
+*       This routine get the Discard Excessive state.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetDiscardExcessive
+(
+    IN GT_QD_DEV* dev,
+    IN MV_BOOL *en
+);
+
+
+
+/*******************************************************************************
+* gsysSetSchedulingMode
+*
+* DESCRIPTION:
+*       This routine set the Scheduling Mode.
+*
+* INPUTS:
+*       mode - GT_TRUE wrr, GT_FALSE strict.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetSchedulingMode
+(
+    IN GT_QD_DEV* dev,
+    IN MV_BOOL mode
+);
+
+
+
+/*******************************************************************************
+* gsysGetSchedulingMode
+*
+* DESCRIPTION:
+*       This routine get the Scheduling Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE wrr, GT_FALSE strict.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetSchedulingMode
+(
+    IN GT_QD_DEV *dev,
+    OUT MV_BOOL *mode
+);
+
+
+
+/*******************************************************************************
+* gsysSetMaxFrameSize
+*
+* DESCRIPTION:
+*       This routine Set the max frame size allowed.
+*
+* INPUTS:
+*       mode - GT_TRUE max size 1522, GT_FALSE max size 1535.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetMaxFrameSize
+(
+    IN GT_QD_DEV* dev,
+    IN MV_BOOL mode
+);
+
+
+
+/*******************************************************************************
+* gsysGetMaxFrameSize
+*
+* DESCRIPTION:
+*       This routine Get the max frame size allowed.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE max size 1522, GT_FALSE max size 1535.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetMaxFrameSize
+(
+    IN GT_QD_DEV *dev,
+    OUT MV_BOOL *mode
+);
+
+
+
+/*******************************************************************************
+* gsysReLoad
+*
+* DESCRIPTION:
+*       This routine cause to the switch to reload the EEPROM.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysReLoad
+(
+    IN GT_QD_DEV* dev
+);
+
+
+/*******************************************************************************
+* gsysSetWatchDog
+*
+* DESCRIPTION:
+*       This routine Set the the watch dog mode.
+*
+* INPUTS:
+*       en - GT_TRUE enables, GT_FALSE disable.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetWatchDog
+(
+    IN GT_QD_DEV* dev,
+    IN MV_BOOL en
+);
+
+
+
+/*******************************************************************************
+* gsysGetWatchDog
+*
+* DESCRIPTION:
+*       This routine Get the the watch dog mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE enables, GT_FALSE disable.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetWatchDog
+(
+    IN GT_QD_DEV* dev,
+    OUT MV_BOOL *en
+);
+
+
+/*******************************************************************************
+* gsysSetDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine sets the full duplex pause src Mac Address.
+*
+* INPUTS:
+*       mac - The Mac address to be set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetDuplexPauseMac
+(
+    IN GT_QD_DEV* dev,
+    IN MV_U8 *mac
+);
+
+
+/*******************************************************************************
+* gsysGetDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine Gets the full duplex pause src Mac Address.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mac - the Mac address.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetDuplexPauseMac
+(
+    IN GT_QD_DEV* dev,
+    OUT MV_U8 *mac
+);
+
+
+
+/*******************************************************************************
+* gsysSetPerPortDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine sets whether the full duplex pause src Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetPerPortDuplexPauseMac
+(
+    IN GT_QD_DEV* dev,
+    IN MV_BOOL en
+);
+
+
+
+/*******************************************************************************
+* gsysGetPerPortDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine Gets whether the full duplex pause src Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetPerPortDuplexPauseMac
+(
+    IN GT_QD_DEV* dev,
+    IN MV_BOOL *en
+);
+
+/*******************************************************************************
+* gsysSetPortWakeonFrameEn
+*
+* DESCRIPTION:
+*       This routine sets port interrupt for wake on frame.
+*
+* INPUTS:
+*       portVec - combine port interrupt enable=1 disable=0:
+*                 port 0: bit0, port 1: bit1, port 2: bit2, ...
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetPortWakeonFrameEn
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U8        portVec
+);
+
+/*******************************************************************************
+* gsysGetPortWakeonFrameEnSt
+*
+* DESCRIPTION:
+*       This routine gets port interrupt status for wake on frame.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       portVec - combine port interrupt enable=1 disable=0:
+*                 port 0: bit0, port 1: bit1, port 2: bit2, ...
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetPortWakeonFrameEnSt
+(
+    IN GT_QD_DEV    *dev,
+    OUT MV_U8       *portVec
+);
+
+/*******************************************************************************
+* gsysGetPortWakeonFrameEn
+*
+* DESCRIPTION:
+*       This routine gets port interrupt status for wake on frame.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       portVec - combine port interrupt enable=1 disable=0:
+*                 port 0: bit0, port 1: bit1, port 2: bit2, ...
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetPortWakeonFrameEn
+(
+    IN GT_QD_DEV    *dev,
+    OUT MV_U8       *portVec
+);
+
+/*******************************************************************************
+* gsysSetWoLMac
+*
+* DESCRIPTION:
+*       This routine sets the Wake on Lan Mac Address.
+*        MAC address should be an Unicast address.
+*        For different MAC Addresses per port operation,
+*        use gsysSetPerPortDuplexPauseMac API.
+*
+* INPUTS:
+*       mac - The Mac address to be set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetWoLMac
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U8 *mac
+);
+
+/*******************************************************************************
+* gsysGetWoLMac
+*
+* DESCRIPTION:
+*       This routine Gets the Wake on Lan Mac Address.
+*        For different MAC Addresses per port operation,
+*        use gsysGetPerPortDuplexPauseMac API.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mac - the Mac address.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetWoLMac
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U8 *mac
+);
+
+/*******************************************************************************
+* gsysSetPerPortWoLMac
+*
+* DESCRIPTION:
+*       This routine sets whether the Wake on Lan Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetPerPortWoLMac
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL      en
+);
+
+/*******************************************************************************
+* gsysGetPerPortWoLMac
+*
+* DESCRIPTION:
+*       This routine Gets whether the Wake on Lanc Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetPerPortWoLMac
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetWoLPass
+*
+* DESCRIPTION:
+*       This routine sets the Wake on Lan Password Mac Address.
+*
+* INPUTS:
+*       mac - The Mac address to be set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetWoLPass
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U8 *mac
+);
+
+/*******************************************************************************
+* gsysGetWoLPass
+*
+* DESCRIPTION:
+*       This routine Gets the Wake on Lan password Mac Address.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mac - the Mac address.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetWoLPass
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U8 *mac
+);
+
+/*******************************************************************************
+* gsysReadMiiRegister
+*
+* DESCRIPTION:
+*       This routine reads QuarterDeck Registers. Since this routine is only for
+*        Diagnostic Purpose, no error checking will be performed.
+*        User has to know exactly which phy address(0 ~ 0x1F) will be read.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysReadMiiReg
+(
+    IN GT_QD_DEV* dev,
+    IN  MV_U32    phyAddr,
+    IN  MV_U32    regAddr,
+    OUT MV_U32    *data
+);
+
+/*******************************************************************************
+* gsysWriteMiiRegister
+*
+* DESCRIPTION:
+*       This routine writes QuarterDeck Registers. Since this routine is only for
+*        Diagnostic Purpose, no error checking will be performed.
+*        User has to know exactly which phy address(0 ~ 0x1F) will be read.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*       data    - data to be written.
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysWriteMiiReg
+(
+    IN GT_QD_DEV* dev,
+    IN  MV_U32    phyAddr,
+    IN  MV_U32    regAddr,
+    IN  MV_U16    data
+);
+
+#ifdef GT_RMGMT_ACCESS
+/*******************************************************************************
+* gsysAccessMultiRegs
+*
+* DESCRIPTION:
+*       This function accesses switch's registers.
+*
+* INPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*     HW_DEV_RW_REG:
+*     cmd - HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1
+*     addr - SMI Address
+*     reg  - Register offset
+*     data - INPUT,OUTPUT:Value in the Register or Bit number
+*
+* OUTPUTS:
+*   regList
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysAccessMultiRegs
+(
+    IN  GT_QD_DEV    *dev,
+    INOUT HW_DEV_REG_ACCESS *regList
+);
+#endif
+
+/*******************************************************************************
+* gsysGetSW_Mode
+*
+* DESCRIPTION:
+*       This routine get the Switch mode. These two bits returen
+*       the current value of the SW_MODE[1:0] pins.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*         This feature is for both clippership and fullsail
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetSW_Mode
+(
+    IN GT_QD_DEV* dev,
+    IN GT_SW_MODE *mode
+);
+
+/*******************************************************************************
+* gsysGetInitReady
+*
+* DESCRIPTION:
+*       This routine get the InitReady bit. This bit is set to a one when the ATU,
+*       the Queue Controller and the Statistics Controller are done with their
+*       initialization and are ready to accept frames.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: switch is ready, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*         This feature is for both clippership and fullsail
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetInitReady
+(
+    IN GT_QD_DEV* dev,
+    IN MV_BOOL *mode
+);
+
+
+/*******************************************************************************
+* gstatsFlushAll
+*
+* DESCRIPTION:
+*       Flush All RMON counters for all ports.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gstatsFlushAll
+(
+    IN GT_QD_DEV* dev
+);
+
+/*******************************************************************************
+* gstatsFlushPort
+*
+* DESCRIPTION:
+*       Flush All RMON counters for a given port.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gstatsFlushPort
+(
+    IN GT_QD_DEV* dev,
+    IN GT_LPORT    port
+);
+
+/*******************************************************************************
+* gstatsGetPortCounter
+*
+* DESCRIPTION:
+*        This routine gets a specific counter of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        None
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gstatsGetPortCounter
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS    counter,
+    OUT MV_U32            *statsData
+);
+
+/*******************************************************************************
+* gstatsGetPortAllCounters
+*
+* DESCRIPTION:
+*       This routine gets all RMON counters of the given port
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gstatsGetPortAllCounters
+(
+    IN  GT_QD_DEV* dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET    *statsCounterSet
+);
+
+
+/*******************************************************************************
+* grcSetLimitMode
+*
+* DESCRIPTION:
+*       This routine sets the port's rate control ingress limit mode.
+*
+* INPUTS:
+*       port    - logical port number.
+*       mode     - rate control ingress limit mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*******************************************************************************/
+MV_STATUS grcSetLimitMode
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT          port,
+    IN GT_RATE_LIMIT_MODE    mode
+);
+
+/*******************************************************************************
+* grcGetLimitMode
+*
+* DESCRIPTION:
+*       This routine gets the port's rate control ingress limit mode.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       mode     - rate control ingress limit mode.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+MV_STATUS grcGetLimitMode
+(
+    IN GT_QD_DEV* dev,
+    IN  GT_LPORT port,
+    OUT GT_RATE_LIMIT_MODE    *mode
+);
+
+/*******************************************************************************
+* grcSetPri3Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 3 frames.
+*       Priority 3 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 3 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri2Rate
+*              GT_TRUE:  use twice the rate as Pri2Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*******************************************************************************/
+MV_STATUS grcSetPri3Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT port,
+    IN MV_BOOL  mode
+);
+
+/*******************************************************************************
+* grcGetPri3Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 3 frames.
+*       Priority 3 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - the priority 3 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri2Rate
+*              GT_TRUE:  use twice the rate as Pri2Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+MV_STATUS grcGetPri3Rate
+(
+    IN GT_QD_DEV* dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *mode
+);
+
+/*******************************************************************************
+* grcSetPri2Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 2 frames.
+*       Priority 2 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 2 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri1Rate
+*              GT_TRUE:  use twice the rate as Pri1Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*******************************************************************************/
+MV_STATUS grcSetPri2Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT port,
+    IN MV_BOOL  mode
+);
+
+/*******************************************************************************
+* grcGetPri2Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 2 frames.
+*       Priority 2 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - the priority 2 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri1Rate
+*              GT_TRUE:  use twice the rate as Pri1Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+MV_STATUS grcGetPri2Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *mode
+);
+
+/*******************************************************************************
+* grcSetPri1Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 1 frames.
+*       Priority 1 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 1 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri0Rate
+*              GT_TRUE:  use twice the rate as Pri0Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*******************************************************************************/
+MV_STATUS grcSetPri1Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT port,
+    IN MV_BOOL  mode
+);
+
+/*******************************************************************************
+* grcGetPri1Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 1 frames.
+*       Priority 1 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - the priority 1 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri0Rate
+*              GT_TRUE:  use twice the rate as Pri0Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+MV_STATUS grcGetPri1Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *mode
+);
+
+/*******************************************************************************
+* grcSetPri0Rate
+*
+* DESCRIPTION:
+*       This routine sets the port's ingress data limit for priority 0 frames.
+*
+* INPUTS:
+*       port    - logical port number.
+*       rate    - ingress data rate limit for priority 0 frames. These frames
+*             will be discarded after the ingress rate selected is reached
+*             or exceeded.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+MV_STATUS grcSetPri0Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT        port,
+    IN GT_PRI0_RATE    rate
+);
+
+/*******************************************************************************
+* grcGetPri0Rate
+*
+* DESCRIPTION:
+*       This routine gets the port's ingress data limit for priority 0 frames.
+*
+* INPUTS:
+*       port    - logical port number to set.
+*
+* OUTPUTS:
+*       rate    - ingress data rate limit for priority 0 frames. These frames
+*             will be discarded after the ingress rate selected is reached
+*             or exceeded.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+MV_STATUS grcGetPri0Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN  GT_LPORT port,
+    OUT GT_PRI0_RATE    *rate
+);
+
+/*******************************************************************************
+* grcSetBytesCount
+*
+* DESCRIPTION:
+*       This routine sets the byets to count for limiting needs to be determined
+*
+* INPUTS:
+*       port      - logical port number to set.
+*        limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+*                GT_FALSE: otherwise
+*        countIFG  - GT_TRUE: To count IFG bytes
+*                GT_FALSE: otherwise
+*        countPre  - GT_TRUE: To count Preamble bytes
+*                GT_FALSE: otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+MV_STATUS grcSetBytesCount
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT            port,
+    IN MV_BOOL         limitMGMT,
+    IN MV_BOOL         countIFG,
+    IN MV_BOOL         countPre
+);
+
+/*******************************************************************************
+* grcGetBytesCount
+*
+* DESCRIPTION:
+*       This routine gets the byets to count for limiting needs to be determined
+*
+* INPUTS:
+*       port    - logical port number
+*
+* OUTPUTS:
+*        limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+*                GT_FALSE: otherwise
+*        countIFG  - GT_TRUE: To count IFG bytes
+*                GT_FALSE: otherwise
+*        countPre  - GT_TRUE: To count Preamble bytes
+*                GT_FALSE: otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+MV_STATUS grcGetBytesCount
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT            port,
+    IN MV_BOOL         *limitMGMT,
+    IN MV_BOOL         *countIFG,
+    IN MV_BOOL         *countPre
+);
+
+/*******************************************************************************
+* grcSetEgressRate
+*
+* DESCRIPTION:
+*       This routine sets the port's egress data limit.
+*
+*
+* INPUTS:
+*       port      - logical port number.
+*       rateType  - egress data rate limit (GT_ERATE_TYPE union type).
+*                    union type is used to support multiple devices with the
+*                    different formats of egress rate.
+*                    GT_ERATE_TYPE has the following fields:
+*                        definedRate - GT_EGRESS_RATE enum type should used for the
+*                            following devices:
+*                            88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183,
+*                            88E6093, 88E6095, 88E6185, 88E6108, 88E6065, 88E6061,
+*                            and their variations
+*                        kbRate - rate in kbps that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with the GT_PIRL_ELIMIT_MODE of
+*                                GT_PIRL_ELIMIT_LAYER1,
+*                                GT_PIRL_ELIMIT_LAYER2, or
+*                                GT_PIRL_ELIMIT_LAYER3 (see grcSetELimitMode)
+*                            64kbps ~ 1Mbps    : increments of 64kbps,
+*                            1Mbps ~ 100Mbps   : increments of 1Mbps, and
+*                            100Mbps ~ 1000Mbps: increments of 10Mbps
+*                            Therefore, the valid values are:
+*                                64, 128, 192, 256, 320, 384,..., 960,
+*                                1000, 2000, 3000, 4000, ..., 100000,
+*                                110000, 120000, 130000, ..., 1000000.
+*                        fRate - frame per second that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with GT_PIRL_ELIMIT_MODE of
+*                                GT_PIRL_ELIMIT_FRAME
+*                            Valid values are between 7600 and 1488000
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*            GT_16M, MV_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
+*            are supported only by Gigabit Ethernet Switch.
+*
+*******************************************************************************/
+MV_STATUS grcSetEgressRate
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_ERATE_TYPE   *rateType
+);
+
+/*******************************************************************************
+* grcGetEgressRate
+*
+* DESCRIPTION:
+*       This routine gets the port's egress data limit.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       rateType  - egress data rate limit (GT_ERATE_TYPE union type).
+*                    union type is used to support multiple devices with the
+*                    different formats of egress rate.
+*                    GT_ERATE_TYPE has the following fields:
+*                        definedRate - GT_EGRESS_RATE enum type should used for the
+*                            following devices:
+*                            88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183,
+*                            88E6093, 88E6095, 88E6185, 88E6108, 88E6065, 88E6061,
+*                            and their variations
+*                        kbRate - rate in kbps that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with the GT_PIRL_ELIMIT_MODE of
+*                                GT_PIRL_ELIMIT_LAYER1,
+*                                GT_PIRL_ELIMIT_LAYER2, or
+*                                GT_PIRL_ELIMIT_LAYER3 (see grcSetELimitMode)
+*                            64kbps ~ 1Mbps    : increments of 64kbps,
+*                            1Mbps ~ 100Mbps   : increments of 1Mbps, and
+*                            100Mbps ~ 1000Mbps: increments of 10Mbps
+*                            Therefore, the valid values are:
+*                                64, 128, 192, 256, 320, 384,..., 960,
+*                                1000, 2000, 3000, 4000, ..., 100000,
+*                                110000, 120000, 130000, ..., 1000000.
+*                        fRate - frame per second that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with GT_PIRL_ELIMIT_MODE of
+*                                GT_PIRL_ELIMIT_FRAME
+*                            Valid values are between 7600 and 1488000
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*            GT_16M, MV_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
+*            are supported only by Gigabit Ethernet Switch.
+*
+*******************************************************************************/
+MV_STATUS grcGetEgressRate
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_ERATE_TYPE  *rateType
+);
+
+
+/*******************************************************************************
+* gpavSetPAV
+*
+* DESCRIPTION:
+*       This routine sets the Port Association Vector
+*
+* INPUTS:
+*       port    - logical port number.
+*       pav     - Port Association Vector
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+MV_STATUS gpavSetPAV
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT    port,
+    IN MV_U16    pav
+);
+
+/*******************************************************************************
+* gpavGetPAV
+*
+* DESCRIPTION:
+*       This routine gets the Port Association Vector
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       pav     - Port Association Vector
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+MV_STATUS gpavGetPAV
+(
+    IN GT_QD_DEV*       dev,
+    IN  GT_LPORT port,
+    OUT MV_U16    *pav
+);
+
+/*******************************************************************************
+* gpavSetIngressMonitor
+*
+* DESCRIPTION:
+*       This routine sets the Ingress Monitor bit in the PAV.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the ingress monitor bit in the PAV
+*              GT_FALSE: Ingress Monitor enabled
+*              GT_TRUE:  Ingress Monitor disabled
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*******************************************************************************/
+MV_STATUS gpavSetIngressMonitor
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT port,
+    IN MV_BOOL  mode
+);
+
+/*******************************************************************************
+* gpavGetIngressMonitor
+*
+* DESCRIPTION:
+*       This routine gets the Ingress Monitor bit in the PAV.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - the ingress monitor bit in the PAV
+*              GT_FALSE: Ingress Monitor enabled
+*              GT_TRUE:  Ingress Monitor disabled
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+MV_STATUS gpavGetIngressMonitor
+(
+    IN GT_QD_DEV*       dev,
+    IN  GT_LPORT port,
+    OUT MV_BOOL  *mode
+);
+
+/*******************************************************************************
+* gvctGetCableStatus
+*
+* DESCRIPTION:
+*       This routine perform the virtual cable test for the requested port,
+*       and returns the the status per MDI pair.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*       cableLen    - the port copper cable length.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are not supported by this API. For those devices, gvctGetAdvCableDiag
+*        API can be used, instead.
+*
+
+*******************************************************************************/
+MV_STATUS gvctGetCableDiag
+(
+    IN GT_QD_DEV*       dev,
+    IN  GT_LPORT        port,
+    OUT GT_CABLE_STATUS *cableStatus
+);
+
+
+/*******************************************************************************
+* gvctGet1000BTExtendedStatus
+*
+* DESCRIPTION:
+*       This routine retrieves extended cable status, such as Pair Poloarity,
+*        Pair Swap, and Pair Skew. Note that this routine will be success only
+*        if 1000Base-T Link is up.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - the extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are not supported by this API. For those devices, gvctGetAdvExtendedStatus
+*        API can be used, instead.
+*
+*
+*******************************************************************************/
+MV_STATUS gvctGet1000BTExtendedStatus
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_LPORT        port,
+    OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+);
+
+
+/*******************************************************************************
+* gtMemSet
+*
+* DESCRIPTION:
+*       Set a block of memory
+*
+* INPUTS:
+*       start  - start address of memory block for setting
+*       simbol - character to store, converted to an unsigned char
+*       size   - size of block to be set
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Pointer to set memory block
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void * gtMemSet
+(
+    IN void * start,
+    IN int    symbol,
+    IN MV_U32 size
+);
+
+/*******************************************************************************
+* gtMemCpy
+*
+* DESCRIPTION:
+*       Copies 'size' characters from the object pointed to by 'source' into
+*       the object pointed to by 'destination'. If copying takes place between
+*       objects that overlap, the behavior is undefined.
+*
+* INPUTS:
+*       destination - destination of copy
+*       source      - source of copy
+*       size        - size of memory to copy
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Pointer to destination
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void * gtMemCpy
+(
+    IN void *       destination,
+    IN const void * source,
+    IN MV_U32       size
+);
+
+
+/*******************************************************************************
+* gtMemCmp
+*
+* DESCRIPTION:
+*       Compares given memories.
+*
+* INPUTS:
+*       src1 - source 1
+*       src2 - source 2
+*       size - size of memory to copy
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       0, if equal.
+*        negative number, if src1 < src2.
+*        positive number, if src1 > src2.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+int gtMemCmp
+(
+    IN char src1[],
+    IN char src2[],
+    IN MV_U32 size
+);
+
+/*******************************************************************************
+* gtStrlen
+*
+* DESCRIPTION:
+*       Determine the length of a string
+* INPUTS:
+*       source  - string
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       size    - number of characters in string, not including EOS.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_U32 gtStrlen
+(
+    IN const void * source
+);
+
+/*******************************************************************************
+* gtDelay
+*
+* DESCRIPTION:
+*       Wait for the given uSec and return.
+*        Current Switch devices with Gigabit Ethernet Support require 250 uSec
+*        of delay time for PPU to be disabled.
+*        Since this function is System and/or OS dependent, it should be provided
+*        by each DSDT user.
+*
+* INPUTS:
+*       delayTime - delay in uSec.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void gtDelay
+(
+    IN const unsigned int delayTime
+);
+
+
+/*******************************************************************************
+* gtVersion
+*
+* DESCRIPTION:
+*       This function returns the version of the QuarterDeck SW suite.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       version     - QuarterDeck software version.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_BAD_PARAM on bad parameters,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gtVersion
+(
+    OUT GT_VERSION   *version
+);
+
+
+/* Prototypes added for Gigabit Ethernet Switch Support */
+
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+* gfdbMove
+*
+* DESCRIPTION:
+*        This routine moves all or unblocked addresses from a port to another.
+*
+* INPUTS:
+*        moveCmd  - the move operation type.
+*        moveFrom - port where moving from
+*        moveTo   - port where moving to
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbMove
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_MOVE_CMD    moveCmd,
+    IN MV_U32        moveFrom,
+    IN MV_U32        moveTo
+);
+
+/*******************************************************************************
+* gfdbMoveInDB
+*
+* DESCRIPTION:
+*         This routine move all or unblocked addresses which are in the particular
+*         ATU Database (DBNum) from a port to another.
+*
+* INPUTS:
+*         moveCmd  - the move operation type.
+*        DBNum         - ATU MAC Address Database Number.
+*        moveFrom - port where moving from
+*        moveTo   - port where moving to
+*
+* OUTPUTS:
+*     None
+*
+* RETURNS:
+*         GT_OK           - on success
+*         GT_FAIL         - on error
+*         GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbMoveInDB
+(
+    IN GT_QD_DEV   *dev,
+    IN GT_MOVE_CMD moveCmd,
+    IN MV_U32         DBNum,
+    IN MV_U32        moveFrom,
+    IN MV_U32        moveTo
+);
+
+/* gtBrgStp.c */
+
+/* gtBrgVlan.c */
+
+/* gtBrgVtu.c */
+
+/* gtEvents.c */
+
+/*******************************************************************************
+* gatuGetIntStatus
+*
+* DESCRIPTION:
+*        Check to see if a specific type of ATU interrupt occured
+*
+* INPUTS:
+*     intType - the type of interrupt which causes an interrupt.
+*                    GT_MEMEBER_VIOLATION, GT_MISS_VIOLATION, or GT_FULL_VIOLATION
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gatuGetIntStatus
+(
+    IN  GT_QD_DEV                *dev,
+    OUT GT_ATU_INT_STATUS    *atuIntStatus
+);
+
+
+/* gtPhyCtrl.c */
+
+/*******************************************************************************
+* gprtSet1000TMasterMode
+*
+* DESCRIPTION:
+*        This routine set the port multicast rate limit.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_1000T_MASTER_SLAVE structure
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSet1000TMasterMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_1000T_MASTER_SLAVE    *mode
+);
+
+/*******************************************************************************
+* gprtGet1000TMasterMode
+*
+* DESCRIPTION:
+*        This routine set the port multicast rate limit.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_1000T_MASTER_SLAVE structure
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGet1000TMasterMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_1000T_MASTER_SLAVE    *mode
+);
+
+/*******************************************************************************
+* gprtGetPhyReg
+*
+* DESCRIPTION:
+*        This routine reads Phy Registers.
+*
+* INPUTS:
+*        port    - logical port number
+*        regAddr - The register's address.
+*
+* OUTPUTS:
+*        data    - The read register's data.
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPhyReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  MV_U32         regAddr,
+    OUT MV_U16         *data
+);
+
+/*******************************************************************************
+* gprtSetPhyReg
+*
+* DESCRIPTION:
+*        This routine writes Phy Registers.
+*
+* INPUTS:
+*        port    - logical port number
+*        regAddr - The register's address.
+*
+* OUTPUTS:
+*        data    - The read register's data.
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetPhyReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  MV_U32         regAddr,
+    IN  MV_U16         data
+);
+
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtSetDropOnLock
+*
+* DESCRIPTION:
+*        This routine set the Drop on Lock. When set to one, Ingress frames will
+*        be discarded if their SA field is not in the ATU's address database.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for Unknown SA drop or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetDropOnLock
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetDropOnLock
+*
+* DESCRIPTION:
+*        This routine gets DropOnLock mode.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: DropOnLock enabled,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetDropOnLock
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetDoubleTag
+*
+* DESCRIPTION:
+*        This routine set the Ingress Double Tag Mode. When set to one,
+*        ingressing frames are examined to see if they contain an 802.3ac tag.
+*        If they do, the tag is removed and then the frame is processed from
+*        there (i.e., removed tag is ignored). Essentially, untagged frames
+*        remain untagged, single tagged frames become untagged and double tagged
+*        frames become single tagged.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for DoulbeTag mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetDoubleTag
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetDoubleTag
+*
+* DESCRIPTION:
+*        This routine gets DoubleTag mode.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: DoubleTag enabled,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetDoubleTag
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetInterswitchPort
+*
+* DESCRIPTION:
+*        This routine set Interswitch Port. When set to one,
+*        it indicates this port is a interswitch port used to communicated with
+*        CPU or to cascade with another switch device.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for Interswitch port or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetInterswitchPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetInterswithPort
+*
+* DESCRIPTION:
+*        This routine gets InterswitchPort.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: This port is interswitch port,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetInterswitchPort
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetLearnDisable
+*
+* DESCRIPTION:
+*        This routine enables/disables automatic learning of new source MAC
+*        addresses on the given port ingress
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for disable or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetLearnDisable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN MV_BOOL        mode
+);
+
+
+/*******************************************************************************
+* gprtGetLearnDisable
+*
+* DESCRIPTION:
+*        This routine gets LearnDisable setup
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: Learning disabled on the given port ingress frames,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetLearnDisable
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetIgnoreFCS
+*
+* DESCRIPTION:
+*        This routine sets FCS Ignore mode. When this bit is set to a one,
+*        the last four bytes of frames received on this port are overwritten with
+*        a good CRC and the frames will be accepted by the switch.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for ignore FCS or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetIgnoreFCS
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN MV_BOOL         mode
+);
+
+/*******************************************************************************
+* gprtGetIgnoreFCS
+*
+* DESCRIPTION:
+*        This routine gets Ignore FCS setup
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: Ignore FCS on the given port's ingress frames,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetIgnoreFCS
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetVTUPriOverride
+*
+* DESCRIPTION:
+*        VTU Priority Override. The following modes are supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_PRI_OVERRIDE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+MV_STATUS gprtSetVTUPriOverride
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_PRI_OVERRIDE        mode
+);
+
+/*******************************************************************************
+* gprtGetVTUPriOverride
+*
+* DESCRIPTION:
+*        VTU Priority Override. The following modes are supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_PRI_OVERRIDE type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+MV_STATUS gprtGetVTUPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PRI_OVERRIDE        *mode
+);
+
+/*******************************************************************************
+* gprtSetSAPriOverride
+*
+* DESCRIPTION:
+*        SA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_PRI_OVERRIDE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+MV_STATUS gprtSetSAPriOverride
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetSAPriOverride
+*
+* DESCRIPTION:
+*        SA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_PRI_OVERRIDE type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+MV_STATUS gprtGetSAPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PRI_OVERRIDE        *mode
+);
+
+/*******************************************************************************
+* gprtSetDAPriOverride
+*
+* DESCRIPTION:
+*        DA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_PRI_OVERRIDE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+MV_STATUS gprtSetDAPriOverride
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_PRI_OVERRIDE        mode
+);
+
+/*******************************************************************************
+* gprtGetDAPriOverride
+*
+* DESCRIPTION:
+*        DA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_PRI_OVERRIDE type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+MV_STATUS gprtGetDAPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PRI_OVERRIDE        *mode
+);
+
+/*******************************************************************************
+* gprtSetCPUPort
+*
+* DESCRIPTION:
+*        This routine sets CPU Port number. When Snooping is enabled on this port
+*        or when this port is configured as an Interswitch Port and it receives a
+*        To_CPU frame, the switch needs to know what port on this device the frame
+*        should egress.
+*
+* INPUTS:
+*        port - the logical port number.
+*        cpuPort - CPU Port number or interswitch port where CPU Port is connected
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetCPUPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_LPORT     cpuPort
+);
+
+/*******************************************************************************
+* gprtGetCPUPort
+*
+* DESCRIPTION:
+*        This routine gets CPU Logical Port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        cpuPort - CPU Port's logical number
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetCPUPort
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_LPORT     *cpuLPort
+);
+
+/*******************************************************************************
+* gprtSetLockedPort
+*
+* DESCRIPTION:
+*        This routine sets LockedPort. When it's set to one, CPU directed
+*        learning for 802.1x MAC authentication is enabled on this port. In this
+*        mode, an ATU Miss Violation interrupt will occur when a new SA address
+*        is received in a frame on this port. Automatically SA learning and
+*        refreshing is disabled in this mode.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for Locked Port, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetLockedPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetLockedPort
+*
+* DESCRIPTION:
+*        This routine gets Locked Port mode for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if LockedPort, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetLockedPort
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL      *mode
+);
+
+/*******************************************************************************
+* gprtSetIgnoreWrongData
+*
+* DESCRIPTION:
+*        This routine sets Ignore Wrong Data. If the frame's SA address is found
+*        in the database and if the entry is 'static' or if the port is 'locked'
+*        the source port's bit is checked to insure the SA has been assigned to
+*        this port. If the SA is NOT assigned to this port, it is considered an
+*        ATU Member Violation. If the IgnoreWrongData is set to GT_FALSE, an ATU
+*        Member Violation interrupt will be generated. If it's set to GT_TRUE,
+*        the ATU Member Violation error will be masked and ignored.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for IgnoreWrongData, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetIgnoreWrongData
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN MV_BOOL        mode
+);
+
+
+/*******************************************************************************
+* gprtGetIgnoreWrongData
+*
+* DESCRIPTION:
+*        This routine gets Ignore Wrong Data mode for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if IgnoreWrongData, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetIgnoreWrongData
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL     *mode
+);
+
+
+/* gtPortRateCtrl.c */
+
+/* gtPortRmon.c */
+
+/*******************************************************************************
+* gstatsGetPortCounter2
+*
+* DESCRIPTION:
+*        This routine gets a specific counter of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gstatsGetPortCounter2
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS2    counter,
+    OUT MV_U32            *statsData
+);
+
+
+/*******************************************************************************
+* gstatsGetPortAllCounters2
+*
+* DESCRIPTION:
+*        This routine gets all counters of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gstatsGetPortAllCounters2
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET2    *statsCounterSet
+);
+
+/*******************************************************************************
+* gstatsGetHistogramMode
+*
+* DESCRIPTION:
+*        This routine gets the Histogram Counters Mode.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY,
+*                    and GT_COUNT_RX_TX)
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gstatsGetHistogramMode
+(
+    IN  GT_QD_DEV                *dev,
+    OUT GT_HISTOGRAM_MODE    *mode
+);
+
+/*******************************************************************************
+* gstatsSetHistogramMode
+*
+* DESCRIPTION:
+*        This routine sets the Histogram Counters Mode.
+*
+* INPUTS:
+*        mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY,
+*                    and GT_COUNT_RX_TX)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gstatsSetHistogramMode
+(
+    IN GT_QD_DEV                 *dev,
+    IN GT_HISTOGRAM_MODE        mode
+);
+
+
+/* gtPortStatus.c */
+
+/*******************************************************************************
+* gprtGetPauseEn
+*
+* DESCRIPTION:
+*        This routine retrives the link pause state.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE for enable or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        If set MAC Pause (for Full Duplex flow control) is implemented in the
+*        link partner and in MyPause
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPauseEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL     *state
+);
+
+/*******************************************************************************
+* gprtGetHdFlow
+*
+* DESCRIPTION:
+*        This routine retrives the half duplex flow control value.
+*        If set, Half Duplex back pressure will be used on this port if this port
+*        is in a half duplex mode.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE for enable or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetHdFlow
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL     *state
+);
+
+/*******************************************************************************
+* gprtGetPHYDetect
+*
+* DESCRIPTION:
+*        This routine retrives the information regarding PHY detection.
+*        If set, An 802.3 PHY is attached to this port.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if connected or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPHYDetect
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL     *state
+);
+
+/*******************************************************************************
+* gprtSetPHYDetect
+*
+* DESCRIPTION:
+*        This routine sets PHYDetect bit which make PPU change its polling.
+*        PPU's pool routine uses these bits to determine which port's to poll
+*        PHYs on for Link, Duplex, Speed, and Flow Control.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE or GT_FALSE
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        This function should not be called if gsysGetPPUState returns
+*        PPU_STATE_ACTIVE.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetPHYDetect
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  MV_BOOL      state
+);
+
+/*******************************************************************************
+* gprtGetSpeedMode
+*
+* DESCRIPTION:
+*       This routine retrives the port speed.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_PORT_SPEED_MODE type.
+*                    (PORT_SPEED_1000_MBPS,PORT_SPEED_100_MBPS, or PORT_SPEED_10_MBPS)
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetSpeedMode
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_PORT_SPEED_MODE   *speed
+);
+
+/*******************************************************************************
+* gprtGetHighErrorRate
+*
+* DESCRIPTION:
+*        This routine retrives the PCS High Error Rate.
+*        This routine returns GT_TRUE if the rate of invalid code groups seen by
+*        PCS has exceeded 10 to the power of -11.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE or GT_FALSE
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetHighErrorRate
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gprtGetTxPaused
+*
+* DESCRIPTION:
+*        This routine retrives Transmit Pause state.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Rx MAC receives a PAUSE frame with none-zero Puase Time
+*                  GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetTxPaused
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+
+/*******************************************************************************
+* gprtGetFlowCtrl
+*
+* DESCRIPTION:
+*        This routine retrives Flow control state.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Rx MAC determines that no more data should be
+*                    entering this port.
+*                  GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetFlowCtrl
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gprtGetC_Duplex
+*
+* DESCRIPTION:
+*        This routine retrives Port 9's duplex configuration mode determined
+*        at reset.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if configured as Full duplex operation
+*                  GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Return value is valid only if the given port is 9.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetC_Duplex
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gprtGetC_Mode
+*
+* DESCRIPTION:
+*        This routine retrives port's interface type configuration mode
+*        determined at reset.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - one of value in GT_PORT_CONFIG_MODE enum type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Return value is valid only if the given port is 9.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetC_Mode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PORT_CONFIG_MODE   *state
+);
+
+
+/* gtSysCtrl.c */
+
+/*******************************************************************************
+* gsysSetPPUEn
+*
+* DESCRIPTION:
+*        This routine enables/disables Phy Polling Unit.
+*
+* INPUTS:
+*        en - GT_TRUE to enable PPU, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetPPUEn
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL         en
+);
+
+/*******************************************************************************
+* gsysGetPPUEn
+*
+* DESCRIPTION:
+*        This routine get the PPU state.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if PPU is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetPPUEn
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetCascadePort
+*
+* DESCRIPTION:
+*        This routine sets Cascade Port number.
+*        In multichip systems frames coming from a CPU need to know when they
+*        have reached their destination chip.
+*
+* INPUTS:
+*        port - Cascade Port
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetCascadePort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
+);
+
+/*******************************************************************************
+* gsysGetCascadePort
+*
+* DESCRIPTION:
+*        This routine gets Cascade Port number.
+*        In multichip systems frames coming from a CPU need to know when they
+*        have reached their destination chip.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port - Cascade Port
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetCascadePort
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT     *port
+);
+
+/*******************************************************************************
+* gsysSetDeviceNumber
+*
+* DESCRIPTION:
+*        This routine sets Device Number.
+*        In multichip systems frames coming from a CPU need to know when they
+*        have reached their destination chip. From CPU frames whose Dev_Num
+*        fieldmatches these bits have reachedtheir destination chip and are sent
+*        out this chip using the port number indicated in the frame's Trg_Port
+*        field.
+*
+* INPUTS:
+*        devNum - Device Number (0 ~ 31)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetDeviceNumber
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U32          devNum
+);
+
+/*******************************************************************************
+* gsysGetDeviceNumber
+*
+* DESCRIPTION:
+*        This routine gets Device Number.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        devNum - Device Number (0 ~ 31)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetDeviceNumber
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U32      *devNum
+);
+
+
+/* gtPCSCtrl.c */
+
+
+/*******************************************************************************
+* gpcsGetCommaDet
+*
+* DESCRIPTION:
+*        This routine retrieves Comma Detection status in PCS
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetCommaDet
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsGetSyncOK
+*
+* DESCRIPTION:
+*        This routine retrieves SynOK bit. It is set to a one when the PCS has
+*        detected a few comma patterns and is synchronized with its peer PCS
+*        layer.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if synchronized or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetSyncOK
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsGetSyncFail
+*
+* DESCRIPTION:
+*        This routine retrieves SynFail bit.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if synchronizaion failed or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetSyncFail
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsGetAnBypassed
+*
+* DESCRIPTION:
+*        This routine retrieves Inband Auto-Negotiation bypass status.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if AN is bypassed or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetAnBypassed
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsGetAnBypassMode
+*
+* DESCRIPTION:
+*        This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE if AN bypass is enabled or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetAnBypassMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *mode
+);
+
+/*******************************************************************************
+* gpcsSetAnBypassMode
+*
+* DESCRIPTION:
+*        This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to enable AN bypass mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetAnBypassMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL      mode
+);
+
+/*******************************************************************************
+* gpcsGetPCSAnEn
+*
+* DESCRIPTION:
+*        This routine retrieves Enable mode of PCS Inband Auto-Negotiation.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE if PCS AN is enabled or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetPCSAnEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *mode
+);
+
+/*******************************************************************************
+* gpcsSetPCSAnEn
+*
+* DESCRIPTION:
+*        This routine sets Enable mode of PCS Inband Auto-Negotiation.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to enable PCS AN mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetPCSAnEn
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL      mode
+);
+
+/*******************************************************************************
+* gpcsSetRestartPCSAn
+*
+* DESCRIPTION:
+*        This routine restarts PCS Inband Auto-Negotiation.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetRestartPCSAn
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
+);
+
+/*******************************************************************************
+* gpcsGetPCSAnDone
+*
+* DESCRIPTION:
+*        This routine retrieves completion information of PCS Auto-Negotiation.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE if PCS AN is done or never done
+*                GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetPCSAnDone
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *mode
+);
+
+/*******************************************************************************
+* gpcsSetLinkValue
+*
+* DESCRIPTION:
+*        This routine sets Link's force value
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force link up, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetLinkValue
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    MV_BOOL        state
+);
+
+/*******************************************************************************
+* gpcsGetLinkValue
+*
+* DESCRIPTION:
+*        This routine retrieves Link Value which will be used for Forcing Link
+*        up or down.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Link Force value is one (link up)
+*                 GT_FALSE otherwise (link down)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetLinkValue
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsSetForcedLink
+*
+* DESCRIPTION:
+*        This routine forces Link. If LinkValue is set to one, calling this
+*        routine with GT_TRUE will force Link to be up.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force link (up or down), GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetForcedLink
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    MV_BOOL        state
+);
+
+/*******************************************************************************
+* gpcsGetForcedLink
+*
+* DESCRIPTION:
+*        This routine retrieves Forced Link bit
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if ForcedLink bit is one,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetForcedLink
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsSetDpxValue
+*
+* DESCRIPTION:
+*        This routine sets Duplex's Forced value. This function needs to be
+*        called prior to gpcsSetForcedDpx.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force full duplex, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetDpxValue
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    MV_BOOL        state
+);
+
+/*******************************************************************************
+* gpcsGetDpxValue
+*
+* DESCRIPTION:
+*        This routine retrieves Duplex's Forced value
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Duplex's Forced value is set to Full duplex,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetDpxValue
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsSetForcedDpx
+*
+* DESCRIPTION:
+*        This routine forces duplex mode. If DpxValue is set to one, calling this
+*        routine with GT_TRUE will force duplex mode to be full duplex.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force duplex mode, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetForcedDpx
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    MV_BOOL        state
+);
+
+/*******************************************************************************
+* gpcsGetForcedDpx
+*
+* DESCRIPTION:
+*        This routine retrieves Forced Duplex.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if ForcedDpx bit is one,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetForcedDpx
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsSetForceSpeed
+*
+* DESCRIPTION:
+*        This routine forces speed.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or No Speed Force)
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetForceSpeed
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_PORT_FORCED_SPEED_MODE  mode
+);
+
+/*******************************************************************************
+* gpcsGetForceSpeed
+*
+* DESCRIPTION:
+*        This routine retrieves Force Speed value
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or no force speed)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetForceSpeed
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PORT_FORCED_SPEED_MODE   *mode
+);
+
+
+
+/* gtQosMap.c */
+
+/*******************************************************************************
+* gqosGetTagRemap
+*
+* DESCRIPTION:
+*        Gets the remapped priority value for a specific 802.1p priority on a
+*        given port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*        pri   - 802.1p priority
+*
+* OUTPUTS:
+*        remappedPri - remapped Priority
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosGetTagRemap
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  MV_U8        pri,
+    OUT MV_U8       *remappedPri
+);
+
+/*******************************************************************************
+* gqosSetTagRemap
+*
+* DESCRIPTION:
+*        Sets the remapped priority value for a specific 802.1p priority on a
+*        given port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*        pri   - 802.1p priority
+*        remappedPri - remapped Priority
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosSetTagRemap
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN MV_U8        pri,
+    IN MV_U8        remappedPri
+);
+
+
+/* gtSysConfig.c */
+
+/* gtSysStatus.c */
+
+/*******************************************************************************
+* gsysGetPPUState
+*
+* DESCRIPTION:
+*        This routine get the PPU State. These two bits return
+*        the current value of the PPU.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode - GT_PPU_STATE
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetPPUState
+(
+    IN  GT_QD_DEV       *dev,
+    OUT GT_PPU_STATE    *mode
+);
+
+
+/* Prototypes added for 88E6093 */
+
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+* gfdbGetLearn2All
+*
+* DESCRIPTION:
+*        When more than one Marvell device is used to form a single 'switch', it
+*        may be desirable for all devices in the 'switch' to learn any address this
+*        device learns. When this bit is set to a one all other devices in the
+*        'switch' learn the same addresses this device learns. When this bit is
+*        cleared to a zero, only the devices that actually receive frames will learn
+*        from those frames. This mode typically supports more active MAC addresses
+*        at one time as each device in the switch does not need to learn addresses
+*        it may nerver use.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if Learn2All is enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbGetLearn2All
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL     *mode
+);
+
+/*******************************************************************************
+* gfdbSetLearn2All
+*
+* DESCRIPTION:
+*        Enable or disable Learn2All mode.
+*
+* INPUTS:
+*        mode - GT_TRUE to set Learn2All, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbSetLearn2All
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gfdbRemovePort
+*
+* DESCRIPTION:
+*       This routine deassociages all or unblocked addresses from a port.
+*
+* INPUTS:
+*       moveCmd - the move operation type.
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbRemovePort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD     moveCmd,
+    IN GT_LPORT        port
+);
+
+/*******************************************************************************
+* gfdbRemovePortInDB
+*
+* DESCRIPTION:
+*       This routine deassociages all or unblocked addresses from a port in the
+*       particular ATU Database (DBNum).
+*
+* INPUTS:
+*       moveCmd  - the move operation type.
+*       port - the logical port number.
+*        DBNum     - ATU MAC Address Database Number.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbRemovePortInDB
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD     moveCmd,
+    IN GT_LPORT        port,
+    IN MV_U32         DBNum
+);
+
+
+
+/* gtBrgStp.c */
+
+/* gtBrgVlan.c */
+
+/* gtBrgVtu.c */
+
+/* gtEvents.c */
+
+/* gtPCSCtrl.c */
+
+/*******************************************************************************
+* gpcsGetPCSLink
+*
+* DESCRIPTION:
+*        This routine retrieves Link up status in PCS
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetPCSLink
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsSetFCValue
+*
+* DESCRIPTION:
+*        This routine sets Flow Control's force value
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force flow control enabled, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetFCValue
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    MV_BOOL        state
+);
+
+/*******************************************************************************
+* gpcsGetFCValue
+*
+* DESCRIPTION:
+*        This routine retrieves Flow Control Value which will be used for Forcing
+*        Flow Control enabled or disabled.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if FC Force value is one (flow control enabled)
+*                 GT_FALSE otherwise (flow control disabled)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetFCValue
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsSetForcedFC
+*
+* DESCRIPTION:
+*        This routine forces Flow Control. If FCValue is set to one, calling this
+*        routine with GT_TRUE will force Flow Control to be enabled.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force flow control (enable or disable), GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetForcedFC
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    MV_BOOL        state
+);
+
+/*******************************************************************************
+* gpcsGetForcedFC
+*
+* DESCRIPTION:
+*        This routine retrieves Forced Flow Control bit
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if ForcedFC bit is one,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetForcedFC
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+
+
+/* gtPhyCtrl.c */
+
+/*******************************************************************************
+* gprtGetPagedPhyReg
+*
+* DESCRIPTION:
+*       This routine reads phy register of the given page
+*
+* INPUTS:
+*        port     - port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
+*
+* OUTPUTS:
+*        data    - value of the read register
+*
+* RETURNS:
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gprtGetPagedPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  MV_U32  port,
+    IN    MV_U32  regAddr,
+    IN    MV_U32  page,
+    OUT MV_U16* data
+);
+
+/*******************************************************************************
+* gprtSetPagedPhyReg
+*
+* DESCRIPTION:
+*       This routine writes a value to phy register of the given page
+*
+* INPUTS:
+*        port     - port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
+*        data    - value of the read register
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gprtSetPagedPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  MV_U32 port,
+    IN    MV_U32 regAddr,
+    IN    MV_U32 page,
+    IN  MV_U16 data
+);
+
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtSetUseCoreTag
+*
+* DESCRIPTION:
+*       This routine set the UseCoreTag bit in Port Control Register.
+*            When this bit is cleared to a zero, ingressing frames are considered
+*            Tagged if the 16-bits following the frame's Source Address is 0x8100.
+*            When this bit is set to a one, ingressing frames are considered Tagged
+*            if the 16-bits following the frame's Source Address is equal to the
+*            CoreTag register value.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetUseCoreTag
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN MV_BOOL    force
+);
+
+/*******************************************************************************
+* gprtGetUseCoreTag
+*
+* DESCRIPTION:
+*       This routine get the Use Core Tag state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       force - GT_TRUE for using core tag register  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetUseCoreTag
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT MV_BOOL    *force
+);
+
+/*******************************************************************************
+* gprtSetDiscardTagged
+*
+* DESCRIPTION:
+*        When this bit is set to a one, all non-MGMT frames that are processed as
+*        Tagged will be discarded as they enter this switch port. Priority only
+*        tagged frames (with a VID of 0x000) are considered tagged.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to discard tagged frame, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetDiscardTagged
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetDiscardTagged
+*
+* DESCRIPTION:
+*        This routine gets DiscardTagged bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if DiscardTagged bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetDiscardTagged
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL     *mode
+);
+
+/*******************************************************************************
+* gprtSetDiscardUntagged
+*
+* DESCRIPTION:
+*        When this bit is set to a one, all non-MGMT frames that are processed as
+*        Untagged will be discarded as they enter this switch port. Priority only
+*        tagged frames (with a VID of 0x000) are considered tagged.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to discard untagged frame, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetDiscardUntagged
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetDiscardUntagged
+*
+* DESCRIPTION:
+*        This routine gets DiscardUntagged bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if DiscardUntagged bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetDiscardUntagged
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL     *mode
+);
+
+/*******************************************************************************
+* gprtSetMapDA
+*
+* DESCRIPTION:
+*        When this bit is set to a one, normal switch operation will occur where a
+*        frame's DA address is used to direct the frame out the correct port.
+*        When this be is cleared to a zero, the frame will be sent out the port(s)
+*        defined by ForwardUnknown bits or the DefaultForward bits even if the DA
+*        is ound in the address database.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to use MapDA, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetMapDA
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetMapDA
+*
+* DESCRIPTION:
+*        This routine gets MapDA bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if MapDA bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetMapDA
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL     *mode
+);
+
+/*******************************************************************************
+* gprtSetDefaultForward
+*
+* DESCRIPTION:
+*        When this bit is set to a one, normal switch operation will occurs and
+*        multicast frames with unknown DA addresses are allowed to egress out this
+*        port (assuming the VLAN settings allow the frame to egress this port too).
+*        When this be is cleared to a zero, multicast frames with unknown DA
+*        addresses will not egress out this port.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to use DefaultForward, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetDefaultForward
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetDefaultForward
+*
+* DESCRIPTION:
+*        This routine gets DefaultForward bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if DefaultForward bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetDefaultForward
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL     *mode
+);
+
+/*******************************************************************************
+* gprtSetEgressMonitorSource
+*
+* DESCRIPTION:
+*        When this be is cleared to a zero, normal network switching occurs.
+*        When this bit is set to a one, any frame that egresses out this port will
+*        also be sent to the EgressMonitorDest Port
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetEgressMonitorSource
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetEgressMonitorSource
+*
+* DESCRIPTION:
+*        This routine gets EgressMonitorSource bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if EgressMonitorSource bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetEgressMonitorSource
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL     *mode
+);
+
+/*******************************************************************************
+* gprtSetIngressMonitorSource
+*
+* DESCRIPTION:
+*        When this be is cleared to a zero, normal network switching occurs.
+*        When this bit is set to a one, any frame that egresses out this port will
+*        also be sent to the EgressMonitorDest Port
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetIngressMonitorSource
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetIngressMonitorSource
+*
+* DESCRIPTION:
+*        This routine gets IngressMonitorSource bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if IngressMonitorSource bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetIngressMonitorSource
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL     *mode
+);
+
+
+/* gtPortPAV.c */
+
+/* gtPortRateCtrl.c */
+
+/* gtPortRmon.c */
+
+/*******************************************************************************
+* gstatsGetPortCounter3
+*
+* DESCRIPTION:
+*        This routine gets a specific counter of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gstatsGetPortCounter3
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS3    counter,
+    OUT MV_U32            *statsData
+);
+
+/*******************************************************************************
+* gstatsGetPortAllCounters3
+*
+* DESCRIPTION:
+*        This routine gets all counters of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gstatsGetPortAllCounters3
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET3    *statsCounterSet
+);
+
+
+/* gtPortStat.c */
+
+/*******************************************************************************
+* gprtGetPortCtr2
+*
+* DESCRIPTION:
+*       This routine gets the port InDiscards, InFiltered, and OutFiltered counters.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       ctr - the counters value.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPortCtr2
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_PORT_STAT2   *ctr
+);
+
+/* gtPortStatus.c */
+
+/*******************************************************************************
+* gprtGetMGMII
+*
+* DESCRIPTION:
+*        SERDES Interface mode. When this bit is cleared to a zero and a PHY is
+*        detected connected to this port, the SERDES interface between this port
+*        and the PHY will be SGMII.  When this bit is set toa one and a PHY is
+*        detected connected to this port, the SERDES interface between this port
+*        and the PHY will be MGMII. When no PHY is detected on this port and the
+*        SERDES interface is being used, it will be configured in 1000Base-X mode.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE or GT_FALSE
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetMGMII
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gprtSetMGMII
+*
+* DESCRIPTION:
+*        SERDES Interface mode. When this bit is cleared to a zero and a PHY is
+*        detected connected to this port, the SERDES interface between this port
+*        and the PHY will be SGMII.  When this bit is set toa one and a PHY is
+*        detected connected to this port, the SERDES interface between this port
+*        and the PHY will be MGMII. When no PHY is detected on this port and the
+*        SERDES interface is being used, it will be configured in 1000Base-X mode.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE or GT_FALSE
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetMGMII
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  MV_BOOL      state
+);
+
+
+/* gtQosMap.c */
+
+/* gtSysCtrl.c */
+
+/*******************************************************************************
+* gsysSetCoreTagType
+*
+* DESCRIPTION:
+*        This routine sets Ether Core Tag Type.
+*        This Ether Type is added to frames that egress the switch as Double Tagged
+*        frames. It is also the Ether Type expected during Ingress to determine if
+*        a frame is Tagged or not on ports configured as UseCoreTag mode.
+*
+* INPUTS:
+*        etherType - Core Tag Type (2 bytes)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetCoreTagType
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U16          etherType
+);
+
+/*******************************************************************************
+* gsysGetCoreTagType
+*
+* DESCRIPTION:
+*        This routine gets CoreTagType
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        etherType - Core Tag Type (2 bytes)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetCoreTagType
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U16      *etherType
+);
+
+/*******************************************************************************
+* gsysSetIngressMonitorDest
+*
+* DESCRIPTION:
+*        This routine sets Ingress Monitor Destination Port. Frames that are
+*        targeted toward an Ingress Monitor Destination go out the port number
+*        indicated in these bits. This includes frames received on a Marvell Tag port
+*        with the Ingress Monitor type, and frames received on a Network port that
+*        is enabled to be the Ingress Monitor Source Port.
+*        If the Ingress Monitor Destination Port resides in this device these bits
+*        should point to the Network port where these frames are to egress. If the
+*        Ingress Monitor Destination Port resides in another device these bits
+*        should point to the Marvell Tag port in this device that is used to get
+*        to the device that contains the Ingress Monitor Destination Port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetIngressMonitorDest
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+);
+
+/*******************************************************************************
+* gsysGetIngressMonitorDest
+*
+* DESCRIPTION:
+*        This routine gets Ingress Monitor Destination Port.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetIngressMonitorDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+);
+
+/*******************************************************************************
+* gsysSetEgressMonitorDest
+*
+* DESCRIPTION:
+*        This routine sets Egress Monitor Destination Port. Frames that are
+*        targeted toward an Egress Monitor Destination go out the port number
+*        indicated in these bits. This includes frames received on a Marvell Tag port
+*        with the Egress Monitor type, and frames transmitted on a Network port that
+*        is enabled to be the Egress Monitor Source Port.
+*        If the Egress Monitor Destination Port resides in this device these bits
+*        should point to the Network port where these frames are to egress. If the
+*        Egress Monitor Destination Port resides in another device these bits
+*        should point to the Marvell Tag port in this device that is used to get
+*        to the device that contains the Egress Monitor Destination Port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetEgressMonitorDest
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+);
+
+/*******************************************************************************
+* gsysGetEgressMonitorDest
+*
+* DESCRIPTION:
+*        This routine gets Egress Monitor Destination Port.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetEgressMonitorDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+);
+
+
+/* gtSysConfig.c */
+
+/* gtSysStatus.c */
+
+
+/* functions added on rev 2.2 */
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtSetMessagePort
+*
+* DESCRIPTION:
+*        When the Learn2All bit is set to one, learning message frames are
+*        generated. These frames will be sent out all ports whose Message Port is
+*        set to one.
+*         If this feature is used, it is recommended that all Marvell Tag ports,
+*        except for the CPU's port, have their MessagePort bit set to one.
+*        Ports that are not Marvell Tag ports should not have their Message Port
+*        bit set to one.
+*
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtSetMessagePort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetMessagePort
+*
+* DESCRIPTION:
+*        When the Learn2All bit is set to one, learning message frames are
+*        generated. These frames will be sent out all ports whose Message Port is
+*        set to one.
+*         If this feature is used, it is recommended that all Marvell Tag ports,
+*        except for the CPU's port, have their MessagePort bit set to one.
+*        Ports that are not Marvell Tag ports should not have their Message Port
+*        bit set to one.
+*
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetMessagePort
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL     *mode
+);
+
+
+/*******************************************************************************
+* gprtSetTrunkPort
+*
+* DESCRIPTION:
+*        This function enables/disables and sets the trunk ID.
+*
+* INPUTS:
+*        port - the logical port number.
+*        en - GT_TRUE to make the port be a member of a trunk with the given trunkId.
+*             GT_FALSE, otherwise.
+*        trunkId - valid ID is 0 ~ 15.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkId is neither valid nor INVALID_TRUNK_ID
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtSetTrunkPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL         en,
+    IN MV_U32        trunkId
+);
+
+
+/*******************************************************************************
+* gprtGetTrunkPort
+*
+* DESCRIPTION:
+*        This function returns trunk state of the port.
+*        When trunk is disabled, trunkId field won't have valid value.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        en - GT_TRUE, if the port is a member of a trunk,
+*             GT_FALSE, otherwise.
+*        trunkId - 0 ~ 15, valid only if en is GT_TRUE
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetTrunkPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    OUT MV_BOOL     *en,
+    OUT MV_U32        *trunkId
+);
+
+
+
+
+/*******************************************************************************
+* gprtGetGlobal2Reg
+*
+* DESCRIPTION:
+*       This routine reads Switch Global 2 Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetGlobal2Reg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  MV_U32         regAddr,
+    OUT MV_U16         *data
+);
+
+/*******************************************************************************
+* gprtSetGlobal2Reg
+*
+* DESCRIPTION:
+*       This routine writes Switch Global2 Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetGlobal2Reg
+(
+    IN  GT_QD_DEV        *dev,
+    IN  MV_U32            regAddr,
+    IN  MV_U16            data
+);
+
+/* gtSysCtrl.c */
+/*******************************************************************************
+* gsysSetARPDest
+*
+* DESCRIPTION:
+*        This routine sets ARP Monitor Destination Port. Tagged or untagged
+*        frames that ingress Network ports with the Broadcast Destination Address
+*        and with an Ethertype of 0x0806 are mirrored to this port. The ARPDest
+*        should point to the port that directs these frames to the switch's CPU
+*        that will process ARPs. This target port should be a Marvell Tag port so
+*        that frames will egress with a To_CPU Marvell Tag with a CPU Code of ARP.
+*        To_CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell
+*        Tag port will be sent to the port number definded in ARPDest.
+*
+*        If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To_CPU ARP
+*        frames will be discarded.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetARPDest
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+);
+
+/*******************************************************************************
+* gsysGetARPDest
+*
+* DESCRIPTION:
+*        This routine gets ARP Monitor Destination Port. Tagged or untagged
+*        frames that ingress Network ports with the Broadcast Destination Address
+*        and with an Ethertype of 0x0806 are mirrored to this port. The ARPDest
+*        should point to the port that directs these frames to the switch's CPU
+*        that will process ARPs. This target port should be a Marvell Tag port so
+*        that frames will egress with a To_CPU Marvell Tag with a CPU Code of ARP.
+*        To_CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell
+*        Tag port will be sent to the port number definded in ARPDest.
+*
+*        If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To_CPU ARP
+*        frames will be discarded.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetARPDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+);
+
+/*******************************************************************************
+* gsysSetRsvd2CpuEnables
+*
+* DESCRIPTION:
+*        Reserved DA Enables. When the function, gsysSetRsvd2Cpu, is called with
+*        en = GT_TRUE, the 16 reserved multicast DA addresses, whose bit in this
+*        enBits(or register) are also set to a one, are treated as MGMT frames.
+*        All the reserved DA's take the form 01:80:C2:00:00:0x. When x = 0x0,
+*        bit 0 of this register is tested. When x = 0x2, bit 2 of this field is
+*        tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will
+*        be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*        enBits - bit vector of enabled Reserved Multicast.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetRsvd2CpuEnables
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U16        enBits
+);
+
+/*******************************************************************************
+* gsysGetRsvd2CpuEnables
+*
+* DESCRIPTION:
+*        Reserved DA Enables. When the function, gsysSetRsvd2Cpu, is called with
+*        en = GT_TRUE, the 16 reserved multicast DA addresses, whose bit in this
+*        enBits(or register) are also set to a one, are treated as MGMT frames.
+*        All the reserved DA's take the form 01:80:C2:00:00:0x. When x = 0x0,
+*        bit 0 of this register is tested. When x = 0x2, bit 2 of this field is
+*        tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will
+*        be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        enBits - bit vector of enabled Reserved Multicast.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetRsvd2CpuEnables
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U16      *enBits
+);
+
+/*******************************************************************************
+* gsysSetRsvd2Cpu
+*
+* DESCRIPTION:
+*        When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination
+*        Address in the range 01:80:C2:00:00:0x, regardless of their VLAN
+*        membership, will be considered MGMT frames and sent to the port's CPU
+*        Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable
+*        function) for the frames's DA is also set to a one.
+*
+* INPUTS:
+*        en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetRsvd2Cpu
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetRsvd2Cpu
+*
+* DESCRIPTION:
+*        When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination
+*        Address in the range 01:80:C2:00:00:0x, regardless of their VLAN
+*        membership, will be considered MGMT frames and sent to the port's CPU
+*        Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable
+*        function) for the frames's DA is also set to a one.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetRsvd2Cpu
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetMGMTPri
+*
+* DESCRIPTION:
+*        These bits are used as the PRI[2:0] bits on Rsvd2CPU MGMT frames.
+*
+* INPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetMGMTPri
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U16        pri
+);
+
+/*******************************************************************************
+* gsysGetMGMTPri
+*
+* DESCRIPTION:
+*        These bits are used as the PRI[2:0] bits on Rsvd2CPU MGMT frames.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetMGMTPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U16      *pri
+);
+
+/*******************************************************************************
+* gsysSetUseDoubleTagData
+*
+* DESCRIPTION:
+*        This bit is used to determine if Double Tag data that is removed from a
+*        Double Tag frame is used or ignored when making switching decisions on
+*        the frame.
+*
+* INPUTS:
+*        en - GT_TRUE to use removed tag data, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetUseDoubleTagData
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetUseDoubleTagData
+*
+* DESCRIPTION:
+*        This bit is used to determine if Double Tag data that is removed from a
+*        Double Tag frame is used or ignored when making switching decisions on
+*        the frame.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if removed tag data is used, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetUseDoubleTagData
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetPreventLoops
+*
+* DESCRIPTION:
+*        When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev
+*        field equals this device's Device Number, the following action will be
+*        taken depending upon the value of this bit.
+*        GT_TRUE (1) - The frame will be discarded.
+*        GT_FALSE(0) - The frame will be prevented from going out its original
+*                        source port as defined by the frame's Src_Port field.
+*
+* INPUTS:
+*        en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetPreventLoops
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetPreventLoops
+*
+* DESCRIPTION:
+*        When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev
+*        field equals this device's Device Number, the following action will be
+*        taken depending upon the value of this bit.
+*        GT_TRUE (1) - The frame will be discarded.
+*        GT_FALSE(0) - The frame will be prevented from going out its original
+*                        source port as defined by the frame's Src_Port field.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetPreventLoops
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetFlowControlMessage
+*
+* DESCRIPTION:
+*        When this bit is set to one, Marvell Tag Flow Control messages will be
+*        generated when an output queue becomes congested and received Marvell Tag
+*        Flow Control messages will pause MACs inside this device. When this bit
+*        is cleared to a zero, Marvell Tag Flow Control messages will not be
+*        generated and any received will be ignored at the target MAC.
+*
+* INPUTS:
+*        en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetFlowControlMessage
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetFlowControlMessage
+*
+* DESCRIPTION:
+*        When this bit is set to one, Marvell Tag Flow Control messages will be
+*        generated when an output queue becomes congested and received Marvell Tag
+*        Flow Control messages will pause MACs inside this device. When this bit
+*        is cleared to a zero, Marvell Tag Flow Control messages will not be
+*        generated and any received will be ignored at the target MAC.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetFlowControlMessage
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetForceFlowControlPri
+*
+* DESCRIPTION:
+*        When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag
+*        Flow Control frames will be set to the value of the FC Pri bits (set by
+*        gsysSetFCPri function call). When this bit is cleared to a zero, generated
+*        Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the
+*        frames that caused the congestion. This bit will have no effect if the
+*        FlowControlMessage bit(gsysSetFlowControlMessage function call) is
+*        cleared to a zero.
+*
+* INPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetForceFlowControlPri
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetForceFlowControlPri
+*
+* DESCRIPTION:
+*        When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag
+*        Flow Control frames will be set to the value of the FC Pri bits (set by
+*        gsysSetFCPri function call). When this bit is cleared to a zero, generated
+*        Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the
+*        frames that caused the congestion. This bit will have no effect if the
+*        FlowControlMessage bit(gsysSetFlowControlMessage function call) is
+*        cleared to a zero.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetForceFlowControlPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetFCPri
+*
+* DESCRIPTION:
+*        These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow
+*        Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+*        is set to a one.
+*
+* INPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetFCPri
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U16        pri
+);
+
+/*******************************************************************************
+* gsysGetFCPri
+*
+* DESCRIPTION:
+*        These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow
+*        Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+*        is set to a one.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetFCPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U16      *pri
+);
+
+/*******************************************************************************
+* gsysSetFlowCtrlDelay
+*
+* DESCRIPTION:
+*        This function sets Flow control delay time for 10Mbps, 100Mbps, and
+*        1000Mbps.
+*
+* INPUTS:
+*        sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+*        delayTime - actual delay time will be (this value x 2.048uS).
+*                    the value cannot exceed 0x1FFF (or 8191 in decimal).
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetFlowCtrlDelay
+(
+    IN GT_QD_DEV            *dev,
+    IN GT_PORT_SPEED_MODE    sp,
+    IN MV_U32                delayTime
+);
+
+/*******************************************************************************
+* gsysGetFlowCtrlDelay
+*
+* DESCRIPTION:
+*        This function retrieves Flow control delay time for 10Mbps, 100Mbps, and
+*        1000Mbps.
+*
+* INPUTS:
+*        sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+*
+* OUTPUTS:
+*        delayTime - actual delay time will be (this value x 2.048uS).
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetFlowCtrlDelay
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_PORT_SPEED_MODE    sp,
+    OUT MV_U32        *delayTime
+);
+
+/*******************************************************************************
+* gsysSetDevRoutingTable
+*
+* DESCRIPTION:
+*        This function sets Device to Port mapping (which device is connected to
+*        which port of this device).
+*
+* INPUTS:
+*        devNum - target device number.
+*        portNum - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if devNum >= 32 or port >= total number of ports.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetDevRoutingTable
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U32          devNum,
+    IN GT_LPORT     port
+);
+
+/*******************************************************************************
+* gsysGetDevRoutingTable
+*
+* DESCRIPTION:
+*        This function gets Device to Port mapping (which device is connected to
+*        which port of this device).
+*
+* INPUTS:
+*        devNum - target device number.
+*
+* OUTPUTS:
+*        portNum - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if devNum >= 32
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetDevRoutingTable
+(
+    IN  GT_QD_DEV    *dev,
+    IN  MV_U32         devNum,
+    OUT GT_LPORT     *port
+);
+
+/*******************************************************************************
+* gsysSetTrunkMaskTable
+*
+* DESCRIPTION:
+*        This function sets Trunk mask vector table for load balancing.
+*        This vector will be AND'ed with where the frame was originally egressed to.
+*        To insure all trunks are load balanced correctly, the data in this table
+*        needs to be correctly configured.
+*
+* INPUTS:
+*        trunkNum - one of the eight Trunk mask vectors.
+*        trunkMask - Trunk Mask bits. Bit 0 controls trunk masking for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkNum > 0x7 or trunMask > 0x7FF (or port vector).
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetTrunkMaskTable
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U32          trunkNum,
+    IN MV_U32        trunkMask
+);
+
+/*******************************************************************************
+* gsysGetTrunkMaskTable
+*
+* DESCRIPTION:
+*        This function sets Trunk mask vector table for load balancing.
+*        This vector will be AND'ed with where the frame was originally egressed to.
+*        To insure all trunks are load balanced correctly, the data in this table
+*        needs to be correctly configured.
+*
+* INPUTS:
+*        trunkNum - one of the eight Trunk mask vectors.
+*
+* OUTPUTS:
+*        trunkMask - Trunk Mask bits. Bit 0 controls trunk masking for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkNum > 0x7.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetTrunkMaskTable
+(
+    IN  GT_QD_DEV    *dev,
+    IN  MV_U32         trunkNum,
+    OUT MV_U32        *trunkMask
+);
+
+/*******************************************************************************
+* gsysSetHashTrunk
+*
+* DESCRIPTION:
+*        Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished
+*        by using the frame's DA and SA fields to access one of eight Trunk Masks.
+*        When this bit is set to a one, the hashed computed for address table
+*        lookups is used for the TrunkMask selection. When this bit is cleared to
+*        a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to
+*        select the TrunkMask to use.
+*
+* INPUTS:
+*        en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetHashTrunk
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetHashTrunk
+*
+* DESCRIPTION:
+*        Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished
+*        by using the frame's DA and SA fields to access one of eight Trunk Masks.
+*        When this bit is set to a one, the hashed computed for address table
+*        lookups is used for the TrunkMask selection. When this bit is cleared to
+*        a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to
+*        select the TrunkMask to use.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetHashTrunk
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetTrunkRouting
+*
+* DESCRIPTION:
+*        This function sets routing information for the given Trunk ID.
+*
+* INPUTS:
+*        trunkId - Trunk ID.
+*        trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkId > 0xF or trunkRoute > 0x7FF(or port vector).
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysSetTrunkRouting
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U32          trunkId,
+    IN MV_U32        trunkRoute
+);
+
+/*******************************************************************************
+* gsysGetTrunkRouting
+*
+* DESCRIPTION:
+*        This function retrieves routing information for the given Trunk ID.
+*
+* INPUTS:
+*        trunkId - Trunk ID.
+*
+* OUTPUTS:
+*        trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkId > 0xF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetTrunkRouting
+(
+    IN  GT_QD_DEV    *dev,
+    IN  MV_U32         trunkId,
+    OUT MV_U32        *trunkRoute
+);
+
+
+
+/* Prototype added for 88E6095 Rev 1 or Rev 2 */
+
+/* gtPortCtrl.c */
+/*******************************************************************************
+* gprtGetDiscardBCastMode
+*
+* DESCRIPTION:
+*       This routine gets the Discard Broadcast Mode. If the mode is enabled,
+*        all the broadcast frames to the given port will be discarded.
+*
+* INPUTS:
+*       port - logical port number
+*
+* OUTPUTS:
+*        en - GT_TRUE, if enabled,
+*             GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetDiscardBCastMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *en
+);
+
+/*******************************************************************************
+* gprtSetDiscardBCastMode
+*
+* DESCRIPTION:
+*       This routine sets the Discard Broadcast mode.
+*        If the mode is enabled, all the broadcast frames to the given port will
+*        be discarded.
+*
+* INPUTS:
+*       port - logical port number
+*        en - GT_TRUE, to enable the mode,
+*             GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetDiscardBCastMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  MV_BOOL      en
+);
+
+/*******************************************************************************
+* gprtGetFCOnRateLimitMode
+*
+* DESCRIPTION:
+*       This routine returns mode that tells if ingress rate limiting uses Flow
+*        Control. When this mode is enabled and the port receives frames over the
+*        limit, Ingress Rate Limiting will be performed by stalling the
+*        link partner using flow control, instead of discarding frames.
+*
+* INPUTS:
+*       port - logical port number
+*
+* OUTPUTS:
+*        en - GT_TRUE, if the mode is enabled,
+*             GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetFCOnRateLimitMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *en
+);
+
+/*******************************************************************************
+* gprtSetFCOnRateLimitMode
+*
+* DESCRIPTION:
+*       This routine sets the mode that tells if ingress rate limiting uses Flow
+*        Control. When this mode is enabled and the port receives frames over the
+*        limit, Ingress Rate Limiting will be performed by stalling the
+*        link partner using flow control, instead of discarding frames.
+*
+* INPUTS:
+*       port - logical port number
+*        en - GT_TRUE, to enable the mode,
+*             GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetFCOnRateLimitMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  MV_BOOL      en
+);
+
+
+/* gtPortRateCtrl.c */
+
+/*******************************************************************************
+* grcSetBurstRate
+*
+* DESCRIPTION:
+*       This routine sets the port's ingress data limit based on burst size.
+*
+* INPUTS:
+*       port    - logical port number.
+*       bsize    - burst size.
+*       rate    - ingress data rate limit. These frames will be discarded after
+*                the ingress rate selected is reached or exceeded.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*                                Minimum rate for Burst Size 24K byte is 128Kbps
+*                                Minimum rate for Burst Size 48K byte is 256Kbps
+*                                Minimum rate for Burst Size 96K byte is 512Kbps
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*        If the device supports both priority based Rate Limiting and burst size
+*        based Rate limiting, user has to manually change the mode to burst size
+*        based Rate limiting by calling gsysSetRateLimitMode.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS grcSetBurstRate
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_BURST_SIZE   bsize,
+    IN GT_BURST_RATE   rate
+);
+
+/*******************************************************************************
+* grcGetBurstRate
+*
+* DESCRIPTION:
+*       This routine retrieves the port's ingress data limit based on burst size.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       bsize    - burst size.
+*       rate    - ingress data rate limit. These frames will be discarded after
+*                the ingress rate selected is reached or exceeded.
+*
+* RETURNS:
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS grcGetBurstRate
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_BURST_SIZE   *bsize,
+    OUT GT_BURST_RATE   *rate
+);
+
+
+/*******************************************************************************
+* grcSetTCPBurstRate
+*
+* DESCRIPTION:
+*       This routine sets the port's TCP/IP ingress data limit based on burst size.
+*
+* INPUTS:
+*       port    - logical port number.
+*       rate    - ingress data rate limit for TCP/IP packets. These frames will
+*                be discarded after the ingress rate selected is reached or exceeded.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*                                Valid rate is GT_BURST_NO_LIMIT, or between
+*                                64Kbps and 1500Kbps.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*        If the device supports both priority based Rate Limiting and burst size
+*        based Rate limiting, user has to manually change the mode to burst size
+*        based Rate limiting by calling gsysSetRateLimitMode.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS grcSetTCPBurstRate
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_BURST_RATE   rate
+);
+
+
+/*******************************************************************************
+* grcGetTCPBurstRate
+*
+* DESCRIPTION:
+*       This routine sets the port's TCP/IP ingress data limit based on burst size.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       rate    - ingress data rate limit for TCP/IP packets. These frames will
+*                be discarded after the ingress rate selected is reached or exceeded.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_VALUE        - register value is not known
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*        If the device supports both priority based Rate Limiting and burst size
+*        based Rate limiting, user has to manually change the mode to burst size
+*        based Rate limiting by calling gsysSetRateLimitMode.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS grcGetTCPBurstRate
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_BURST_RATE   *rate
+);
+
+
+/* gtSysCtrl.c */
+/*******************************************************************************
+* gsysSetRateLimitMode
+*
+* DESCRIPTION:
+*        Ingress Rate Limiting can be either Priority based or Burst Size based.
+*        This routine sets which mode to use.
+*
+* INPUTS:
+*        mode - either GT_RATE_PRI_BASE or GT_RATE_BURST_BASE
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if invalid mode is used.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetRateLimitMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_INGRESS_RATE_MODE mode
+);
+
+/*******************************************************************************
+* gsysGetRateLimitMode
+*
+* DESCRIPTION:
+*        Ingress Rate Limiting can be either Priority based or Burst Size based.
+*        This routine gets which mode is being used.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode - either GT_RATE_PRI_BASE or GT_RATE_BURST_BASE
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetRateLimitMode
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_INGRESS_RATE_MODE *mode
+);
+
+/*******************************************************************************
+* gsysSetAgeInt
+*
+* DESCRIPTION:
+*        Enable/Disable Age Refresh Interrupt. If CPU Directed Learning is being
+*        used (gprtSetLockedPort), it may be desirable to know when an address is
+*        still being used before it totally ages out of the switch. This can be
+*        accomplished by enabling Age Refresh Interrupt (or ATU Age Violation Int).
+*        An ATU Age Violation looks identical to and reported the same as an ATU
+*        Miss Violation. The only difference is when this reported. Normal ATU Miss
+*        Violation only occur if a new SA arrives at a LockedPort. The Age version
+*        of the ATU Miss Violation occurs if an SA arrives at a LockedPort, where
+*        the address is contained in the ATU's database, but where its EntryState
+*        is less than 0x4 (i.e., it has aged more than 1/2 way).
+*        GT_ATU_PROB Interrupt should be enabled for this interrupt to occur.
+*        Refer to eventSetActive routine to enable GT_ATU_PROB.
+*
+*
+* INPUTS:
+*        en - GT_TRUE, to enable,
+*             GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetAgeInt
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetAgeInt
+*
+* DESCRIPTION:
+*        Get state of Age Refresh Interrupt mode. If CPU Directed Learning is being
+*        used (gprtSetLockedPort), it may be desirable to know when an address is
+*        still being used before it totally ages out of the switch. This can be
+*        accomplished by enabling Age Refresh Interrupt (or ATU Age Violation Int).
+*        An ATU Age Violation looks identical to and reported the same as an ATU
+*        Miss Violation. The only difference is when this reported. Normal ATU Miss
+*        Violation only occur if a new SA arrives at a LockedPort. The Age version
+*        of the ATU Miss Violation occurs if an SA arrives at a LockedPort, where
+*        the address is contained in the ATU's database, but where its EntryState
+*        is less than 0x4 (i.e., it has aged more than 1/2 way).
+*        GT_ATU_PROB Interrupt should be enabled for this interrupt to occur.
+*        Refer to eventSetActive routine to enable GT_ATU_PROB.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE, if enabled,
+*             GT_FALSE, otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetAgeInt
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL        *en
+);
+
+
+/* For Zephyr */
+
+/* gtPhyCtrl.c */
+/*******************************************************************************
+* gprtGetPhyLinkStatus
+*
+* DESCRIPTION:
+*       This routine retrieves the Link status.
+*
+* INPUTS:
+*         port     - The logical port number
+*
+* OUTPUTS:
+*       linkStatus - GT_FALSE if link is not established,
+*                     GT_TRUE if link is established.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPhyLinkStatus
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN MV_BOOL      *linkStatus
+);
+
+
+/*******************************************************************************
+* gprtSetPktGenEnable
+*
+* DESCRIPTION:
+*       This routine enables or disables Packet Generator.
+*       Link should be established first prior to enabling the packet generator,
+*       and generator will generate packets at the speed of the established link.
+*        When enables packet generator, the following information should be
+*       provided:
+*           Payload Type:  either Random or 5AA55AA5
+*           Packet Length: either 64 or 1514 bytes
+*           Error Packet:  either Error packet or normal packet
+*
+* INPUTS:
+*         port     - The logical port number
+*       en      - GT_TRUE to enable, GT_FALSE to disable
+*       pktInfo - packet information(GT_PG structure pointer), if en is GT_TRUE.
+*                 ignored, if en is GT_FALSE
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtSetPktGenEnable
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN MV_BOOL   en,
+    IN GT_PG     *pktInfo
+);
+
+/*******************************************************************************
+* gprtGetSerdesMode
+*
+* DESCRIPTION:
+*       This routine reads Serdes Interface Mode.
+*
+* INPUTS:
+*       port    - logical port number
+*
+* OUTPUTS:
+*       mode    - Serdes Interface Mode
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetSerdesMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_SERDES_MODE *mode
+);
+
+/*******************************************************************************
+* gprtSetSerdesMode
+*
+* DESCRIPTION:
+*       This routine sets Serdes Interface Mode.
+*
+* INPUTS:
+*       port    - logical port number
+*       mode    - Serdes Interface Mode
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetSerdesMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_SERDES_MODE mode
+);
+
+
+/* gtSysCtrl.c */
+
+/*******************************************************************************
+* gsysSetForceSnoopPri
+*
+* DESCRIPTION:
+*        Force Snooping Priority. The priority on IGMP or MLD Snoop frames are
+*        set to the SnoopPri value (gsysSetSnoopPri API) when Force Snooping
+*       Priority is enabled. When it's disabled, the priority on these frames
+*        is not modified.
+*
+* INPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetForceSnoopPri
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetForceSnoopPri
+*
+* DESCRIPTION:
+*        Force Snooping Priority. The priority on IGMP or MLD Snoop frames are
+*        set to the SnoopPri value (gsysSetSnoopPri API) when Force Snooping
+*       Priority is enabled. When it's disabled, the priority on these frames
+*        is not modified.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetForceSnoopPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+
+/*******************************************************************************
+* gsysSetSnoopPri
+*
+* DESCRIPTION:
+*        Snoop Priority. When ForceSnoopPri (gsysSetForceSnoopPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU Snoop frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on IGMP/MLD snoop frames.
+*
+* INPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetSnoopPri
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U16        pri
+);
+
+
+/*******************************************************************************
+* gsysGetSnoopPri
+*
+* DESCRIPTION:
+*        Snoop Priority. When ForceSnoopPri (gsysSetForceSnoopPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU Snoop frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on IGMP/MLD snoop frames.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetSnoopPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U16      *pri
+);
+
+
+/*******************************************************************************
+* gsysSetForceARPPri
+*
+* DESCRIPTION:
+*        Force ARP Priority. The priority on ARP frames are set to the ARPPri
+*       value (gsysSetARPPri API) when Force ARP Priority is enabled. When it's
+*       disabled, the priority on these frames is not modified.
+*
+* INPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetForceARPPri
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetForceARPPri
+*
+* DESCRIPTION:
+*        Force ARP Priority. The priority on ARP frames are set to the ARPPri
+*       value (gsysSetARPPri API) when Force ARP Priority is enabled. When it's
+*       disabled, the priority on these frames is not modified.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetForceARPPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+
+/*******************************************************************************
+* gsysSetARPPri
+*
+* DESCRIPTION:
+*        ARP Priority. When ForceARPPri (gsysSetForceARPPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU ARP frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on ARP frames.
+*
+* INPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetARPPri
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U16        pri
+);
+
+
+/*******************************************************************************
+* gsysGetARPPri
+*
+* DESCRIPTION:
+*        ARP Priority. When ForceARPPri (gsysSetForceARPPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU ARP frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on ARP frames.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetARPPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U16      *pri
+);
+
+
+/* added for 88E6065 */
+
+/* gtBrgVlan.c */
+
+/********************************************************************
+* gvlnSetForceMap
+*
+* DESCRIPTION:
+*       This routine enables/disables Force Map feature.
+*        When Force Map feature is enabled, all received frames will be
+*        considered MGMT and they are mapped to the port or ports defined
+*        in the VLAN Table overriding the mapping from the address database.
+*
+* INPUTS:
+*       port    - logical port number to set.
+*       mode    - GT_TRUE, to enable force map feature
+*                 GT_FAULSE, otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gvlnSetForceMap
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    IN  MV_BOOL      mode
+);
+
+
+/********************************************************************
+* gvlnGetForceMap
+*
+* DESCRIPTION:
+*       This routine checks if Force Map feature is enabled.
+*        When Force Map feature is enabled, all received frames will be
+*        considered MGMT and they are mapped to the port or ports defined
+*        in the VLAN Table overriding the mapping from the address database.
+*
+* INPUTS:
+*       port    - logical port number to set.
+*
+* OUTPUTS:
+*       mode    - GT_TRUE, to enable force map feature
+*                 GT_FAULSE, otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gvlnGetForceMap
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *mode
+);
+
+/* gtEvents.c */
+
+/*******************************************************************************
+* geventSetAgeIntEn
+*
+* DESCRIPTION:
+*        This routine enables/disables Age Interrupt for a port.
+*        When it's enabled, ATU Age Violation interrupts from this port are enabled.
+*        An Age Violation will occur anytime a port is Locked(gprtSetLockedPort)
+*        and the ingressing frame's SA is contained in the ATU as a non-Static
+*        entry with a EntryState less than 0x4.
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_TRUE to enable Age Interrupt,
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS geventSetAgeIntEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  MV_BOOL        mode
+);
+
+/*******************************************************************************
+* geventGetAgeIntEn
+*
+* DESCRIPTION:
+*        This routine gets Age Interrupt Enable for the port.
+*        When it's enabled, ATU Age Violation interrupts from this port are enabled.
+*        An Age Violation will occur anytime a port is Locked(gprtSetLockedPort)
+*        and the ingressing frame's SA is contained in the ATU as a non-Static
+*        entry with a EntryState less than 0x4.
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_TRUE to enable Age Interrupt,
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS geventGetAgeIntEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+
+/* gtPIRL.c */
+
+/*******************************************************************************
+* gpirlActivate
+*
+* DESCRIPTION:
+*       This routine activates Ingress Rate Limiting for the given ports by
+*        initializing a resource bucket, assigning ports, and configuring
+*        Bucket Parameters.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11).
+*       portVec  - the list of ports that share the bucket.
+*        pirlData - PIRL resource parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gpirlActivate
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        irlUnit,
+    IN  MV_U32        portVec,
+    IN  GT_PIRL_DATA    *pirlData
+);
+
+/*******************************************************************************
+* gpirlDeactivate
+*
+* DESCRIPTION:
+*       This routine deactivates Ingress Rate Limiting for the given bucket.
+*        It simply removes every ports from the Ingress Rate Resource.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the irlUnit before this function is called.
+*
+* INPUTS:
+*        irlUnit  - bucket to be deactivated
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gpirlDeactivate
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        irlUnit
+);
+
+/*******************************************************************************
+* gpirlUpdateParam
+*
+* DESCRIPTION:
+*       This routine updates IRL Parameter.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11)
+*        pirlData - PIRL resource parameters
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gpirlUpdateParam
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        irlUnit,
+    IN  GT_PIRL_DATA    *pirlData
+);
+
+/*******************************************************************************
+* gpirlReadParam
+*
+* DESCRIPTION:
+*       This routine retrieves IRL Parameter.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11).
+*
+* OUTPUTS:
+*        pirlData - PIRL resource parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gpirlReadParam
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        irlUnit,
+    OUT GT_PIRL_DATA    *pirlData
+);
+
+/*******************************************************************************
+* gpirlUpdatePortVec
+*
+* DESCRIPTION:
+*       This routine updates port list that share the bucket.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11).
+*       portVec  - the list of ports that share the bucket.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gpirlUpdatePortVec
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        irlUnit,
+    IN  MV_U32        portVec
+);
+
+/*******************************************************************************
+* gpirlReadPortVec
+*
+* DESCRIPTION:
+*       This routine retrieves port list that share the bucket.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11).
+*
+* OUTPUTS:
+*       portVec  - the list of ports that share the bucket.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gpirlReadPortVec
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        irlUnit,
+    OUT MV_U32        *portVec
+);
+
+/*******************************************************************************
+* grcGetPirlFcMode
+*
+* DESCRIPTION:
+*       This routine gets Port Ingress Rate Limit Flow Control mode.
+*        When EBSLimitAction is programmed to generate a flow control message,
+*        the deassertion of flow control is controlled by this mode.
+*            GT_PIRL_FC_DEASSERT_EMPTY:
+*                De-assert when the ingress rate resource has become empty
+*            GT_PIRL_FC_DEASSERT_CBS_LIMIT
+*                De-assert when the ingress rate resource has enough room as
+*                specified by the CBSLimit.
+*        Please refer to GT_PIRL_RESOURCE structure for EBSLimitAction and
+*        CBSLimit.
+*
+* INPUTS:
+*       port - logical port number
+*
+* OUTPUTS:
+*        mode - GT_PIRL_FC_DEASSERT enum type
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS grcGetPirlFcMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PIRL_FC_DEASSERT        *mode
+);
+
+/*******************************************************************************
+* gpirlGetIngressRateResource
+*
+* DESCRIPTION:
+*       This routine gets Ingress Rate Limiting Resources assigned to the port.
+*        This vector is used to attach specific counter resources to the physical
+*        port. And the same counter resource can be attached to more than one port.
+*
+* INPUTS:
+*       port   - logical port number
+*
+* OUTPUTS:
+*        resVec - resource vector (bit 0 for irl unit 0, bit 1 for irl unit 1, etc.)
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gpirlGetIngressRateResource
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_U32        *resVec
+);
+
+
+
+/* gtPortStatus.c */
+
+/*******************************************************************************
+* gprtGetPxMode
+*
+* DESCRIPTION:
+*        This routine retrives 4 bits of Px_MODE Configuration value.
+*        If speed and duplex modes are forced, the returned mode value would be
+*        different from the configuration pin values.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - Px_MODE configuration value
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPxMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_U32      *mode
+);
+
+/*******************************************************************************
+* gprtGetMiiInterface
+*
+* DESCRIPTION:
+*        This routine retrives Mii Interface Mode.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Mii Interface is enabled,
+*                  GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetMiiInterface
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gprtGetFdFlowDis
+*
+* DESCRIPTION:
+*        This routine retrives the read time value of the Full Duplex Flow Disable.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Full Duplex Flow Disable.
+*                   GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetFdFlowDis
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gprtGetHdFlowDis
+*
+* DESCRIPTION:
+*        This routine retrives the read time value of the Half Duplex Flow Disable.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Half Duplex Flow Disable.
+*                   GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetHdFlowDis
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *state
+);
+
+/*******************************************************************************
+* gprtGetOutQSize
+*
+* DESCRIPTION:
+*        This routine gets egress queue size counter value.
+*        This counter reflects the current number of Egress buffers switched to
+*        this port. This is the total number of buffers across all four priority
+*        queues.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        count - egress queue size counter value
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetOutQSize
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_U16        *count
+);
+
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtSetSAFiltering
+*
+* DESCRIPTION:
+*        This routine set the Source Address(SA) fitering method.
+*            GT_SA_FILTERING_DISABLE :
+*                no frame will be filtered.
+*            GT_SA_DROP_ON_LOCK :
+*                discard if SA field is not in the ATU's address database.
+*            GT_SA_DROP_ON_UNLOC :
+*                discard if SA field is in the ATU's address database as Static
+*                entry with a PortVec of all zeros.
+*            GT_SA_DROP_TO_CPU :
+*                Ingressing frames will be mapped to the CPU Port if their SA
+*                field is in the ATU's address database as Static entry with a
+*                PortVec of all zeros. Otherwise, the frames will be discarded
+*                if their SA field is not in the ATU's address database or if this
+*                port's bit is not set in the PortVec bits for the frame's SA.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_SA_FILTERING structure
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+*******************************************************************************/
+MV_STATUS gprtSetSAFiltering
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_SA_FILTERING    mode
+);
+
+/*******************************************************************************
+* gprtGetSAFiltering
+*
+* DESCRIPTION:
+*        This routine gets the Source Address(SA) fitering method.
+*            GT_SA_FILTERING_DISABLE :
+*                no frame will be filtered.
+*            GT_SA_DROP_ON_LOCK :
+*                discard if SA field is not in the ATU's address database.
+*            GT_SA_DROP_ON_UNLOC :
+*                discard if SA field is in the ATU's address database as Static
+*                entry with a PortVec of all zeros.
+*            GT_SA_DROP_TO_CPU :
+*                Ingressing frames will be mapped to the CPU Port if their SA
+*                field is in the ATU's address database as Static entry with a
+*                PortVec of all zeros. Otherwise, the frames will be discarded
+*                if their SA field is not in the ATU's address database or if this
+*                port's bit is not set in the PortVec bits for the frame's SA.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_SA_FILTERING structure
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+*******************************************************************************/
+MV_STATUS gprtGetSAFiltering
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_SA_FILTERING    *mode
+);
+
+
+/*******************************************************************************
+* gprtSetARPtoCPU
+*
+* DESCRIPTION:
+*        When ARPtoCPU is set to GT_TRUE, ARP frames are mapped to the CPU port.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE, to map ARP frames to CPU Port,
+*               GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+*******************************************************************************/
+MV_STATUS gprtSetARPtoCPU
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN MV_BOOL    mode
+);
+
+
+/*******************************************************************************
+* gprtGetARPtoCPU
+*
+* DESCRIPTION:
+*        When ARPtoCPU is set to GT_TRUE, ARP frames are mapped to the CPU port.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE, to map ARP frames to CPU Port,
+*               GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+*******************************************************************************/
+MV_STATUS gprtGetARPtoCPU
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT MV_BOOL    *mode
+);
+
+/*******************************************************************************
+* gprtSetEgressFlood
+*
+* DESCRIPTION:
+*       This routine set Egress Flooding Mode.
+*        Frames with unknown DA (Destination Address that is not in ATU database)
+*        generally flood out all the ports. This mode can be used to prevent
+*        those frames from egressing this port as follows:
+*            GT_BLOCK_EGRESS_UNKNOWN
+*                do not egress frame with unknown DA (both unicast and multicast)
+*            GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
+*                do not egress frame with unknown multicast DA
+*            GT_BLOCK_EGRESS_UNKNOWN_UNICAST
+*                do not egress frame with unknown unicast DA
+*            GT_BLOCK_EGRESS_NONE
+*                egress all frames with unknown DA
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_EGRESS_FLOOD structure
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtSetEgressFlood
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    IN  GT_EGRESS_FLOOD      mode
+);
+
+/*******************************************************************************
+* gprtGetEgressFlood
+*
+* DESCRIPTION:
+*       This routine gets Egress Flooding Mode.
+*        Frames with unknown DA (Destination Address that is not in ATU database)
+*        generally flood out all the ports. This mode can be used to prevent
+*        those frames from egressing this port as follows:
+*            GT_BLOCK_EGRESS_UNKNOWN
+*                do not egress frame with unknown DA (both unicast and multicast)
+*            GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
+*                do not egress frame with unknown multicast DA
+*            GT_BLOCK_EGRESS_UNKNOWN_UNICAST
+*                do not egress frame with unknown unicast DA
+*            GT_BLOCK_EGRESS_NONE
+*                egress all frames with unknown DA
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_EGRESS_FLOOD structure
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetEgressFlood
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    OUT GT_EGRESS_FLOOD      *mode
+);
+
+/*******************************************************************************
+* gprtSetPortSched
+*
+* DESCRIPTION:
+*        This routine sets Port Scheduling Mode.
+*        When usePortSched is enablied, this mode is used to select the Queue
+*        controller's scheduling on the port as follows:
+*            GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
+*            GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_PORT_SCHED_MODE enum type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtSetPortSched
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_PORT_SCHED_MODE        mode
+);
+
+/*******************************************************************************
+* gprtGetPortSched
+*
+* DESCRIPTION:
+*        This routine gets Port Scheduling Mode.
+*        When usePortSched is enablied, this mode is used to select the Queue
+*        controller's scheduling on the port as follows:
+*            GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
+*            GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        mode - GT_PORT_SCHED_MODE enum type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPortSched
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PORT_SCHED_MODE        *mode
+);
+
+
+/*******************************************************************************
+* gprtSetProviderTag
+*
+* DESCRIPTION:
+*        This routine sets Provider Tag which indicates the provider tag (Ether
+*        Type) value that needs to be matched to in ingress to determine if a
+*        frame is Provider tagged or not.
+*
+* INPUTS:
+*        port - the logical port number
+*        tag  - Provider Tag (Ether Type)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtSetProviderTag
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  MV_U16        tag
+);
+
+/*******************************************************************************
+* gprtGetProviderTag
+*
+* DESCRIPTION:
+*        This routine gets Provider Tag which indicates the provider tag (Ether
+*        Type) value that needs to be matched to in ingress to determine if a
+*        frame is Provider tagged or not.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        tag  - Provider Tag (Ether Type)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetProviderTag
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_U16        *tag
+);
+
+
+
+/* gtPortRateCtrl.c */
+
+/*******************************************************************************
+* grcSetVidNrlEn
+*
+* DESCRIPTION:
+*       This routine enables/disables VID None Rate Limit (NRL).
+*        When VID NRL is enabled and the determined VID of a frame results in a VID
+*        whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
+*        will not be ingress nor egress rate limited.
+*
+* INPUTS:
+*       port - logical port number.
+*        mode - GT_TRUE to enable VID None Rate Limit
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS grcSetVidNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  MV_BOOL        mode
+);
+
+/*******************************************************************************
+* grcGetVidNrlEn
+*
+* DESCRIPTION:
+*       This routine gets VID None Rate Limit (NRL) mode.
+*        When VID NRL is enabled and the determined VID of a frame results in a VID
+*        whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
+*        will not be ingress nor egress rate limited.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable VID None Rate Limit
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS grcGetVidNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* grcSetSaNrlEn
+*
+* DESCRIPTION:
+*       This routine enables/disables SA None Rate Limit (NRL).
+*        When SA NRL is enabled and the source address of a frame results in a ATU
+*        hit where the SA's MAC address returns an EntryState that indicates Non
+*        Rate Limited, then the frame will not be ingress nor egress rate limited.
+*
+* INPUTS:
+*       port - logical port number.
+*        mode - GT_TRUE to enable SA None Rate Limit
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS grcSetSaNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  MV_BOOL        mode
+);
+
+/*******************************************************************************
+* grcGetSaNrlEn
+*
+* DESCRIPTION:
+*       This routine gets SA None Rate Limit (NRL) mode.
+*        When SA NRL is enabled and the source address of a frame results in a ATU
+*        hit where the SA's MAC address returns an EntryState that indicates Non
+*        Rate Limited, then the frame will not be ingress nor egress rate limited.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable SA None Rate Limit
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS grcGetSaNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* grcSetDaNrlEn
+*
+* DESCRIPTION:
+*       This routine enables/disables DA None Rate Limit (NRL).
+*        When DA NRL is enabled and the destination address of a frame results in
+*        a ATU hit where the DA's MAC address returns an EntryState that indicates
+*        Non Rate Limited, then the frame will not be ingress nor egress rate
+*        limited.
+*
+* INPUTS:
+*       port - logical port number.
+*        mode - GT_TRUE to enable DA None Rate Limit
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS grcSetDaNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  MV_BOOL        mode
+);
+
+/*******************************************************************************
+* grcGetDaNrlEn
+*
+* DESCRIPTION:
+*       This routine gets SA None Rate Limit (NRL) mode.
+*        When DA NRL is enabled and the destination address of a frame results in
+*        a ATU hit where the DA's MAC address returns an EntryState that indicates
+*        Non Rate Limited, then the frame will not be ingress nor egress rate
+*        limited.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable DA None Rate Limit
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS grcGetDaNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* grcSetELimitMode
+*
+* DESCRIPTION:
+*       This routine sets Egress Rate Limit counting mode.
+*        The supported modes are as follows:
+*            GT_PIRL_ELIMIT_FRAME -
+*                Count the number of frames
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes:
+*                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+*            GT_PIRL_ELIMIT_LAYER2 -
+*                Count all Layer 2 bytes: Frame's DA to CRC
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes:
+*                Frame's DA to CRC - 18 - 4 (if frame is tagged)
+*
+* INPUTS:
+*       port - logical port number
+*        mode - GT_PIRL_ELIMIT_MODE enum type
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*        GT_PIRL_ELIMIT_FRAME mode is supported by only a few devices.
+*        Please refer to the device datasheet for details.
+*
+*******************************************************************************/
+MV_STATUS grcSetELimitMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_PIRL_ELIMIT_MODE        mode
+);
+
+/*******************************************************************************
+* grcGetELimitMode
+*
+* DESCRIPTION:
+*       This routine gets Egress Rate Limit counting mode.
+*        The supported modes are as follows:
+*            GT_PIRL_ELIMIT_FRAME -
+*                Count the number of frames
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes:
+*                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+*            GT_PIRL_ELIMIT_LAYER2 -
+*                Count all Layer 2 bytes: Frame's DA to CRC
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes:
+*                Frame's DA to CRC - 18 - 4 (if frame is tagged)
+*
+* INPUTS:
+*       port - logical port number
+*
+* OUTPUTS:
+*        mode - GT_PIRL_ELIMIT_MODE enum type
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*        GT_PIRL_ELIMIT_FRAME mode is supported by only a few devices.
+*        Please refer to the device datasheet for details.
+*
+*******************************************************************************/
+MV_STATUS grcGetELimitMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PIRL_ELIMIT_MODE        *mode
+);
+
+/*******************************************************************************
+* grcSetRsvdNrlEn
+*
+* DESCRIPTION:
+*       This routine sets Reserved Non Rate Limit.
+*        When this feature is enabled, frames that match the requirements of the
+*        Rsvd2Cpu bit below will also be considered to be ingress and egress non
+*        rate limited.
+*
+* INPUTS:
+*       en - GT_TRUE to enable Reserved Non Rate Limit,
+*             GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS grcSetRsvdNrlEn
+(
+    IN  GT_QD_DEV *dev,
+    IN  MV_BOOL   en
+);
+
+/*******************************************************************************
+* grcGetRsvdNrlEn
+*
+* DESCRIPTION:
+*       This routine gets Reserved Non Rate Limit.
+*        When this feature is enabled, frames that match the requirements of the
+*        Rsvd2Cpu bit below will also be considered to be ingress and egress non
+*        rate limited.
+*
+* INPUTS:
+*       en - GT_TRUE to enable Reserved Non Rate Limit,
+*             GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS grcGetRsvdNrlEn
+(
+    IN  GT_QD_DEV *dev,
+    OUT MV_BOOL   *en
+);
+
+
+/* gtPortRmon.c */
+
+/*******************************************************************************
+* gstatsGetRealtimePortCounter
+*
+* DESCRIPTION:
+*        This routine gets a specific realtime counter of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gstatsGetRealtimePortCounter
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS3    counter,
+    OUT MV_U32            *statsData
+);
+
+
+/* gtQosMap.c */
+
+/*******************************************************************************
+* gqosSetVIDFPriOverride
+*
+* DESCRIPTION:
+*        This routine sets VID Frame Priority Override. When this feature is enabled,
+*        VID Frame priority overrides can occur on this port.
+*        VID Frame priority override occurs when the determined VID of a frame
+*        results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
+*        When this occurs the VIDFPri value assigned to the frame's VID (in the
+*        VTU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new VIDFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for VID Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosSetVIDFPriOverride
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gqosGetVIDFPriOverride
+*
+* DESCRIPTION:
+*        This routine gets VID Frame Priority Override. When this feature is enabled,
+*        VID Frame priority overrides can occur on this port.
+*        VID Frame priority override occurs when the determined VID of a frame
+*        results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
+*        When this occurs the VIDFPri value assigned to the frame's VID (in the
+*        VTU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new VIDFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for VID Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosGetVIDFPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* gqosSetSAFPriOverride
+*
+* DESCRIPTION:
+*        This routine sets Source Address(SA) Frame Priority Override.
+*        When this feature is enabled, SA Frame priority overrides can occur on
+*        this port.
+*        SA ATU Frame priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's SA (in the
+*        ATU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for SA Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosSetSAFPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gqosGetSAFPriOverride
+*
+* DESCRIPTION:
+*        This routine gets Source Address(SA) Frame Priority Override.
+*        When this feature is enabled, SA Frame priority overrides can occur on
+*        this port.
+*        SA ATU Frame priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's SA (in the
+*        ATU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for SA Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosGetSAFPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* gqosSetDAFPriOverride
+*
+* DESCRIPTION:
+*        This routine sets Destination Address(DA) Frame Priority Override.
+*        When this feature is enabled, DA Frame priority overrides can occur on
+*        this port.
+*        DA ATU Frame priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's DA (in the
+*        ATU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for DA Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosSetDAFPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gqosGetDAFPriOverride
+*
+* DESCRIPTION:
+*        This routine gets Destination Address(DA) Frame Priority Override.
+*        When this feature is enabled, DA Frame priority overrides can occur on
+*        this port.
+*        DA ATU Frame priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's DA (in the
+*        ATU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for DA Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosGetDAFPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* gqosSetVIDQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets VID Queue Priority Override. When this feature is enabled,
+*        VID Queue priority overrides can occur on this port.
+*        VID Queue priority override occurs when the determined VID of a frame
+*        results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
+*        When this occurs the VIDQPri value assigned to the frame's VID (in the
+*        VTU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new VIDQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for VID Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosSetVIDQPriOverride
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gqosGetVIDQPriOverride
+*
+* DESCRIPTION:
+*        This routine gets VID Queue Priority Override. When this feature is enabled,
+*        VID Queue priority overrides can occur on this port.
+*        VID Queue priority override occurs when the determined VID of a frame
+*        results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
+*        When this occurs the VIDQPri value assigned to the frame's VID (in the
+*        VTU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new VIDQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for VID Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosGetVIDQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* gqosSetSAQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets Source Address(SA) Queue Priority Override.
+*        When this feature is enabled, SA Queue priority overrides can occur on
+*        this port.
+*        SA ATU Queue priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's SA (in the
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for SA Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosSetSAQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gqosGetSAQPriOverride
+*
+* DESCRIPTION:
+*        This routine gets Source Address(SA) Queue Priority Override.
+*        When this feature is enabled, SA Queue priority overrides can occur on
+*        this port.
+*        SA ATU Queue priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's SA (in the
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for SA Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosGetSAQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* gqosSetDAQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets Destination Address(DA) Queue Priority Override.
+*        When this feature is enabled, DA Queue priority overrides can occur on
+*        this port.
+*        DA ATU Queue priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's DA (in the
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for DA Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosSetDAQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gqosGetDAQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets Destination Address(DA) Queue Priority Override.
+*        When this feature is enabled, DA Queue priority overrides can occur on
+*        this port.
+*        DA ATU Queue priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's DA (in the
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for DA Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosGetDAQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* gqosSetARPQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets ARP Queue Priority Override.
+*        When this feature is enabled, ARP Queue priority overrides can occur on
+*        this port.
+*        ARP Queue priority override occurs for all ARP frames.
+*        When this occurs, the frame's previously determined egress queue priority
+*        will be overwritten with ArpQPri.
+*        If the frame egresses tagged the priority in the frame will not
+*        be modified. When used, the two bits of the ArpQPri priority determine the
+*        egress queue the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for ARP Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosSetARPQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gqosGetARPQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets ARP Queue Priority Override.
+*        When this feature is enabled, ARP Queue priority overrides can occur on
+*        this port.
+*        ARP Queue priority override occurs for all ARP frames.
+*        When this occurs, the frame's previously determined egress queue priority
+*        will be overwritten with ArpQPri.
+*        If the frame egresses tagged the priority in the frame will not
+*        be modified. When used, the two bits of the ArpQPri priority determine the
+*        egress queue the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for ARP Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosGetARPQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+
+/*******************************************************************************
+* gqosSetQPriValue
+*
+* DESCRIPTION:
+*       This routine sets Queue priority value to used when forced.
+*        When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
+*        are mapped to the priority queue defined in this value, unless a VTU, SA,
+*        DA or ARP priority override occurs. The Frame's priority (FPri) is not
+*        effected by this value.
+*
+* INPUTS:
+*       port - the logical port number.
+*       pri  - Queue priority value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if pri > 3
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gqosSetQPriValue
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    IN  MV_U8      pri
+);
+
+/*******************************************************************************
+* gqosGetQPriValue
+*
+* DESCRIPTION:
+*       This routine gets Queue priority value to used when forced.
+*        When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
+*        are mapped to the priority queue defined in this value, unless a VTU, SA,
+*        DA or ARP priority override occurs. The Frame's priority (FPri) is not
+*        effected by this value.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       pri  - Queue priority value
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gqosGetQPriValue
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT MV_U8      *pri
+);
+
+/*******************************************************************************
+* gqosSetForceQPri
+*
+* DESCRIPTION:
+*       This routine enables/disables forcing Queue priority.
+*        When ForceQPri is disabled, normal priority queue mapping is used on all
+*        ingressing frames entering this port. When it's enabled, all frames
+*        entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
+*        a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
+*        is not effected by this feature.
+*
+* INPUTS:
+*       port - the logical port number.
+*       en   - GT_TRUE, to force Queue Priority,
+*               GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gqosSetForceQPri
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    IN  MV_BOOL    en
+);
+
+/*******************************************************************************
+* gqosGetForceQPri
+*
+* DESCRIPTION:
+*       This routine checks if forcing Queue priority is enabled.
+*        When ForceQPri is disabled, normal priority queue mapping is used on all
+*        ingressing frames entering this port. When it's enabled, all frames
+*        entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
+*        a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
+*        is not effected by this feature.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       en   - GT_TRUE, to force Queue Priority,
+*               GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gqosGetForceQPri
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT MV_BOOL    *en
+);
+
+/*******************************************************************************
+* gqosSetDefFPri
+*
+* DESCRIPTION:
+*       This routine sets the default frame priority (0 ~ 7).
+*        This priority is used as the default frame priority (FPri) to use when
+*        no other priority information is available.
+*
+* INPUTS:
+*       port - the logical port number
+*       pri  - default frame priority
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if pri > 7
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gqosSetDefFPri
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    IN  MV_U8      pri
+);
+
+/*******************************************************************************
+* gqosGetDefFPri
+*
+* DESCRIPTION:
+*       This routine gets the default frame priority (0 ~ 7).
+*        This priority is used as the default frame priority (FPri) to use when
+*        no other priority information is available.
+*
+* INPUTS:
+*       port - the logical port number
+*
+* OUTPUTS:
+*       pri  - default frame priority
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gqosGetDefFPri
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT MV_U8      *pri
+);
+
+
+/*******************************************************************************
+* gqosSetArpQPri
+*
+* DESCRIPTION:
+*       This routine sets ARP queue Priority to use for ARP QPri Overridden
+*        frames. When a ARP frame is received on a por tthat has its ARP
+*        QPriOVerride is enabled, the QPri assigned to the frame comes from
+*        this value
+*
+* INPUTS:
+*       pri - ARP Queue Priority (0 ~ 3)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if pri > 3
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gqosSetArpQPri
+(
+    IN  GT_QD_DEV *dev,
+    IN  MV_U8     pri
+);
+
+
+/*******************************************************************************
+* gqosGetArpQPri
+*
+* DESCRIPTION:
+*       This routine gets ARP queue Priority to use for ARP QPri Overridden
+*        frames. When a ARP frame is received on a por tthat has its ARP
+*        QPriOVerride is enabled, the QPri assigned to the frame comes from
+*        this value
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       pri - ARP Queue Priority (0 ~ 3)
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gqosGetArpQPri
+(
+    IN  GT_QD_DEV *dev,
+    OUT MV_U8     *pri
+);
+
+
+/* gtSysCtrl.c */
+
+/*******************************************************************************
+* gsysSetUsePortSchedule
+*
+* DESCRIPTION:
+*       This routine sets per port scheduling mode
+*
+* INPUTS:
+*       en - GT_TRUE enables per port scheduling,
+*             GT_FALSE disable.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetUsePortSchedule
+(
+    IN  GT_QD_DEV *dev,
+    IN  MV_BOOL   en
+);
+
+/*******************************************************************************
+* gsysGetUsePortSchedule
+*
+* DESCRIPTION:
+*       This routine gets per port scheduling mode
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE enables per port scheduling,
+*             GT_FALSE disable.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetUsePortSchedule
+(
+    IN  GT_QD_DEV *dev,
+    OUT MV_BOOL   *en
+);
+
+/*******************************************************************************
+* gsysSetOldHader
+*
+* DESCRIPTION:
+*       This routine sets Egress Old Header.
+*        When this feature is enabled and frames are egressed with a Marvell Header,
+*        the format of the Header is slightly modified to be backwards compatible
+*        with previous devices that used the original Header. Specifically, bit 3
+*        of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
+*        is available in the Header.
+*
+* INPUTS:
+*       en - GT_TRUE to enable Old Header Mode,
+*             GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetOldHader
+(
+    IN  GT_QD_DEV *dev,
+    IN  MV_BOOL   en
+);
+
+/*******************************************************************************
+* gsysGetOldHader
+*
+* DESCRIPTION:
+*       This routine gets Egress Old Header.
+*        When this feature is enabled and frames are egressed with a Marvell Header,
+*        the format of the Header is slightly modified to be backwards compatible
+*        with previous devices that used the original Header. Specifically, bit 3
+*        of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
+*        is available in the Header.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE to enable Old Header Mode,
+*             GT_FALSE to disable
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetOldHader
+(
+    IN  GT_QD_DEV *dev,
+    OUT MV_BOOL   *en
+);
+
+/*******************************************************************************
+* gsysSetRecursiveStrippingDisable
+*
+* DESCRIPTION:
+*       This routine determines if recursive tag stripping feature needs to be
+*        disabled.
+*
+* INPUTS:
+*       en - GT_TRUE to disable Recursive Tag Stripping,
+*             GT_FALSE to enable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetRecursiveStrippingDisable
+(
+    IN  GT_QD_DEV *dev,
+    IN  MV_BOOL   en
+);
+
+/*******************************************************************************
+* gsysGetRecursiveStrippingDisable
+*
+* DESCRIPTION:
+*       This routine checks if recursive tag stripping feature is disabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE, if Recursive Tag Stripping is disabled,
+*             GT_FALSE, otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetRecursiveStrippingDisable
+(
+    IN  GT_QD_DEV *dev,
+    OUT MV_BOOL   *en
+);
+
+/*******************************************************************************
+* gsysSetCPUPort
+*
+* DESCRIPTION:
+*       This routine sets CPU Port where Rsvd2Cpu frames and IGMP/MLD Snooped
+*        frames are destined.
+*
+* INPUTS:
+*       cpuPort - CPU Port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetCPUPort
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  cpuPort
+);
+
+/*******************************************************************************
+* gsysGetCPUPort
+*
+* DESCRIPTION:
+*       This routine gets CPU Port where Rsvd2Cpu frames and IGMP/MLD Snooped
+*        frames are destined.
+*
+* INPUTS:
+*       cpuPort - CPU Port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetCPUPort
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_LPORT  *cpuPort
+);
+
+
+
+/* gtSysStatus.c */
+
+/*******************************************************************************
+* gsysGetFreeQSize
+*
+* DESCRIPTION:
+*       This routine gets Free Queue Counter. This counter reflects the
+*        current number of unalllocated buffers available for all the ports.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       count - Free Queue Counter
+*
+* RETURNS:
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gsysGetFreeQSize
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U16         *count
+);
+
+/*******************************************************************************
+                New APIs in DSDT 2.6
+*******************************************************************************/
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+* gfdbSetPortAtuLearnLimit
+*
+* DESCRIPTION:
+*       Port's auto learning limit. When the limit is non-zero value, the number
+*        of MAC addresses that can be learned on this port are limited to the value
+*        specified in this API. When the learn limit has been reached any frame
+*        that ingresses this port with a source MAC address not already in the
+*        address database that is associated with this port will be discarded.
+*        Normal auto-learning will resume on the port as soon as the number of
+*        active unicast MAC addresses associated to this port is less than the
+*        learn limit.
+*        CPU directed ATU Load, Purge, or Move will not have any effect on the
+*        learn limit.
+*        This feature is disabled when the limit is zero.
+*        The following care is needed when enabling this feature:
+*            1) disable learning on the ports
+*            2) flush all non-static addresses in the ATU
+*            3) define the desired limit for the ports
+*            4) re-enable learing on the ports
+*
+* INPUTS:
+*       port  - logical port number
+*       limit - auto learning limit ( 0 ~ 255 )
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbSetPortAtuLearnLimit
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    IN  MV_U32       limit
+);
+
+
+/*******************************************************************************
+* gfdbGetPortAtuLearnCnt
+*
+* DESCRIPTION:
+*       Read the current number of active unicast MAC addresses associated with
+*        the given port. This counter (LearnCnt) is held at zero if learn limit
+*        (gfdbSetPortAtuLearnLimit API) is set to zero.
+*
+* INPUTS:
+*       port  - logical port number
+*
+* OUTPUTS:
+*       count - current auto learning count
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbGetPortAtuLearnCnt
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    IN  MV_U32       *count
+);
+
+/*******************************************************************************
+* gfdbGetAtuAllCount
+*
+* DESCRIPTION:
+*       Counts all entries in the Address Translation Unit.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       count - number of valid entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gfdbGetAtuAllCount
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U32         *count
+);
+
+/*******************************************************************************
+* gfdbGetAtuAllCountInDBNum
+*
+* DESCRIPTION:
+*       Counts all entries in the defined FID (or DBNum).
+*
+* INPUTS:
+*       dbNum - DBNum of FID
+*
+* OUTPUTS:
+*       count - number of valid entries in FID (or DBNum).
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gfdbGetAtuAllCountInDBNum
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32         dbNum,
+    OUT MV_U32         *count
+);
+
+/*******************************************************************************
+* gfdbGetAtuDynamicCountInDBNum
+*
+* DESCRIPTION:
+*       Counts all non-static entries in the defined FID (or DBNum).
+*
+* INPUTS:
+*       dbNum - DBNum or FID
+*
+* OUTPUTS:
+*       count - number of valid non-static entries in FID (or DBNum).
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gfdbGetAtuDynamicCountInDBNum
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32         dbNum,
+    OUT MV_U32         *count
+);
+
+
+/* gtBrgStu.c */
+
+/*******************************************************************************
+* gstuGetEntryCount
+*
+* DESCRIPTION:
+*       Gets the current number of valid entries in the STU table
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       numEntries - number of STU entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gstuGetEntryCount
+(
+    IN  GT_QD_DEV *dev,
+    OUT MV_U32    *numEntries
+);
+
+/*******************************************************************************
+* gstuGetEntryFirst
+*
+* DESCRIPTION:
+*       Gets first lexicographic entry from the STU.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       stuEntry - find the first valid STU entry.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - table is empty.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gstuGetEntryFirst
+(
+    IN  GT_QD_DEV       *dev,
+    OUT GT_STU_ENTRY    *stuEntry
+);
+
+/*******************************************************************************
+* gstuGetEntryNext
+*
+* DESCRIPTION:
+*       Gets next lexicographic STU entry from the specified SID.
+*
+* INPUTS:
+*       stuEntry - the SID to start the search.
+*
+* OUTPUTS:
+*       stuEntry - next STU entry.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gstuGetEntryNext
+(
+    IN  GT_QD_DEV       *dev,
+    INOUT GT_STU_ENTRY  *stuEntry
+);
+
+/*******************************************************************************
+* gstuFindSidEntry
+*
+* DESCRIPTION:
+*       Find STU entry for a specific SID, it will return the entry, if found,
+*       along with its associated data
+*
+* INPUTS:
+*       stuEntry - contains the SID to searche for
+*
+* OUTPUTS:
+*       found    - GT_TRUE, if the appropriate entry exists.
+*       stuEntry - the entry parameters.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no such entry.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gstuFindSidEntry
+(
+    IN  GT_QD_DEV       *dev,
+    INOUT GT_STU_ENTRY  *stuEntry,
+    OUT MV_BOOL         *found
+);
+
+/*******************************************************************************
+* gstuAddEntry
+*
+* DESCRIPTION:
+*       Creates or update the entry in STU table based on user input.
+*
+* INPUTS:
+*       stuEntry    - stu entry to insert to the STU.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK             - on success
+*       GT_FAIL           - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gstuAddEntry
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_STU_ENTRY    *stuEntry
+);
+
+/*******************************************************************************
+* gstuDelEntry
+*
+* DESCRIPTION:
+*       Deletes STU entry specified by user.
+*
+* INPUTS:
+*       stuEntry - the STU entry to be deleted
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gstuDelEntry
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_STU_ENTRY     *stuEntry
+);
+
+
+/* gtCCPVT.c */
+
+/*******************************************************************************
+* gpvtInitialize
+*
+* DESCRIPTION:
+*       This routine initializes the PVT Table to all one's (initial state)
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gpvtInitialize
+(
+    IN  GT_QD_DEV     *dev
+);
+
+/*******************************************************************************
+* gpvtWritePVTData
+*
+* DESCRIPTION:
+*       This routine write Cross Chip Port Vlan Data.
+*        Cross chip Port VLAN Data used as a bit mask to limit where cross chip
+*        frames can egress (in chip Port VLANs are masked using gvlnSetPortVlanPorts
+*        API). Cross chip frames are Forward frames that ingress a DSA or Ether
+*        Type DSA port (see gprtSetFrameMode API). Bit 0 is a mask for port 0,
+*        bit 1 for port 1, etc. When a port's mask bit is one, frames are allowed
+*        to egress that port on this device. When a port's mask bit is zero,
+*        frames are not allowed to egress that port on this device.
+*
+*        The Cross Chip Port VLAN Table is accessed by ingressing frames based
+*        upon the original source port of the frame using the Forward frame's DSA tag
+*        fields Src_Dev, Src_Port/Src_Trunk and Src_Is_Trunk. The 1 entry of the 512
+*        that is accessed by the frame is:
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 0:
+*                If Src_Is_Trunk = 0   Src_Dev[4:0], Src_Port[3:0]119
+*                If Src_Is_Trunk = 1   Device Number (global offset 0x1C), Src_Trunk[3:0]
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 1:
+*                If Src_Is_Trunk = 0   Src_Dev[3:0], Src_Port[4:0]120
+*                If Src_Is_Trunk = 1   Device Number[3:0], Src_Trunk[4:0]
+*
+*        Cross chip port VLANs with Trunks are supported in the table where this
+*        device's entries would be stored (defined by this device's Device Number).
+*        This portion of the table is available for Trunk entries because this device's
+*        port VLAN mappings to ports inside this device are masked by the port's
+*        VLAN Table (see gvlnSetPortVlanPorts API).
+*
+*
+* INPUTS:
+*        pvtPointer - pointer to the desired entry of PVT (0 ~ 511)
+*        pvtData    - Cross Chip Port Vlan Data
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gpvtWritePVTData
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        pvtPointer,
+    IN  MV_U32        pvtData
+);
+
+/*******************************************************************************
+* gpvtReadPVTData
+*
+* DESCRIPTION:
+*       This routine reads Cross Chip Port Vlan Data.
+*        Cross chip Port VLAN Data used as a bit mask to limit where cross chip
+*        frames can egress (in chip Port VLANs are masked using gvlnSetPortVlanPorts
+*        API). Cross chip frames are Forward frames that ingress a DSA or Ether
+*        Type DSA port (see gprtSetFrameMode API). Bit 0 is a mask for port 0,
+*        bit 1 for port 1, etc. When a port's mask bit is one, frames are allowed
+*        to egress that port on this device. When a port's mask bit is zero,
+*        frames are not allowed to egress that port on this device.
+*
+*        The Cross Chip Port VLAN Table is accessed by ingressing frames based
+*        upon the original source port of the frame using the Forward frame's DSA tag
+*        fields Src_Dev, Src_Port/Src_Trunk and Src_Is_Trunk. The 1 entry of the 512
+*        that is accessed by the frame is:
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 0:
+*                If Src_Is_Trunk = 0   Src_Dev[4:0], Src_Port[3:0]119
+*                If Src_Is_Trunk = 1   Device Number (global offset 0x1C), Src_Trunk[3:0]
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 1:
+*                If Src_Is_Trunk = 0   Src_Dev[3:0], Src_Port[4:0]120
+*                If Src_Is_Trunk = 1   Device Number[3:0], Src_Trunk[4:0]
+*
+*        Cross chip port VLANs with Trunks are supported in the table where this
+*        device's entries would be stored (defined by this device's Device Number).
+*        This portion of the table is available for Trunk entries because this device's
+*        port VLAN mappings to ports inside this device are masked by the port's
+*        VLAN Table (see gvlnSetPortVlanPorts API).
+*
+*
+* INPUTS:
+*        pvtPointer - pointer to the desired entry of PVT (0 ~ 511)
+*
+* OUTPUTS:
+*        pvtData    - Cross Chip Port Vlan Data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gpvtReadPVTData
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        pvtPointer,
+    OUT MV_U32        *pvtData
+);
+
+
+/* gtEvents.c */
+
+/*******************************************************************************
+* geventGetDevIntStatus
+*
+* DESCRIPTION:
+*         Check to see which device interrupts (WatchDog, JamLimit, Duplex Mismatch, and
+*        SERDES Link Int) have occurred.
+*
+* INPUTS:
+*       intType - the type of interrupt which causes an interrupt.
+*                  any combination of
+*                    GT_DEV_INT_WATCHDOG,
+*                    GT_DEV_INT_JAMLIMIT,
+*                    GT_DEV_INT_DUPLEX_MISMATCH,
+*                    GT_DEV_INT_SERDES_LINK
+*        port    - logical port where GT_DEV_INT_DUPLEX_MISMATCH occurred.
+*                  valid only if GT_DEV_INT_DUPLEX_MISMATCH is set in intType.
+*        linkInt - SERDES port list where GT_DEV_INT_SERDES_LINK interrupt is
+*                  asserted. It's in vector format, Bit 10 is for port 10,
+*                  Bit 9 is for port 9, etc.
+*                  valid only if GT_DEV_INT_SERDES_LINK bit is set in intType.
+*                  These bits are only valid of the port that is in 1000Base-X mode.
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK - on success
+*         GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS geventGetDevIntStatus
+(
+    IN  GT_QD_DEV             *dev,
+    OUT GT_DEV_INT_STATUS    *devIntStatus
+);
+
+/*******************************************************************************
+* geventSetAgeOutIntEn
+*
+* DESCRIPTION:
+*        Interrupt on Age Out. When aging is enabled, all non-static address
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this
+*        port is aged out, an AgeOutViolation will be captured for that entry.
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_TRUE to enable Age Out Interrupt,
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS geventSetAgeOutIntEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  MV_BOOL        mode
+);
+
+/*******************************************************************************
+* geventGetAgeOutIntEn
+*
+* DESCRIPTION:
+*        Interrupt on Age Out. When aging is enabled, all non-static address
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this
+*        port is aged out, an AgeOutViolation will be captured for that entry.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        mode - GT_TRUE, if Age Out Interrupt is enabled
+*               GT_FALUSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS geventGetAgeOutIntEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* geventSetOverLimitInt
+*
+* DESCRIPTION:
+*        This routine enables/disables Over Limit Interrupt for a port.
+*        If it's enabled, an ATU Miss violation will be generated when port auto
+*        learn reached the limit(refer to gfdbGetPortAtuLimitReached API).
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_TRUE to enable Over Limit Interrupt,
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS geventSetOverLimitInt
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  MV_BOOL        mode
+);
+
+/*******************************************************************************
+* geventGetOverLimitInt
+*
+* DESCRIPTION:
+*        This routine enables/disables Over Limit Interrupt for a port.
+*        If it's enabled, an ATU Miss violation will be generated when port auto
+*        learn reached the limit(refer to gfdbSetPortAtuLearnLimit API).
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable Over Limit Interrupt,
+*               GT_FALUSE to disable
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS geventGetOverLimitInt
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* geventGetPortAtuLimitReached
+*
+* DESCRIPTION:
+*       This routine checks if learn limit has been reached.
+*        When it reached, the port can no longer auto learn any more MAC addresses
+*        because the address learn limit set on this port has been reached.
+*
+* INPUTS:
+*       port  - logical port number
+*
+* OUTPUTS:
+*       limit - GT_TRUE, if limit has been reached
+*                GT_FALSE, otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*
+*******************************************************************************/
+MV_STATUS geventGetPortAtuLimitReached
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    IN  MV_BOOL       *limit
+);
+
+/*******************************************************************************
+* eventSetDevInt
+*
+* DESCRIPTION:
+*        Device Interrupt.
+*        The following device interrupts are supported:
+*            GT_DEV_INT_WATCHDOG    -
+*                WatchDog event interrupt (WatchDog event can be configured with
+*                gwdSetEvent API)
+*            GT_DEV_INT_JAMLIMIT    -
+*                any of the ports detect an Ingress Jam Limit violation
+*                (see gprtSetPauseLimitIn API)
+*            GT_DEV_INT_DUPLEX_MISMATCH -
+*                any of the ports detect a duplex mismatch (i.e., the local port is
+*                in half duplex mode while the link partner is in full duplex mode)
+*            GT_DEV_INT_SERDES_LINK -
+*                SERDES link chage interrupt.
+*                An interrupt occurs when a SERDES port changes link status
+*                (link up or link down)
+*
+*        If any of the above events is enabled, GT_DEVICE_INT interrupt will
+*        be asserted by the enabled event when GT_DEV_INT is enabled with
+*        eventSetActive API.
+*
+* INPUTS:
+*        devInt - GT_DEV_INT
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS eventSetDevInt
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_DEV_EVENT    *devInt
+);
+
+/*******************************************************************************
+* gwdSetEvent
+*
+* DESCRIPTION:
+*        Watch Dog Event.
+*        The following Watch Dog events are supported:
+*            GT_WD_QC  - Queue Controller Watch Dog enable.
+*                        When enabled, the QC's watch dog circuit checks for link
+*                        list errors and any errors found in the QC.
+*            GT_WD_EGRESS - Egress Watch Dog enable.
+*                        When enabled, each port's egress circuit checks for problems
+*                        between the port and the Queue Controller.
+*            GT_WD_FORCE - Force a Watch Dog event.
+*
+*        If any of the above events is enabled, GT_DEVICE_INT interrupt will
+*        be asserted by the enabled WatchDog event when GT_DEV_INT_WATCHDOG is
+*        enabled with eventSetDevActive API and GT_DEV_INT is enabled with
+*        eventSetActive API.
+*
+* INPUTS:
+*        wdEvent - Watch Dog Events
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gwdSetEvent
+(
+    IN  GT_QD_DEV    *dev,
+    IN  MV_U32        wdEvent
+);
+
+/*******************************************************************************
+* gwdSetSWResetOnWD
+*
+* DESCRIPTION:
+*        SWReset on Watch Dog Event.
+*        When this feature is enabled, any enabled watch dog event (gwdSetEvent API)
+*        will automatically reset the switch core's datapath just as if gsysSwReset
+*        API is called.
+*
+*        The Watch Dog History (gwdGetHistory API) won't be cleared by this
+*        automatic SWReset. This allows the user to know if any watch dog event
+*        ever occurred even if the swich is configured to automatically recover
+*        from a watch dog.
+*
+*        When this feature is disabled, enabled watch dog events will not cause a
+*        SWReset.
+*
+* INPUTS:
+*        en   - GT_TRUE to enable SWReset on WD
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gwdSetSWResetOnWD
+(
+    IN  GT_QD_DEV    *dev,
+    IN  MV_BOOL        en
+);
+
+/*******************************************************************************
+* gwdGetSWResetOnWD
+*
+* DESCRIPTION:
+*        SWReset on Watch Dog Event.
+*        When this feature is enabled, any enabled watch dog event (gwdSetEvent API)
+*        will automatically reset the switch core's datapath just as if gsysSwReset
+*        API is called.
+*
+*        The Watch Dog History (gwdGetHistory API) won't be cleared by this
+*        automatic SWReset. This allows the user to know if any watch dog event
+*        ever occurred even if the swich is configured to automatically recover
+*        from a watch dog.
+*
+*        When this feature is disabled, enabled watch dog events will not cause a
+*        SWReset.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en   - GT_TRUE, if SWReset on WD is enabled
+*               GT_FALUSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gwdGetSWResetOnWD
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL        *en
+);
+
+/*******************************************************************************
+* gwdGetHistory
+*
+* DESCRIPTION:
+*        This routine retrieves Watch Dog history. They are
+*
+*        wdEvent -
+*            When it's set to GT_TRUE, some enabled Watch Dog event occurred.
+*            The following events are possible:
+*                QC WatchDog Event (GT_WD_QC)
+*                Egress WatchDog Event (GT_WD_EGRESS)
+*                Forced WatchDog Event (GT_WD_FORCE)
+*        egressEvent -
+*            If any port's egress logic detects an egress watch dog issue,
+*            this field is set to GT_TRUE, regardless of the enabling GT_WD_EGRESS
+*            event.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        history - GT_WD_EVENT_HISTORY structure
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gwdGetHistory
+(
+    IN  GT_QD_DEV            *dev,
+    OUT GT_WD_EVENT_HISTORY    *history
+);
+
+
+/* gtPIRL2.c */
+
+/*******************************************************************************
+* gpirl2WriteResource
+*
+* DESCRIPTION:
+*       This routine writes resource bucket parameters to the given resource
+*        of the port.
+*
+* INPUTS:
+*       port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
+*        pirlData - PIRL resource parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gpirl2WriteResource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  MV_U32        irlRes,
+    IN  GT_PIRL2_DATA    *pirlData
+);
+
+/*******************************************************************************
+* gpirl2ReadResource
+*
+* DESCRIPTION:
+*       This routine retrieves IRL Parameter.
+*
+* INPUTS:
+*       port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
+*
+* OUTPUTS:
+*        pirlData - PIRL resource parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gpirl2ReadResource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  MV_U32        irlRes,
+    OUT GT_PIRL2_DATA    *pirlData
+);
+
+/*******************************************************************************
+* gpirl2DisableResource
+*
+* DESCRIPTION:
+*       This routine disables Ingress Rate Limiting for the given bucket.
+*
+* INPUTS:
+*       port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gpirl2DisableResource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  MV_U32        irlRes
+);
+
+
+/* gtPolicy.c */
+
+/*******************************************************************************
+* gprtSetPolicy
+*
+* DESCRIPTION:
+*       This routine sets the Policy for ports.
+*        Supported Policies are defined as GT_FRAME_POLICY as follows:
+*            FRAME_POLICY_NONE    - normal frame switching
+*            FRAME_POLICY_MIRROR  - mirror (copy) frame to MirrorDest port
+*            FRAME_POLICY_TRAP    - trap(re-direct) frame to the CPUDest port
+*            FRAME_POLICY_DISCARD - discard(filter) the frame
+*        Supported Policy types are defined as GT_POLICY_TYPE:
+*            POLICY_TYPE_DA - DA Policy Mapping
+*                DA Policy Mapping occurs when the DA of a frame is contained in
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_SA - SA Policy Mapping
+*                SA Policy Mapping occurs when the SA of a frame is contained in
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_VTU - VTU Policy Mapping
+*                VTU Policy Mapping occurs when the VID of a frame is contained in
+*                the VTU database with the VidPolicy is enabled.
+*            POLICY_TYPE_ETYPE - EtherType Policy Mapping
+*                EType Policy Mapping occurs when the EtherType of a frame matches
+*                the PortEType (see gprtSetPortEType API)
+*            POLICY_TYPE_PPPoE - PPPoE Policy Mapping
+*                PPPoE Policy Mapping occurs when the EtherType of a frame matches 0x8863
+*            POLICY_TYPE_VBAS - VBAS Policy Mapping
+*                VBAS Policy Mapping occurs when the EtherType of a frame matches 0x8200
+*            POLICY_TYPE_OPT82 - DHCP Option 82 Policy Mapping
+*                DHCP Option 82 Policy Mapping occurs when the ingressing frame is an
+*                IPv4 UDP with a UDP Destination port = 0x0043 or 0x0044, or an
+*                IPv6 UDP with a UDP Destination port = 0x0223 or 0x0222
+*            POLICY_TYPE_UDP - UDP Policy Mapping
+*                UDP Policy Mapping occurs when the ingressing frame is
+*                a Broadcast IPv4 UDP or a Multicast IPv6 UDP.
+*
+* INPUTS:
+*       port    - logical port number.
+*       type     - policy type (GT_POLICY_TYPE)
+*       policy     - policy (GT_FRAME_POLICY)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*       GT_BAD_PARAM     - on bad parameters
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetPolicy
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT     port,
+    IN  GT_POLICY_TYPE    type,
+    IN    GT_FRAME_POLICY    policy
+);
+
+/*******************************************************************************
+* gprtGetPolicy
+*
+* DESCRIPTION:
+*       This routine gets the Policy of the given policy type.
+*        Supported Policies are defined as GT_FRAME_POLICY as follows:
+*            FRAME_POLICY_NONE    - normal frame switching
+*            FRAME_POLICY_MIRROR  - mirror (copy) frame to MirrorDest port
+*            FRAME_POLICY_TRAP    - trap(re-direct) frame to the CPUDest port
+*            FRAME_POLICY_DISCARD - discard(filter) the frame
+*        Supported Policy types are defined as GT_POLICY_TYPE:
+*            POLICY_TYPE_DA - DA Policy Mapping
+*                DA Policy Mapping occurs when the DA of a frame is contained in
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_SA - SA Policy Mapping
+*                SA Policy Mapping occurs when the SA of a frame is contained in
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_VTU - VTU Policy Mapping
+*                VTU Policy Mapping occurs when the VID of a frame is contained in
+*                the VTU database with the VidPolicy is enabled.
+*            POLICY_TYPE_ETYPE - EtherType Policy Mapping
+*                EType Policy Mapping occurs when the EtherType of a frame matches
+*                the PortEType (see gprtSetPortEType API)
+*            POLICY_TYPE_PPPoE - PPPoE Policy Mapping
+*                PPPoE Policy Mapping occurs when the EtherType of a frame matches 0x8863
+*            POLICY_TYPE_VBAS - VBAS Policy Mapping
+*                VBAS Policy Mapping occurs when the EtherType of a frame matches 0x8200
+*            POLICY_TYPE_OPT82 - DHCP Option 82 Policy Mapping
+*                DHCP Option 82 Policy Mapping occurs when the ingressing frame is an
+*                IPv4 UDP with a UDP Destination port = 0x0043 or 0x0044, or an
+*                IPv6 UDP with a UDP Destination port = 0x0223 or 0x0222
+*            POLICY_TYPE_UDP - UDP Policy Mapping
+*                UDP Policy Mapping occurs when the ingressing frame is
+*                a Broadcast IPv4 UDP or a Multicast IPv6 UDP.
+*
+* INPUTS:
+*       port    - logical port number.
+*       type     - policy type (GT_POLICY_TYPE)
+*
+* OUTPUTS:
+*       policy     - policy (GT_FRAME_POLICY)
+*
+* RETURNS:
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*       GT_BAD_PARAM     - on bad parameters
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPolicy
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT     port,
+    IN  GT_POLICY_TYPE    type,
+    OUT GT_FRAME_POLICY    *policy
+);
+
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtSetPauseLimitOut
+*
+* DESCRIPTION:
+*        Limit the number of continuous Pause refresh frames that can be transmitted
+*        from this port. When full duplex Flow Control is enabled on this port,
+*        these bits are used to limit the number of Pause refresh frames that can
+*        be generated from this port to keep this port's link partner from sending
+*        any data.
+*        Setting this value to 0 will allow continuous Pause frame refreshes to
+*        egress this port as long as this port remains congested.
+*        Setting this value to 1 will allow 1 Pause frame to egress from this port
+*        for each congestion situation.
+*        Setting this value to 2 will allow 2 Pause frames to egress from this port
+*        for each congestion situation, etc.
+*
+* INPUTS:
+*        port - the logical port number
+*        limit - the max number of Pause refresh frames for each congestion situation
+*                ( 0 ~ 0xFF)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtSetPauseLimitOut
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  MV_U16        limit
+);
+
+/*******************************************************************************
+* gprtGetPauseLimitOut
+*
+* DESCRIPTION:
+*        Limit the number of continuous Pause refresh frames that can be transmitted
+*        from this port. When full duplex Flow Control is enabled on this port,
+*        these bits are used to limit the number of Pause refresh frames that can
+*        be generated from this port to keep this port's link partner from sending
+*        any data.
+*        Setting this value to 0 will allow continuous Pause frame refreshes to
+*        egress this port as long as this port remains congested.
+*        Setting this value to 1 will allow 1 Pause frame to egress from this port
+*        for each congestion situation.
+*        Setting this value to 2 will allow 2 Pause frames to egress from this port
+*        for each congestion situation, etc.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        limit - the max number of Pause refresh frames for each congestion situation
+*                ( 0 ~ 0xFF)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPauseLimitOut
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_U16        *limit
+);
+
+/*******************************************************************************
+* gprtSetPauseLimitIn
+*
+* DESCRIPTION:
+*        Limit the number of continuous Pause refresh frames that can be received
+*        on this port. When a port has flow Control enabled, this value can be
+*        used to limit how long this port can be Paused off to prevent a port stall
+*        through jamming.
+*        When this value is in the range of 0x01 to 0xFF, and a frame is ready to
+*        be transmitted out this port, but it cannot be transmitted due to the port
+*        being jammed, this limit mechanism starts. The limit mechanism starts
+*        counting new Pause refresh frames or counts of 16 consecutive collisions.
+*        If the counter reaches the value set through this API, the following event
+*        will occur:
+*            1) Port's ForceFC is enabled,
+*            2) Port's FCValue is cleared to a zero, and
+*            3) Jam Limit Interrupt is asserted.
+*        This effectively disables Flow Control on the port once the Pause timer
+*        expires. If a frame gets transmitted out this port before the counter
+*        reaches this limit, then this limit mechanism counter resets back to zero.
+*
+*        Setting this value to 0 will allow continuous jamming to be received on
+*        this port without the Port's ForceFC and FCValue getting modified.
+*
+*        The modification of Port's ForceFC and FCValue is the only indication that
+*        the limit was reached on this port.
+*
+* INPUTS:
+*        port - the logical port number
+*        limit - the max number of continuous Pause refresh frames for each trasmition
+*                ( 0 ~ 0xFF)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtSetPauseLimitIn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  MV_U16        limit
+);
+
+/*******************************************************************************
+* gprtGetPauseLimitIn
+*
+* DESCRIPTION:
+*        Limit the number of continuous Pause refresh frames that can be received
+*        on this port. When a port has flow Control enabled, this value can be
+*        used to limit how long this port can be Paused off to prevent a port stall
+*        through jamming.
+*        When this value is in the range of 0x01 to 0xFF, and a frame is ready to
+*        be transmitted out this port, but it cannot be transmitted due to the port
+*        being jammed, this limit mechanism starts. The limit mechanism starts
+*        counting new Pause refresh frames or counts of 16 consecutive collisions.
+*        If the counter reaches the value set through this API, the following event
+*        will occur:
+*            1) Port's ForceFC is enabled,
+*            2) Port's FCValue is cleared to a zero, and
+*            3) Jam Limit Interrupt is asserted.
+*        This effectively disables Flow Control on the port once the Pause timer
+*        expires. If a frame gets transmitted out this port before the counter
+*        reaches this limit, then this limit mechanism counter resets back to zero.
+*
+*        Setting this value to 0 will allow continuous jamming to be received on
+*        this port without the Port's ForceFC and FCValue getting modified.
+*
+*        The modification of Port's ForceFC and FCValue is the only indication that
+*        the limit was reached on this port.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        limit - the max number of continuous Pause refresh frames for each trasmition
+*                ( 0 ~ 0xFF)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPauseLimitIn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_U16        *limit
+);
+
+/*******************************************************************************
+* gprtSetFrameMode
+*
+* DESCRIPTION:
+*        Frmae Mode is used to define the expected Ingress and the generated Egress
+*        tagging frame format for this port as follows:
+*            GT_FRAME_MODE_NORMAL -
+*                Normal Network mode uses industry standard IEEE 802.3ac Tagged or
+*                Untagged frames. Tagged frames use an Ether Type of 0x8100.
+*            GT_FRAME_MODE_DSA -
+*                DSA mode uses a Marvell defined tagged frame format for
+*                Chip-to-Chip and Chip-to-CPU connections.
+*            GT_FRAME_MODE_PROVIDER -
+*                Provider mode uses user definable Ether Types per port
+*                (see gprtSetPortEType/gprtGetPortEType API).
+*            GT_FRAME_MODE_ETHER_TYPE_DSA -
+*                Ether Type DSA mode uses standard Marvell DSA Tagged frame info
+*                flowing a user definable Ether Type. This mode allows the mixture
+*                of Normal Network frames with DSA Tagged frames and is useful to
+*                be used on ports that connect to a CPU.
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_FRAME_MODE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is unknown
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtSetFrameMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_FRAME_MODE    mode
+);
+
+/*******************************************************************************
+* gprtGetFrameMode
+*
+* DESCRIPTION:
+*        Frmae Mode is used to define the expected Ingress and the generated Egress
+*        tagging frame format for this port as follows:
+*            GT_FRAME_MODE_NORMAL -
+*                Normal Network mode uses industry standard IEEE 802.3ac Tagged or
+*                Untagged frames. Tagged frames use an Ether Type of 0x8100.
+*            GT_FRAME_MODE_DSA -
+*                DSA mode uses a Marvell defined tagged frame format for
+*                Chip-to-Chip and Chip-to-CPU connections.
+*            GT_FRAME_MODE_PROVIDER -
+*                Provider mode uses user definable Ether Types per port
+*                (see gprtSetPortEType/gprtGetPortEType API).
+*            GT_FRAME_MODE_ETHER_TYPE_DSA -
+*                Ether Type DSA mode uses standard Marvell DSA Tagged frame info
+*                flowing a user definable Ether Type. This mode allows the mixture
+*                of Normal Network frames with DSA Tagged frames and is useful to
+*                be used on ports that connect to a CPU.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        mode - GT_FRAME_MODE type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetFrameMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_FRAME_MODE    *mode
+);
+
+/*******************************************************************************
+* gprtSetHoldAt1
+*
+* DESCRIPTION:
+*        Hold Aging ATU Entries at an Entry State value of 1. When this feature
+*        is set to GT_TRUE, ATU entries associated with this port will age down
+*        to an Entry State of 0x1, but will not go to 0x0 (0x0 would purge the
+*        entry)
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to hold aging ATU entry with Entry State of 1,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtSetHoldAt1
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetHoldAt1
+*
+* DESCRIPTION:
+*        Hold Aging ATU Entries at an Entry State value of 1. When this feature
+*        is set to GT_TRUE, ATU entries associated with this port will age down
+*        to an Entry State of 0x1, but will not go to 0x0 (0x0 would purge the
+*        entry)
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to hold aging ATU entry with Entry State of 1,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetHoldAt1
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL      *mode
+);
+
+/*******************************************************************************
+* gprtSetRefreshLocked
+*
+* DESCRIPTION:
+*        Auto Refresh known addresses when port is Locked. Already known addresses
+*        will be auto refreshed when this feature is enabled. When this feature
+*        is disabled, auto refreshing will not occur on Locked ports.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to enable Auto Refresh known addresses on locked port
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtSetRefreshLocked
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetRefreshLocked
+*
+* DESCRIPTION:
+*        Auto Refresh known addresses when port is Locked. Already known addresses
+*        will be auto refreshed when this feature is enabled. When this feature
+*        is disabled, auto refreshing will not occur on Locked ports.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable Auto Refresh known addresses on locked port
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetRefreshLocked
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL      *mode
+);
+
+/*******************************************************************************
+* gprtSetPortEType
+*
+* DESCRIPTION:
+*        This routine sets the port's special Ether Type. This Ether Type is used
+*        for Policy (see gprtSetPolicy API) and FrameMode (see gprtSetFrameMode API).
+*
+* INPUTS:
+*        port  - the logical port number
+*        etype - port's special ether type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtSetPortEType
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_ETYPE        etype
+);
+
+/*******************************************************************************
+* gprtGetPortEType
+*
+* DESCRIPTION:
+*        This routine retrieves the port's special Ether Type. This Ether Type is used
+*        for Policy (see gprtSetPolicy API) and FrameMode (see gprtSetFrameMode API).
+*
+* INPUTS:
+*        port  - the logical port number
+*
+* OUTPUTS:
+*        etype - port's special ether type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetPortEType
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_ETYPE    *etype
+);
+
+
+/* gtPortRateCtr.c */
+
+/*******************************************************************************
+* grcSetFrameOverhead
+*
+* DESCRIPTION:
+*       Egress rate frame overhead adjustment.
+*        This field is used to adjust the number of bytes that need to be added to a
+*        frame's IFG on a per frame basis.
+*
+*        The egress rate limiter multiplies the value programmed in this field by four
+*        for computing the frame byte offset adjustment value (i.e., the amount the
+*        IPG is increased for every frame). This adjustment, if enabled, is made to
+*        every egressing frame's IPG and it is made in addition to any other IPG
+*        adjustments due to other Egress Rate Control settings.
+*
+*        The egress overhead adjustment can add the following number of byte times
+*        to each frame's IPG: 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52,
+*        56 and 60.
+*
+*        Example:
+*        If FrameOverhead = 11, the egress rate limiter would increase the IPG
+*        between every frame by an additional 44 bytes.
+*
+*        Note: When the Count Mode (port offset 0x0A) is in Frame based egress rate
+*        shaping mode, these Frame Overhead bits must be 0x0.
+*
+* INPUTS:
+*       port     - logical port number.
+*       overhead - Frame overhead (0 ~ 15)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS grcSetFrameOverhead
+(
+    IN GT_QD_DEV        *dev,
+    IN GT_LPORT            port,
+    IN MV_32            overhead
+);
+
+/*******************************************************************************
+* grcGetFrameOverhead
+*
+* DESCRIPTION:
+*       Egress rate frame overhead adjustment.
+*        This field is used to adjust the number of bytes that need to be added to a
+*        frame's IFG on a per frame basis.
+*
+*        The egress rate limiter multiplies the value programmed in this field by four
+*        for computing the frame byte offset adjustment value (i.e., the amount the
+*        IPG is increased for every frame). This adjustment, if enabled, is made to
+*        every egressing frame's IPG and it is made in addition to any other IPG
+*        adjustments due to other Egress Rate Control settings.
+*
+*        The egress overhead adjustment can add the following number of byte times
+*        to each frame's IPG: 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52,
+*        56 and 60.
+*
+*        Example:
+*        If FrameOverhead = 11, the egress rate limiter would increase the IPG
+*        between every frame by an additional 44 bytes.
+*
+*        Note: When the Count Mode (port offset 0x0A) is in Frame based egress rate
+*        shaping mode, these Frame Overhead bits must be 0x0.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       overhead - Frame overhead (0 ~ 15)
+*
+* RETURNS:
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+*******************************************************************************/
+MV_STATUS grcGetFrameOverhead
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT MV_32    *overhead
+);
+
+
+/* gtPortStatus.c */
+
+/*******************************************************************************
+* gprtGetBufHigh
+*
+* DESCRIPTION:
+*        Output from QC telling the MAC that it should perform Flow Control.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        bufHigh - GT_TRUE, if Flow control required
+*                  GT_FALSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetBufHigh
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *bufHigh
+);
+
+/*******************************************************************************
+* gprtGetFcEn
+*
+* DESCRIPTION:
+*        Input into the QC telling it that Flow Control is enabled on this port.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        fcEn - GT_TRUE, if Flow control is enabled
+*               GT_FALSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetFcEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_BOOL        *fcEn
+);
+
+/*******************************************************************************
+* gprtGetRsvSize
+*
+* DESCRIPTION:
+*        This routine gets Ingress reserved queue size counter.
+*        This counter reflects the current number of reserved ingress buffers
+*        assigned to this port.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        count - reserved ingress queue size counter value
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetRsvSize
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_U16        *count
+);
+
+
+/* gtPriTable.c */
+
+/*******************************************************************************
+* gsysSetQPriOverrideTable
+*
+* DESCRIPTION:
+*       Queue Priority Override.
+*        When a frame enters a port, its type is determined and the type is used
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gsysSetQPriOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    IN  GT_QPRI_TBL_ENTRY    *entry
+);
+
+/*******************************************************************************
+* gsysGetQPriOverrideTable
+*
+* DESCRIPTION:
+*       Queue Priority Override.
+*        When a frame enters a port, its type is determined and the type is used
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*
+* OUTPUTS:
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gsysGetQPriOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    OUT GT_QPRI_TBL_ENTRY    *entry
+);
+
+
+/* gtSysCtrl.c */
+
+/*******************************************************************************
+* gsysSetCPUDest
+*
+* DESCRIPTION:
+*        This routine sets CPU Destination Port. CPU Destination port indicates the
+*        port number on this device where the CPU is connected (either directly or
+*        indirectly through another Marvell switch device).
+*
+*        Many modes of frame processing need to know where the CPU is located.
+*        These modes are:
+*        1. When IGMP/MLD frame is received and Snooping is enabled
+*        2. When the port is configured as a DSA port and it receives a To_CPU frame
+*        3. When a Rsvd2CPU frame enters the port
+*        4. When the port's SA Filtering mode is Drop to CPU
+*        5. When any of the port's Policy Options trap the frame to the CPU
+*        6. When the ingressing frame is an ARP and ARP mirroring is enabled in the
+*           device
+*
+*        In all cases, except for ARP, the frames that meet the enabled criteria
+*        are mapped to the CPU Destination port, overriding where the frame would
+*        normally go. In the case of ARP, the frame will be mapped normally and it
+*        will also get copied to this port.
+*        Frames that filtered or discarded will not be mapped to the CPU Destination
+*        port with the exception of the Rsvd2CPU and DSA Tag cases.
+*
+*        If CPUDest = 0xF, the remapped frames will be discarded, no ARP mirroring
+*        will occur and ingressing To_CPU frames will be discarded.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetCPUDest
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+);
+
+/*******************************************************************************
+* gsysGetCPUDest
+*
+* DESCRIPTION:
+*        This routine gets CPU Destination Port. CPU Destination port indicates the
+*        port number on this device where the CPU is connected (either directly or
+*        indirectly through another Marvell switch device).
+*
+*        Many modes of frame processing need to know where the CPU is located.
+*        These modes are:
+*        1. When IGMP/MLD frame is received and Snooping is enabled
+*        2. When the port is configured as a DSA port and it receives a To_CPU frame
+*        3. When a Rsvd2CPU frame enters the port
+*        4. When the port's SA Filtering mode is Drop to CPU
+*        5. When any of the port's Policy Options trap the frame to the CPU
+*        6. When the ingressing frame is an ARP and ARP mirroring is enabled in the
+*           device
+*
+*        In all cases, except for ARP, the frames that meet the enabled criteria
+*        are mapped to the CPU Destination port, overriding where the frame would
+*        normally go. In the case of ARP, the frame will be mapped normally and it
+*        will also get copied to this port.
+*        Frames that filtered or discarded will not be mapped to the CPU Destination
+*        port with the exception of the Rsvd2CPU and DSA Tag cases.
+*
+*        If CPUDest = 0xF, the remapped frames will be discarded, no ARP mirroring
+*        will occur and ingressing To_CPU frames will be discarded.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetCPUDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+);
+
+/*******************************************************************************
+* gsysSetMirrorDest
+*
+* DESCRIPTION:
+*        This routine sets Mirror Destination Port. Frames that ingress a port
+*        that trigger a policy mirror are mapped (copied) to this port as long as
+*        the frame is not filtered or discarded.
+*        The Mirror Destination port should point to the port that directs these
+*        frames to the CPU that will process these frames. This target port should
+*        be a DSA Tag port so the frames will egress with a To_CPU DSA Tag with a
+*        CPU Code of Policy Mirror.
+*        To_CPU DSA Tag frames with a CPU Code of Policy Mirror that ingress a DSA
+*        Tag port will be sent to the port number defined in MirrorDest.
+*
+*        If MirrorDest = 0xF, Policy Mirroring is disabled and ingressing To_CPU
+*        Policy Mirror frames will be discarded.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetMirrorDest
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+);
+
+/*******************************************************************************
+* gsysGetMirrorDest
+*
+* DESCRIPTION:
+*        This routine gets Mirror Destination Port. Frames that ingress a port
+*        that trigger a policy mirror are mapped (copied) to this port as long as
+*        the frame is not filtered or discarded.
+*        The Mirror Destination port should point to the port that directs these
+*        frames to the CPU that will process these frames. This target port should
+*        be a DSA Tag port so the frames will egress with a To_CPU DSA Tag with a
+*        CPU Code of Policy Mirror.
+*        To_CPU DSA Tag frames with a CPU Code of Policy Mirror that ingress a DSA
+*        Tag port will be sent to the port number defined in MirrorDest.
+*
+*        If MirrorDest = 0xF, Policy Mirroring is disabled and ingressing To_CPU
+*        Policy Mirror frames will be discarded.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetMirrorDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+);
+
+/*******************************************************************************
+* gsysSetRMPort
+*
+* DESCRIPTION:
+*        Remote Management feature is enabled only on one port. Since not all ports
+*        can be enabled for Remote Management feature, please refer to the device
+*        datasheet for detailed information.
+*        For example, 88E6097 device allows logical port 9 or 10, and 88E6047
+*        device allows logical port 4 and 5.
+*
+* INPUTS:
+*        port - Remote Management Port
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM     - on unallowable port
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Obsolete. Please uses gsysSetRMUMode API, instead.
+*
+*******************************************************************************/
+MV_STATUS gsysSetRMPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
+);
+
+/*******************************************************************************
+* gsysGetRMPort
+*
+* DESCRIPTION:
+*        Remote Management feature is enabled only on one port. Since not all ports
+*        can be enabled for Remote Management feature, please refer to the device
+*        datasheet for detailed information.
+*        For example, 88E6097 device allows logical port 9 or 10, and 88E6047
+*        device allows logical port 4 and 5.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port - Remote Management Port
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Obsolete. Please uses gsysGetRMUMode API, instead.
+*
+*******************************************************************************/
+MV_STATUS gsysGetRMPort
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT     *port
+);
+
+/*******************************************************************************
+* gsysSetRMDACheck
+*
+* DESCRIPTION:
+*        Check the DA on Remote Management frames.
+*        When DA Check is enabled, the DA of Remote Management frames must be
+*        contained in this device's address database (ATU) as a Static entry
+*        (either unicast or multicast). If the DA of the frame is not contained
+*        in this device's address database, the frame will be not be processed as
+*        a Frame-to-Regter frame.
+*        When DA Check is disabled, the DA of Remote Management frames is not
+*        validated before processing the frame.
+*
+* INPUTS:
+*        en - GT_TRUE to enable DA Check,
+*             GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetRMDACheck
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL         en
+);
+
+/*******************************************************************************
+* gsysGetRMDACheck
+*
+* DESCRIPTION:
+*        Check the DA on Remote Management frames.
+*        When DA Check is enabled, the DA of Remote Management frames must be
+*        contained in this device's address database (ATU) as a Static entry
+*        (either unicast or multicast). If the DA of the frame is not contained
+*        in this device's address database, the frame will be not be processed as
+*        a Frame-to-Regter frame.
+*        When DA Check is disabled, the DA of Remote Management frames is not
+*        validated before processing the frame.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if DA Check is enabled,
+*             GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetRMDACheck
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL     *en
+);
+
+/*******************************************************************************
+* gsysSetHeaderType
+*
+* DESCRIPTION:
+*   To set Header Type. These bits are used to configure the bits that are placed
+*   into the Egress Header when it is enabled on a port (Port offset 0x04)
+*   as follows:
+*     00 = Original Header  for backwards compatibility to UniMACs that look at
+*          Header byte 1 bits[4:2] and byte 2 bits [3:0]
+*     01 = Single chip MGMT Header  for compatibility to Marvell Fast Ethernet
+*          switches that support Spanning Tree without DSA Tags
+*     10 = Trunk Header  used together with the DSA Tags to perform Remote Switching
+*     11 = Reserved for future use.
+*
+* INPUTS:
+*        hdType
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetHeaderType
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U16       hdType
+);
+
+/*******************************************************************************
+* gsysGetHeaderType
+*
+* DESCRIPTION:
+*   To get Header Type. These bits are used to configure the bits that are placed
+*   into the Egress Header when it is enabled on a port (Port offset 0x04)
+*   as follows:
+*     00 = Original Header  for backwards compatibility to UniMACs that look at
+*          Header byte 1 bits[4:2] and byte 2 bits [3:0]
+*     01 = Single chip MGMT Header  for compatibility to Marvell Fast Ethernet
+*          switches that support Spanning Tree without DSA Tags
+*     10 = Trunk Header  used together with the DSA Tags to perform Remote Switching
+*     11 = Reserved for future use.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        hdType
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetHeaderType
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U16     *hdType
+);
+
+/*******************************************************************************
+* gsysSetRMEnable
+*
+* DESCRIPTION:
+*        Enable or disable Remote Management feature. This feature can be enabled
+*        only on one port (see gsysSetRMPort API).
+*
+* INPUTS:
+*        en - GT_TRUE to enable Remote Management feature,
+*             GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Obsolete. Please uses gsysSetRMUMode API, instead.
+*
+*******************************************************************************/
+MV_STATUS gsysSetRMEnable
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL         en
+);
+
+/*******************************************************************************
+* gsysGetRMEnable
+*
+* DESCRIPTION:
+*        Enable or disable Remote Management feature. This feature can be enabled
+*        only on one port (see gsysSetRMPort API).
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Remote Management feature is enabled,
+*             GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Obsolete. Please uses gsysGetRMUMode API, instead.
+*
+*******************************************************************************/
+MV_STATUS gsysGetRMEnable
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL     *en
+);
+
+/*******************************************************************************
+* gsysSetCtrMode
+*
+* DESCRIPTION:
+*        Set Counter Modes. These bits control the operating modes of the two of
+*        the Ports MIB counters.
+*
+* INPUTS:
+*        ctrMode - Counter mode
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM     - on bad parameter
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetCtrMode
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U16       ctrMode
+);
+
+/*******************************************************************************
+* gsysGetCtrMode
+*
+* DESCRIPTION:
+*        Get Counter Modes. These bits control the operating modes of the two of
+*        the Ports MIB counters.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        ctrMode - Counter mode
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetCtrMode
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U16       *ctrMode
+);
+
+/*******************************************************************************
+* gsysSetRsvd2CpuEnables2X
+*
+* DESCRIPTION:
+*        Reserved DA Enables for the form of 01:80:C2:00:00:2x.
+*        When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, the 16 reserved
+*        multicast DA addresses, whose bit in this register are also set to a one,
+*        are treadted as MGMT frames. All the reserved DA's take the form
+*        01:80:C2:00:00:2x. When x = 0x0, bit 0 of this register is tested.
+*        When x = 0x2, bit 2 of this field is tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will
+*        be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*        enBits - bit vector of enabled Reserved Multicast.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetRsvd2CpuEnables2X
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U16        enBits
+);
+
+/*******************************************************************************
+* gsysGetRsvd2CpuEnables2X
+*
+* DESCRIPTION:
+*        Reserved DA Enables for the form of 01:80:C2:00:00:2x.
+*        When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, the 16 reserved
+*        multicast DA addresses, whose bit in this register are also set to a one,
+*        are treadted as MGMT frames. All the reserved DA's take the form
+*        01:80:C2:00:00:2x. When x = 0x0, bit 0 of this register is tested.
+*        When x = 0x2, bit 2 of this field is tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will
+*        be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        enBits - bit vector of enabled Reserved Multicast.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetRsvd2CpuEnables2X
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U16      *enBits
+);
+
+/*******************************************************************************
+* gsysSetFloodBC
+*
+* DESCRIPTION:
+*        Flood Broadcast.
+*        When Flood Broadcast is enabled, frames with the Broadcast destination
+*        address will flood out all the ports regardless of the setting of the
+*        port's Egress Floods mode (see gprtSetEgressFlood API). VLAN rules and
+*        other switch policy still applies to these Broadcast frames.
+*        When this feature is disabled, frames with the Broadcast destination
+*        address are considered Multicast frames and will be affected by port's
+*        Egress Floods mode.
+*
+* INPUTS:
+*        en - GT_TRUE to enable Flood Broadcast, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetFloodBC
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetFloodBC
+*
+* DESCRIPTION:
+*        Flood Broadcast.
+*        When Flood Broadcast is enabled, frames with the Broadcast destination
+*        address will flood out all the ports regardless of the setting of the
+*        port's Egress Floods mode (see gprtSetEgressFlood API). VLAN rules and
+*        other switch policy still applies to these Broadcast frames.
+*        When this feature is disabled, frames with the Broadcast destination
+*        address are considered Multicast frames and will be affected by port's
+*        Egress Floods mode.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Flood Broadcast is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetFloodBC
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetRemove1PTag
+*
+* DESCRIPTION:
+*        Remove One Provider Tag.
+*        When this feature is enabled and a port is configured as a Provider Port
+*        (see gprtSetFrameMode API), recursive Provider Tag stripping will NOT be
+*        performed. Only the first Provider Tag found on the frame will be
+*        extracted and removed. Its extracted data will be used for switching.
+*        When it's disabled and a port is configured as a Provider Port, recursive
+*        Provider Tag stripping will be performed. The first Provider Tag's data
+*        will be extracted and used for switching, and then all subsequent Provider
+*        Tags found in the frame will also be removed. This will only occur if the
+*        port's PortEType (see gprtSetPortEType API) is not 0x8100.
+*
+* INPUTS:
+*        en - GT_TRUE to enable Remove One Provider Tag, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetRemove1PTag
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetRemove1PTag
+*
+* DESCRIPTION:
+*        Remove One Provider Tag.
+*        When this feature is enabled and a port is configured as a Provider Port
+*        (see gprtSetFrameMode API), recursive Provider Tag stripping will NOT be
+*        performed. Only the first Provider Tag found on the frame will be
+*        extracted and removed. Its extracted data will be used for switching.
+*        When it's disabled and a port is configured as a Provider Port, recursive
+*        Provider Tag stripping will be performed. The first Provider Tag's data
+*        will be extracted and used for switching, and then all subsequent Provider
+*        Tags found in the frame will also be removed. This will only occur if the
+*        port's PortEType (see gprtSetPortEType API) is not 0x8100.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Remove One Provider Tag is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetRemove1PTag
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL        *en
+);
+
+/*******************************************************************************
+* gsysSetTagFlowControl
+*
+* DESCRIPTION:
+*        Use and generate source port Flow Control status for Cross-Chip Flow
+*        Control.
+*        When this feature is enabled, bit 17 of the DSA Tag Forward frames is
+*        defined to be Src_FC and it is added to these frames when generated and
+*        it is inspected on these frames when received. The QC will use the Src_FC
+*        bit on DSA ports instead of the DSA port's Flow Control mode bit for the
+*        QC Flow Control algorithm.
+*        When it is disabled, bit 17 of the DSA Tag Forward frames is defined to
+*        be Reserved and it will be zero on these frames when generated and it
+*        will not be used on these frames when received (this is a backwards
+*        compatibility mode).
+*
+* INPUTS:
+*        en - GT_TRUE to enable Tag Flow Control, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetTagFlowControl
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetTagFlowControl
+*
+* DESCRIPTION:
+*        Use and generate source port Flow Control status for Cross-Chip Flow
+*        Control.
+*        When this feature is enabled, bit 17 of the DSA Tag Forward frames is
+*        defined to be Src_FC and it is added to these frames when generated and
+*        it is inspected on these frames when received. The QC will use the Src_FC
+*        bit on DSA ports instead of the DSA port's Flow Control mode bit for the
+*        QC Flow Control algorithm.
+*        When it is disabled, bit 17 of the DSA Tag Forward frames is defined to
+*        be Reserved and it will be zero on these frames when generated and it
+*        will not be used on these frames when received (this is a backwards
+*        compatibility mode).
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Tag Flow Control is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetTagFlowControl
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetAlwaysUseVTU
+*
+* DESCRIPTION:
+*        Always use VTU.
+*        When this feature is enabled, VTU hit data will be used to map frames
+*        even if 802.1Q is Disabled on the port.
+*        When it's disabled, data will be ignored when mapping frames on ports
+*        where 802.1Q is Disabled.
+*
+* INPUTS:
+*        en - GT_TRUE to use VTU always, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetAlwaysUseVTU
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetAlwaysUseVTU
+*
+* DESCRIPTION:
+*        Always use VTU.
+*        When this feature is enabled, VTU hit data will be used to map frames
+*        even if 802.1Q is Disabled on the port.
+*        When it's disabled, data will be ignored when mapping frames on ports
+*        where 802.1Q is Disabled.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if VTU is always used, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetAlwaysUseVTU
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetQVlansOnly
+*
+* DESCRIPTION:
+*        802.1Q VLANs Only.
+*        When this feature is disabled, the egress mapping of the frame is
+*        limited by the frame's VID (using the MemberTag data found in the VTU)
+*        together with the port based VLANs (using the source port's PortVLANTable,
+*        gvlnSetPortVlanPorts API). The two methods are always used together in
+*        this mode.
+*        When this feature is enabled, the egress mapping of the frame is limitied
+*        by the frame's VID only, if the VID was found in the VTU. If the frame's
+*        VID was not found in the VTU the egress mapping of the frame is limited
+*        by the source port's PortVLANTable only. The two methods are never
+*        used together in this mode.
+*
+* INPUTS:
+*        en - GT_TRUE to use 802.1Q Vlan Only feature, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetQVlansOnly
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetQVlansOnly
+*
+* DESCRIPTION:
+*        802.1Q VLANs Only.
+*        When this feature is disabled, the egress mapping of the frame is
+*        limited by the frame's VID (using the MemberTag data found in the VTU)
+*        together with the port based VLANs (using the source port's PortVLANTable,
+*        gvlnSetPortVlanPorts API). The two methods are always used together in
+*        this mode.
+*        When this feature is enabled, the egress mapping of the frame is limitied
+*        by the frame's VID only, if the VID was found in the VTU. If the frame's
+*        VID was not found in the VTU the egress mapping of the frame is limited
+*        by the source port's PortVLANTable only. The two methods are never
+*        used together in this mode.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if 802.1Q Vlan Only feature is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetQVlansOnly
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSet5BitPort
+*
+* DESCRIPTION:
+*        Use 5 bits for Port data in the Port VLAN Table (PVT).
+*        When this feature is enabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:5] = Source Device[3:0] or Device Number[3:0]
+*            Addr[4:0] = Source Port/Trunk[4:0]
+*        When it's disabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:4] = Source Device[4:0] or Device Number[4:0]
+*            Addr[3:0] = Source Port/Trunk[3:0]
+*
+* INPUTS:
+*        en - GT_TRUE to use 5 bit as a Source port in PVT, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSet5BitPort
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGet5BitPort
+*
+* DESCRIPTION:
+*        Use 5 bits for Port data in the Port VLAN Table (PVT).
+*        When this feature is enabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:5] = Source Device[3:0] or Device Number[3:0]
+*            Addr[4:0] = Source Port/Trunk[4:0]
+*        When it's disabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:4] = Source Device[4:0] or Device Number[4:0]
+*            Addr[3:0] = Source Port/Trunk[3:0]
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if 5 bit is used as a Source Port in PVT, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGet5BitPort
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetSDETPolarity
+*
+* DESCRIPTION:
+*        SDET (Signal Detect) Polarity select bits for each port.
+*        Bit 10 is for Port 10, bit 9 is for Port 9, etc. SDET is used to help
+*        determine link on fiber ports. This bit affects the active level of a
+*        port's SDET pins as follows:
+*            0 = SDET is active low. A low level on the port's SDET pin is
+*                required for link to occur.
+*            1 = SDET is active high. A high level on the ports SDET pin is
+*                required for link to occur.
+*        SDET is used when the port is configured as a fiber port. In all other
+*        port modes the SDET pins are ignored and these bits have no effect.
+*
+* INPUTS:
+*        sdetVec - SDET Polarity for each port in Vector format
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sdetVec is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetSDETPolarity
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_U32          sdetVec
+);
+
+/*******************************************************************************
+* gsysSetSDETPolarity
+*
+* DESCRIPTION:
+*        SDET (Signal Detect) Polarity select bits for each port.
+*        Bit 10 is for Port 10, bit 9 is for Port 9, etc. SDET is used to help
+*        determine link on fiber ports. This bit affects the active level of a
+*        port's SDET pins as follows:
+*            0 = SDET is active low. A low level on the port's SDET pin is
+*                required for link to occur.
+*            1 = SDET is active high. A high level on the ports SDET pin is
+*                required for link to occur.
+*        SDET is used when the port is configured as a fiber port. In all other
+*        port modes the SDET pins are ignored and these bits have no effect.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        sdetVec - SDET Polarity for each port in Vector format
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetSDETPolarity
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_U32      *sdetVec
+);
+
+
+/* gtBrgVlan.c for 2.6 release */
+
+/*******************************************************************************
+* gvlnSetNoEgrPolicy
+*
+* DESCRIPTION:
+*        No Egress Policy. When this bit is set to a one Egress 802.1Q Secure and
+*        Check discards are not performed. This mode allowsa non-802.1Q enabled
+*        port to send a frame to an 802.1Q enabled port that is configured in the
+*        Secure or Check 802.1Q mode. In this situation the frames will egress
+*        even if the VID assigned to the frame is not found in the VTU.
+*
+* INPUTS:
+*        mode - no egress policy mode
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gvlnSetNoEgrPolicy
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        mode
+);
+
+
+/*******************************************************************************
+* gvlnGetNoEgrPolicy
+*
+* DESCRIPTION:
+*        No Egress Policy. When this bit is set to a one Egress 802.1Q Secure and
+*        Check discards are not performed. This mode allowsa non-802.1Q enabled
+*        port to send a frame to an 802.1Q enabled port that is configured in the
+*        Secure or Check 802.1Q mode. In this situation the frames will egress
+*        even if the VID assigned to the frame is not found in the VTU.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode - no egress policy mode
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gvlnGetNoEgrPolicy
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL        *mode
+);
+
+/*******************************************************************************
+* gwdSetRMUTimeOut
+*
+* DESCRIPTION:
+*        Remote Management Timeout. When this bit is set to a one the Remote
+*        Management Unit(RMU) will timeout on Wait on Bit commands. If the bit that
+*        is being tested has not gone to the specified value after 1 sec. has elapsed
+*        the Wait on Bit command will be terminated and the Response frame will be
+*        sent without any further processing.
+*
+*        When this bit is cleared to a zero the Wait on Bit command will wait
+*        until the bit that is being tested has changed to the specified value.
+*
+* INPUTS:
+*        en   - GT_TRUE to enable RMU Timeout
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gwdSetRMUTimeOut
+(
+    IN  GT_QD_DEV    *dev,
+    IN  MV_BOOL        en
+);
+
+/*******************************************************************************
+* gwdGetRMUTimeOut
+*
+* DESCRIPTION:
+*        Remote Management Timeout. When this bit is set to a one the Remote
+*        Management Unit(RMU) will timeout on Wait on Bit commands. If the bit that
+*        is being tested has not gone to the specified value after 1 sec. has elapsed
+*        the Wait on Bit command will be terminated and the Response frame will be
+*        sent without any further processing.
+*
+*        When this bit is cleared to a zero the Wait on Bit command will wait
+*        until the bit that is being tested has changed to the specified value.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en   - GT_TRUE to enable RMU Timeout
+*               GT_FALUSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gwdGetRMUTimeOut
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL        *en
+);
+
+/*******************************************************************************
+* gwdGetEgressWDEvent
+*
+* DESCRIPTION:
+*        If any port's egress logic detects an egress watch dog issue, this bit
+*        will be set to a one, regardless of the setting of the GT_WD_EGRESS in
+*        gwdSetEvent function.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        event - GT_TRUE, if egress logic has detected any egress watch dog issue
+*                GT_FALUSE, otherwise
+*
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gwdGetEgressWDEvent
+(
+    IN  GT_QD_DEV        *dev,
+    OUT MV_BOOL            *event
+);
+
+
+/*******************************************************************************
+* gsysSetQoSWeight
+*
+* DESCRIPTION:
+*       Programmable Round Robin Weights.
+*        Each port has 4 output Queues. Queue 3 has the highest priority and
+*        Queue 0 has the lowest priority. When a scheduling mode of port is
+*        configured as Weighted Round Robin queuing mode, the access sequece of the
+*        Queue is 3,2,3,1,3,2,3,0,3,2,3,1,3,2,3 by default.
+*        This sequence can be configured with this API.
+*
+* INPUTS:
+*       weight - access sequence of the queue
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gsysSetQoSWeight
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_QoS_WEIGHT    *weight
+);
+
+/*******************************************************************************
+* gsysGetQoSWeight
+*
+* DESCRIPTION:
+*       Programmable Round Robin Weights.
+*        Each port has 4 output Queues. Queue 3 has the highest priority and
+*        Queue 0 has the lowest priority. When a scheduling mode of port is
+*        configured as Weighted Round Robin queuing mode, the access sequece of the
+*        Queue is 3,2,3,1,3,2,3,0,3,2,3,1,3,2,3 by default.
+*        This routine retrieves the access sequence of the Queue.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       weight - access sequence of the queue
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gsysGetQoSWeight
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_QoS_WEIGHT    *weight
+);
+
+
+/*
+ *    gtPortCtrl.c
+*/
+
+/*******************************************************************************
+* gsysSetJumboMode
+*
+* DESCRIPTION:
+*       This routine Set the max frame size allowed to be received and transmitted
+*        from or to a given port.
+*
+* INPUTS:
+*        port - the logical port number
+*       mode - GT_JUMBO_MODE (1522, 2048, or 10240)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gsysSetJumboMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_JUMBO_MODE   mode
+);
+
+/*******************************************************************************
+* gsysGetJumboMode
+*
+* DESCRIPTION:
+*       This routine gets the max frame size allowed to be received and transmitted
+*        from or to a given port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_JUMBO_MODE (1522, 2048, or 10240)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gsysGetJumboMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_JUMBO_MODE   *mode
+);
+
+/*
+ *  gtPhyCtrl.c
+*/
+/*******************************************************************************
+* gprtGetEnergyDetect
+*
+* DESCRIPTION:
+*       Energy Detect power down mode enables or disables the PHY to wake up on
+*        its own by detecting activity on the CAT 5 cable.
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*       mode - GT_EDETECT_MODE type
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetEnergyDetect
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_EDETECT_MODE   *mode
+);
+
+/*******************************************************************************
+* gprtSetEnergyDetect
+*
+* DESCRIPTION:
+*       Energy Detect power down mode enables or disables the PHY to wake up on
+*        its own by detecting activity on the CAT 5 cable.
+*
+* INPUTS:
+*         port - The logical port number
+*       mode - GT_EDETECT_MODE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+MV_STATUS gprtSetEnergyDetect
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_EDETECT_MODE   mode
+);
+
+
+/*
+ *    gtSysCtrl.c
+*/
+
+/*******************************************************************************
+* gsysSetRMUMode
+*
+* DESCRIPTION:
+*        Set Rmote Management Unit Mode: disable, enable on port 4, 5 or 6, or enable
+*        on port 9 or 10. Devices, such as 88E6097, support RMU on port 9 and 10,
+*        while other devices, such as 88E6165, support RMU on port 4, 5 and 6. So,
+*        please refer to the device datasheet for detail.
+*        When RMU is enabled and this device receives a Remote Management Request
+*        frame directed to this device, the frame will be processed and a Remote
+*        Management Response frame will be generated and sent out.
+*
+*        Note: enabling RMU has no effect if the Remote Management port is in half
+*        duplex mode. The port's FrameMode must be DSA or EtherType DSA as well.
+*
+* INPUTS:
+*        rmu - GT_RMU structure
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM     - on bad parameter
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetRMUMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_RMU        *rmu
+);
+
+/*******************************************************************************
+* gsysGetRMUMode
+*
+* DESCRIPTION:
+*        Get Rmote Management Unit Mode: disable, enable on port 4, 5 or 6, or enable
+*        on port 9 or 10. Devices, such as 88E6097, support RMU on port 9 and 10,
+*        while other devices, such as 88E6165, support RMU on port 4, 5 and 6. So,
+*        please refer to the device datasheet for detail.
+*        When RMU is enabled and this device receives a Remote Management Request
+*        frame directed to this device, the frame will be processed and a Remote
+*        Management Response frame will be generated and sent out.
+*
+*        Note: enabling RMU has no effect if the Remote Management port is in half
+*        duplex mode. The port's FrameMode must be DSA or EtherType DSA as well.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        rmu - GT_RMU structure
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetRMUMode
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_RMU        *rmu
+);
+
+/*******************************************************************************
+* gsysPort2Lport
+*
+* DESCRIPTION:
+*        This routine converts physical port number to logical port number.
+*
+* INPUTS:
+*        port - physical port number
+*
+* OUTPUTS:
+*        lport - logical port number
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysPort2Lport
+(
+    IN  GT_QD_DEV    *dev,
+    IN  MV_U32         port,
+    OUT GT_LPORT    *lport
+);
+
+/*******************************************************************************
+* gsysLport2Port
+*
+* DESCRIPTION:
+*        This routine converts logical port number to physical port number.
+*
+* INPUTS:
+*        lport - logical port number
+*
+* OUTPUTS:
+*        port - physical port number
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysLport2Port
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    lport,
+    OUT MV_U32         *port
+);
+
+/*******************************************************************************
+* gsysPortvec2Lportvec
+*
+* DESCRIPTION:
+*        This routine converts physical port vector to logical port vector.
+*
+* INPUTS:
+*        portvec - physical port vector
+*
+* OUTPUTS:
+*        lportvec - logical port vector
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysPortvec2Lportvec
+(
+    IN  GT_QD_DEV    *dev,
+    IN  MV_U32        portvec,
+    OUT MV_U32         *lportvec
+);
+
+/*******************************************************************************
+* gsysLportvec2Portvec
+*
+* DESCRIPTION:
+*        This routine converts logical port vector to physical port vector.
+*
+* INPUTS:
+*        lportvec - logical port vector
+*
+* OUTPUTS:
+*        portvec - physical port vector
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysLportvec2Portvec
+(
+    IN  GT_QD_DEV    *dev,
+    IN  MV_U32        lportvec,
+    OUT MV_U32         *portvec
+);
+
+
+/*
+ * gtPIRL.c
+ */
+
+/*******************************************************************************
+* gpirlSetCurTimeUpInt
+*
+* DESCRIPTION:
+*       This function sets the current time update interval.
+*        Please contact FAE for detailed information.
+*
+* INPUTS:
+*       upInt - updata interval (0 ~ 7)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gpirlSetCurTimeUpInt
+(
+    IN  GT_QD_DEV              *dev,
+    IN    MV_U32                upInt
+);
+
+
+/*
+ * gtPIRL2.c
+ */
+
+/*******************************************************************************
+* gpirl2SetCurTimeUpInt
+*
+* DESCRIPTION:
+*       This function sets the current time update interval.
+*        Please contact FAE for detailed information.
+*
+* INPUTS:
+*       upInt - updata interval (0 ~ 7)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gpirl2SetCurTimeUpInt
+(
+    IN  GT_QD_DEV              *dev,
+    IN    MV_U32                upInt
+);
+
+
+/*
+ * gtPTP.c
+ */
+
+/*******************************************************************************
+* gptpSetConfig
+*
+* DESCRIPTION:
+*       This routine writes PTP configuration parameters.
+*
+* INPUTS:
+*        ptpData  - PTP configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CONFIG    *ptpData
+);
+
+/*******************************************************************************
+* gptpGetConfig
+*
+* DESCRIPTION:
+*       This routine reads PTP configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpData  - PTP configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CONFIG    *ptpData
+);
+
+/*******************************************************************************
+* gptpSetGlobalConfig
+*
+* DESCRIPTION:
+*       This routine writes PTP global configuration parameters.
+*
+* INPUTS:
+*        ptpData  - PTP global configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetGlobalConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_GLOBAL_CONFIG    *ptpData
+);
+
+/*******************************************************************************
+* gptpGetGlobalConfig
+*
+* DESCRIPTION:
+*       This routine reads PTP global configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpData  - PTP global configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetGlobalConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_GLOBAL_CONFIG    *ptpData
+);
+
+/*******************************************************************************
+* gptpSetPortConfig
+*
+* DESCRIPTION:
+*       This routine writes PTP port configuration parameters.
+*
+* INPUTS:
+*        ptpData  - PTP port configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetPortConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_PTP_PORT_CONFIG    *ptpData
+);
+
+/*******************************************************************************
+* gptpGetPortConfig
+*
+* DESCRIPTION:
+*       This routine reads PTP configuration parameters for a port.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpData  - PTP port configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetPortConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_PTP_PORT_CONFIG    *ptpData
+);
+
+/*******************************************************************************
+* gptpSetPTPEn
+*
+* DESCRIPTION:
+*       This routine enables or disables PTP.
+*
+* INPUTS:
+*        en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_BOOL        en
+);
+
+/*******************************************************************************
+* gptpGetPTPEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_BOOL        *en
+);
+
+/*******************************************************************************
+* gptpSetPortPTPEn
+*
+* DESCRIPTION:
+*       This routine enables or disables PTP on a port.
+*
+* INPUTS:
+*        en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetPortPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  MV_BOOL        en
+);
+
+/*******************************************************************************
+* gptpGetPortPTPEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP is enabled on a port.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetPortPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT MV_BOOL        *en
+);
+
+
+/*******************************************************************************
+* gptpGetPTPInt
+*
+* DESCRIPTION:
+*       This routine gets PTP interrupt status for each port.
+*        The PTP Interrupt bit gets set for a given port when an incoming PTP
+*        frame is time stamped and PTPArrIntEn for that port is set to 0x1.
+*        Similary PTP Interrupt bit gets set for a given port when an outgoing
+*        PTP frame is time stamped and PTPDepIntEn for that port is set to 0x1.
+*        This bit gets cleared upon software reading and clearing the corresponding
+*        time counter valid bits that are valid for that port.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpInt     - interrupt status for each port (bit 0 for port 0, bit 1 for port 1, etc.)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetPTPInt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U32        *ptpInt
+);
+
+/*******************************************************************************
+* gptpGetPTPGlobalTime
+*
+* DESCRIPTION:
+*       This routine gets the global timer value that is running off of the free
+*        running switch core clock.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpTime    - PTP global time
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetPTPGlobalTime
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U32        *ptpTime
+);
+
+/*******************************************************************************
+* gptpGetTimeStamped
+*
+* DESCRIPTION:
+*        This routine retrieves the PTP port status that includes time stamp value
+*        and sequce Id that are captured by PTP logic for a PTP frame that needs
+*        to be time stamped.
+*
+* INPUTS:
+*       port         - logical port number.
+*       timeToRead    - Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
+*
+* OUTPUTS:
+*        ptpStatus    - PTP port status
+*
+* RETURNS:
+*       GT_OK         - on success
+*       GT_FAIL     - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetTimeStamped
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN    GT_PTP_TIME    timeToRead,
+    OUT GT_PTP_TS_STATUS    *ptpStatus
+);
+
+/*******************************************************************************
+* gptpResetTimeStamp
+*
+* DESCRIPTION:
+*        This routine resets PTP Time valid bit so that PTP logic can time stamp
+*        a next PTP frame that needs to be time stamped.
+*
+* INPUTS:
+*       port         - logical port number.
+*       timeToReset    - Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK         - on success
+*       GT_FAIL     - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpResetTimeStamp
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN    GT_PTP_TIME    timeToReset
+);
+
+/*******************************************************************************
+* gptpGetReg
+*
+* DESCRIPTION:
+*       This routine reads PTP register.
+*
+* INPUTS:
+*       port         - logical port number.
+*       regOffset    - register to read
+*
+* OUTPUTS:
+*        data        - register data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  MV_U32        regOffset,
+    OUT MV_U32        *data
+);
+
+/*******************************************************************************
+* gptpSetReg
+*
+* DESCRIPTION:
+*       This routine writes data to PTP register.
+*
+* INPUTS:
+*       port         - logical port number
+*       regOffset    - register to be written
+*        data        - data to be written
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  MV_U32        regOffset,
+    IN  MV_U32        data
+);
+
+
+#ifdef CONFIG_AVB_FPGA
+
+/*******************************************************************************
+* gptpSetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine sets interrupt status of PTP logic.
+*
+* INPUTS:
+*        intStatus    - PTP Int Status
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32    intStatus
+);
+
+
+/*******************************************************************************
+* gptpGetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine gets interrupt status of PTP logic.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        intStatus    - PTP Int Status
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32    *intStatus
+);
+
+
+/*******************************************************************************
+* gptpSetFPGAIntEn
+*
+* DESCRIPTION:
+*       This routine enables PTP interrupt.
+*
+* INPUTS:
+*        intEn    - enable/disable PTP interrupt (1 to enable, 0 to disable)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetFPGAIntEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32    intEn
+);
+
+/*******************************************************************************
+* gptpGetClockSource
+*
+* DESCRIPTION:
+*       This routine gets PTP Clock source mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_SRC     *clkSrc
+);
+
+/*******************************************************************************
+* gptpSetClockSource
+*
+* DESCRIPTION:
+*       This routine sets PTP Clock source mode.
+*
+* INPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_SRC     clkSrc
+);
+
+/*******************************************************************************
+* gptpGetP9Mode
+*
+* DESCRIPTION:
+*       This routine gets Port 9 Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_P9_MODE     *mode
+);
+
+/*******************************************************************************
+* gptpSetP9Mode
+*
+* DESCRIPTION:
+*       This routine sets Port 9 Mode.
+*
+* INPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_P9_MODE     mode
+);
+
+/*******************************************************************************
+* gptpReset
+*
+* DESCRIPTION:
+*       This routine performs software reset for PTP logic.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpReset
+(
+    IN  GT_QD_DEV     *dev
+);
+
+
+/*******************************************************************************
+* gptpGetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP Duty Cycle Adjustment is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adjEn    - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_BOOL        *adjEn
+);
+
+
+/*******************************************************************************
+* gptpSetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PTP Duty Cycle Adjustment.
+*
+* INPUTS:
+*        adjEn    - GT_TRUE to enable, GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_BOOL        adjEn
+);
+
+
+/*******************************************************************************
+* gptpGetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine gets clock duty cycle adjustment value.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_ADJUSTMENT        *adj
+);
+
+/*******************************************************************************
+* gptpSetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine sets clock duty cycle adjustment value.
+*
+* INPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_ADJUSTMENT        *adj
+);
+
+/*******************************************************************************
+* gptpGetPLLEn
+*
+* DESCRIPTION:
+*       This routine checks if PLL is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+MV_STATUS gptpGetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_BOOL        *en,
+    OUT MV_U32        *freqSel
+);
+
+/*******************************************************************************
+* gptpSetPLLEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PLL device.
+*
+* INPUTS:
+*        en        - GT_TRUE to enable, GT_FALSE to disable
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*                  Meaningful only when enabling PLL device
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+MV_STATUS gptpSetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_BOOL        en,
+    IN  MV_U32        freqSel
+);
+#endif
+
+/* Amber APIs */
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+* gfdbGetMacAvb
+*
+* DESCRIPTION:
+*        ATU MAC entry in AVB mode.
+*        When enabled, ATU entries operate in AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_AVB_ENTRY, and
+*            GT_UC_STATIC_AVB_ENTRY
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_AVB_ENTRY, and
+*            GT_MC_PRIO_STATIC_AVB_ENTRY
+*
+*        When disabled, ATU entries operate in non-AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_NRL, and
+*            GT_UC_STATIC_NRL
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_UNLIMITED_RATE, and
+*            GT_MC_PRIO_STATIC_UNLIMITED_RATE
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if MacAvb is enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*
+*******************************************************************************/
+MV_STATUS gfdbGetMacAvb
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL     *mode
+);
+
+/*******************************************************************************
+* gfdbSetMacAvb
+*
+* DESCRIPTION:
+*        ATU MAC entry in AVB mode.
+*        When enabled, ATU entries operate in AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_AVB_ENTRY, and
+*            GT_UC_STATIC_AVB_ENTRY
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_AVB_ENTRY, and
+*            GT_MC_PRIO_STATIC_AVB_ENTRY
+*
+*        When disabled, ATU entries operate in non-AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_NRL, and
+*            GT_UC_STATIC_NRL
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_UNLIMITED_RATE, and
+*            GT_MC_PRIO_STATIC_UNLIMITED_RATE
+*
+* INPUTS:
+*        mode - GT_TRUE to enable MacAvb, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gfdbSetMacAvb
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        mode
+);
+
+/*******************************************************************************
+* gfdbGetPortAtuLearnLimit
+*
+* DESCRIPTION:
+*      Port's auto learning limit. When the limit is non-zero value, the number
+*        of MAC addresses that can be learned on this port are limited to the value
+*        specified in this API. When the learn limit has been reached any frame
+*        that ingresses this port with a source MAC address not already in the
+*        address database that is associated with this port will be discarded.
+*        Normal auto-learning will resume on the port as soon as the number of
+*        active unicast MAC addresses associated to this port is less than the
+*        learn limit.
+*        CPU directed ATU Load, Purge, or Move will not have any effect on the
+*        learn limit.
+*        This feature is disabled when the limit is zero.
+*        The following care is needed when enabling this feature:
+*            1) dsable learning on the ports
+*            2) flush all non-static addresses in the ATU
+*            3) define the desired limit for the ports
+*            4) re-enable learing on the ports
+*
+* INPUTS:
+*        port  - logical port number
+*
+* OUTPUTS:
+*        limit - auto learning limit ( 0 ~ 255 )
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gfdbGetPortAtuLearnLimit
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    OUT MV_U32       *limit
+);
+
+/* gtPCSCtrl.c */
+
+/*******************************************************************************
+* gpcsGetRGMIITimingDelay
+*
+* DESCRIPTION:
+*        RGMII receive/transmit Timing Control. This api adds delay to RXCLK for
+*        IND inputs and GTXCLK for OUTD outputs when port is in RGMII mode.
+*        Change to this bit are disruptive to normal operation. Hence any changes
+*        to this register must be done only while the port's link is down.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        rxmode - GT_FALSE for default setup, GT_TRUE for adding delay to rxclk
+*        txmode - GT_FALSE for default setup, GT_TRUE for adding delay to txclk
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gpcsGetRGMIITimingDelay
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_BOOL      *rxmode,
+    OUT MV_BOOL      *txmode
+);
+
+/*******************************************************************************
+* gpcsSetRGMIITimingDelay
+*
+* DESCRIPTION:
+*        RGMII receive/transmit Timing Control. This api adds delay to RXCLK for
+*        IND inputs and GTXCLK for OUTD outputs when port is in RGMII mode.
+*        Change to this bit are disruptive to normal operation. Hence any changes
+*        to this register must be done only while the port's link is down.
+*
+* INPUTS:
+*        port - the logical port number.
+*        rxmode - GT_FALSE for default setup, GT_TRUE for adding delay to rxclk
+*        txmode - GT_FALSE for default setup, GT_TRUE for adding delay to txclk
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetRGMIITimingDelay
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  MV_BOOL      rxmode,
+    IN  MV_BOOL      txmode
+);
+
+
+/* gtPortLed.c */
+
+/*******************************************************************************
+* gprtSetLED
+*
+* DESCRIPTION:
+*        This API allows to configure 4 LED sections, Pulse stretch, Blink rate,
+*        and special controls.
+*
+* INPUTS:
+*        port    - the logical port number
+*        cfg     - GT_LED_CFG value
+*        value     - value to be configured
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gprtSetLED
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    IN  MV_U32        value
+);
+
+
+/*******************************************************************************
+* gprtGetLED
+*
+* DESCRIPTION:
+*        This API allows to retrieve 4 LED sections, Pulse stretch, Blink rate,
+*        and special controls.
+*
+* INPUTS:
+*        port    - the logical port number
+*        cfg     - GT_LED_CFG value
+*
+* OUTPUTS:
+*        value     - configured value
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gprtGetLED
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    OUT MV_U32        *value
+);
+
+
+
+
+
+/* gtPortStatus.c */
+
+/*******************************************************************************
+* gprtGetQSizePerQPri
+*
+* DESCRIPTION:
+*        This routine gets egress queue size for port's each QPri (0 ~ 3).
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        counts - egress queue size per QPri (should be 4 * 16bytes)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtGetQSizePerQPri
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT MV_U16        *counts
+);
+
+
+/* gtSysCtrl.c */
+
+
+/*******************************************************************************
+* gsysGetARPwoBC
+*
+* DESCRIPTION:
+*       ARP detection without Broadcast checking. When enabled the switch core
+*       does not check for a Btoadcast MAC address as part of the ARP frame
+*       detection. It only checkes the Ether Type (0x0806).
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE if enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetARPwoBC
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_BOOL        *en
+);
+
+/*******************************************************************************
+* gsysSetARPwoBC
+*
+* DESCRIPTION:
+*       ARP detection without Broadcast checking. When enabled the switch core
+*       does not check for a Btoadcast MAC address as part of the ARP frame
+*       detection. It only checkes the Ether Type (0x0806).
+*
+* INPUTS:
+*       en - GT_TRUE to enable, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetARPwoBC
+(
+    IN  GT_QD_DEV    *dev,
+    IN  MV_BOOL     en
+);
+
+
+/*******************************************************************************
+* gsysGetCLK125En
+*
+* DESCRIPTION:
+*        Clock 125MHz Enable.
+*        When this feature is enabled, the CLK125 pin has a free running 125 MHz
+*        clock output.
+*        When it's disabled, the CLK125 pin will be in tri-state.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if 125MHz clock is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetCLK125En
+(
+    IN  GT_QD_DEV    *dev,
+    OUT MV_BOOL      *en
+);
+
+
+/*******************************************************************************
+* gsysSetCLK125En
+*
+* DESCRIPTION:
+*        Clock 125MHz Enable.
+*        When this feature is enabled, the CLK125 pin has a free running 125 MHz
+*        clock output.
+*        When it's disabled, the CLK125 pin will be in tri-state.
+*
+* INPUTS:
+*        en - GT_TRUE to enable 125 MHz clock, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysSetCLK125En
+(
+    IN GT_QD_DEV    *dev,
+    IN MV_BOOL        en
+);
+
+
+/* gtPriTable.c */
+
+/*******************************************************************************
+* gsysSetFPriOverrideTable
+*
+* DESCRIPTION:
+*         Frame Priority Override.
+*        When a frame enters a port, its type is determined and the type is used
+*        to access the Frame Priority Table. If the type's fPriEn (in GT_FPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Frame Priority will be overridden
+*        with the value written in fPriority (in GT_FPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*       entry - Frame Priority Override Table entry (GT_FPRI_TBL_ENTRY)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gsysSetFPriOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    IN  GT_FPRI_TBL_ENTRY    *entry
+);
+
+
+/*******************************************************************************
+* gsysGetFPriOverrideTable
+*
+* DESCRIPTION:
+*         Frame Priority Override.
+*        When a frame enters a port, its type is determined and the type is used
+*        to access the Frame Priority Table. If the type's fPriEn (in GT_FPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Frame Priority will be overridden
+*        with the value written in fPriority (in GT_FPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*
+* OUTPUTS:
+*       entry - Frame Priority Override Table entry (GT_FPRI_TBL_ENTRY)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_BAD_PARAM     - on unknown frame type
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gsysGetFPriOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    OUT GT_FPRI_TBL_ENTRY    *entry
+);
+
+
+/*******************************************************************************
+* gsysSetQPriAvbOverrideTable
+*
+* DESCRIPTION:
+*         Queue Priority Override for AVB enabled ports or AvbOverride enabled ports.
+*        When a frame enters a AVB port, its type is determined and the type is used
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gsysSetQPriAvbOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    IN  GT_QPRI_TBL_ENTRY    *entry
+);
+
+
+/*******************************************************************************
+* gsysGetQPriAvbOverrideTable
+*
+* DESCRIPTION:
+*         Queue Priority Override for AVB enabled ports or AvbOverride enabled ports.
+*        When a frame enters a AVB port, its type is determined and the type is used
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*
+* OUTPUTS:
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gsysGetQPriAvbOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    OUT GT_QPRI_TBL_ENTRY    *entry
+);
+
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtGet200Base
+*
+* DESCRIPTION:
+*        200 Base mode. This bit can be used to change the port's Px_GTXCLK
+*        frequency to 50MHz to support 200 BASE mode as follows:
+*        0 = 25MHz Px_GTXCLK
+*        1 = 50MHz Px_GTXCLK
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - 0 for 100Mbps, 1 for 200Mbps
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        C_Mode should be set to 0x2 in order for this API to work
+*
+*******************************************************************************/
+MV_STATUS gprtGet200Base
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT MV_U32      *mode
+);
+
+
+/*******************************************************************************
+* gprtSet200Base
+*
+* DESCRIPTION:
+*        200 Base mode. This bit can be used to change the port's Px_GTXCLK
+*        frequency to 50MHz to support 200 BASE mode as follows:
+*            0 = 25MHz Px_GTXCLK
+*            1 = 50MHz Px_GTXCLK
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - 0 for 100Mbps, 1 for 200Mbps
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        C_Mode should be set to 0x2 in order for this API to work
+*
+*******************************************************************************/
+MV_STATUS gprtSet200Base
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  MV_U32      mode
+);
+
+
+/* gtPIRL2.c */
+
+/*******************************************************************************
+* gpirl2WriteTSMResource
+*
+* DESCRIPTION:
+*        This routine writes rate resource bucket parameters in Time Slot Metering
+*        mode to the given resource of the port.
+*
+* INPUTS:
+*        port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 1).
+*        pirlData - PIRL TSM resource parameters.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Only Resource 0 and 1 can be supported for TSM Mode.
+*
+*******************************************************************************/
+MV_STATUS gpirl2WriteTSMResource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  MV_U32        irlRes,
+    IN  GT_PIRL2_TSM_DATA    *pirlData
+);
+
+
+/*******************************************************************************
+* gpirl2ReadTSMResource
+*
+* DESCRIPTION:
+*        This routine retrieves IRL Parameter.
+*        Returned ingressRate would be rough number. Instead, customSetup will
+*        have the exact configured value.
+*
+* INPUTS:
+*        port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 1).
+*
+* OUTPUTS:
+*        pirlData - PIRL resource parameters.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Only Resource 0 and 1 can be supported for TSM Mode.
+*
+*******************************************************************************/
+MV_STATUS gpirl2ReadTSMResource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  MV_U32        irlRes,
+    OUT GT_PIRL2_TSM_DATA    *pirlData
+);
+
+
+/* gtPTP.c */
+
+/*******************************************************************************
+* gtaiSetEventConfig
+*
+* DESCRIPTION:
+*       This routine sets TAI Event Capture configuration parameters.
+*
+* INPUTS:
+*        eventData  - TAI Event Capture configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtaiSetEventConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_TAI_EVENT_CONFIG    *eventData
+);
+
+
+/*******************************************************************************
+* gtaiGetEventConfig
+*
+* DESCRIPTION:
+*       This routine gets TAI Event Capture configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        eventData  - TAI Event Capture configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtaiGetEventConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_TAI_EVENT_CONFIG    *eventData
+);
+
+/*******************************************************************************
+* gtaiGetEventStatus
+*
+* DESCRIPTION:
+*       This routine gets TAI Event Capture status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        eventData  - TAI Event Capture configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtaiGetEventStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_TAI_EVENT_STATUS    *status
+);
+
+/*******************************************************************************
+* gtaiGetEventInt
+*
+* DESCRIPTION:
+*       This routine gets TAI Event Capture Interrupt status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        intStatus     - interrupt status for TAI Event capture
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtaiGetEventInt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_BOOL        *intStatus
+);
+
+/*******************************************************************************
+* gtaiSetClockSelect
+*
+* DESCRIPTION:
+*       This routine sets several clock select in TAI.
+*
+* INPUTS:
+*        clkSelect  - TAI clock select configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtaiSetClockSelect
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_TAI_CLOCK_SELECT    *clkSelect
+);
+
+/*******************************************************************************
+* gtaiGetClockSelect
+*
+* DESCRIPTION:
+*       This routine gets several clock select in TAI.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       clkSelect  - TAI clock select configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtaiGetClockSelect
+(
+    IN  GT_QD_DEV     *dev,
+    OUT  GT_TAI_CLOCK_SELECT    *clkSelect
+);
+
+/*******************************************************************************
+* gtaiGetTrigInt
+*
+* DESCRIPTION:
+*       This routine gets TAI Trigger Interrupt status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        intStatus     - interrupt status for TAI Trigger
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtaiGetTrigInt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_BOOL        *intStatus
+);
+
+/*******************************************************************************
+* gtaiClearTrigInt
+*
+* DESCRIPTION:
+*       This routine clear TAI Trigger Interrupt status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtaiClearTrigInt
+(
+    IN  GT_QD_DEV     *dev
+);
+
+/*******************************************************************************
+* gtaiSetTrigConfig
+*
+* DESCRIPTION:
+*       This routine sets TAI Trigger configuration parameters.
+*
+* INPUTS:
+*        trigEn    - enable/disable TAI Trigger.
+*        trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtaiSetTrigConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_BOOL     trigEn,
+    IN  GT_TAI_TRIGGER_CONFIG    *trigData
+);
+
+/*******************************************************************************
+* gtaiGetTrigConfig
+*
+* DESCRIPTION:
+*       This routine gets TAI Trigger configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        trigEn    - enable/disable TAI Trigger.
+*        trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtaiGetTrigConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_BOOL     *trigEn,
+    OUT GT_TAI_TRIGGER_CONFIG    *trigData
+);
+
+/*******************************************************************************
+* gtaiGetTSClkPer
+*
+* DESCRIPTION:
+*         Time Stamping Clock Period in pico seconds.
+*        This routine specifies the clock period for the time stamping clock supplied
+*        to the PTP hardware logic.
+*        This is the clock that is used by the hardware logic to update the PTP
+*        Global Time Counter.
+*
+* INPUTS:
+*         None.
+*
+* OUTPUTS:
+*        clk        - time stamping clock period
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gtaiGetTSClkPer
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U32        *clk
+);
+
+
+/*******************************************************************************
+* gtaiSetTSClkPer
+*
+* DESCRIPTION:
+*         Time Stamping Clock Period in pico seconds.
+*        This routine specifies the clock period for the time stamping clock supplied
+*        to the PTP hardware logic.
+*        This is the clock that is used by the hardware logic to update the PTP
+*        Global Time Counter.
+*
+* INPUTS:
+*        clk        - time stamping clock period
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gtaiSetTSClkPer
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        clk
+);
+
+/*******************************************************************************
+* gtaiSetMultiPTPSync
+*
+* DESCRIPTION:
+*         This routine sets Multiple PTP device sync mode and sync time (TrigGenAmt).
+*        When enabled, the hardware logic detects a low to high transition on the
+*        EventRequest(GPIO) and transfers the sync time into the PTP Global Time
+*        register. The EventCapTime is also updated at that instant.
+*
+* INPUTS:
+*        multiEn        - enable/disable Multiple PTP device sync mode
+*        syncTime    - sync time (valid only if multiEn is GT_TRUE)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
+*        and gtaiSetTimeDec APIs are not operational.
+*
+*******************************************************************************/
+MV_STATUS gtaiSetMultiPTPSync
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_BOOL     multiEn,
+    IN  MV_32        syncTime
+);
+
+/*******************************************************************************
+* gtaiGetMultiPTPSync
+*
+* DESCRIPTION:
+*         This routine gets Multiple PTP device sync mode and sync time (TrigGenAmt).
+*        When enabled, the hardware logic detects a low to high transition on the
+*        EventRequest(GPIO) and transfers the sync time into the PTP Global Time
+*        register. The EventCapTime is also updated at that instant.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        multiEn        - enable/disable Multiple PTP device sync mode
+*        syncTime    - sync time (valid only if multiEn is GT_TRUE)
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
+*        and gtaiSetTimeDec APIs are not operational.
+*
+*******************************************************************************/
+MV_STATUS gtaiGetMultiPTPSync
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_BOOL     *multiEn,
+    OUT MV_32        *syncTime
+);
+
+/*******************************************************************************
+* gtaiGetTimeIncDec
+*
+* DESCRIPTION:
+*         This routine retrieves Time increment/decrement setup.
+*        This amount specifies the number of units of PTP Global Time that need to be
+*        incremented or decremented. This is used for adjusting the PTP Global Time
+*        counter value by a certain amount.
+*
+* INPUTS:
+*         None.
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*        inc        - GT_TRUE if increment, GT_FALSE if decrement
+*        amount    - increment/decrement amount
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gtaiGetTimeIncDec
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_BOOL        *en,
+    OUT MV_BOOL        *inc,
+    OUT MV_U32        *amount
+);
+
+/*******************************************************************************
+* gtaiSetTimeInc
+*
+* DESCRIPTION:
+*         This routine enables time increment by the specifed time increment amount.
+*        The amount specifies the number of units of PTP Global Time that need to be
+*        incremented. This is used for adjusting the PTP Global Time counter value by
+*        a certain amount.
+*        Increment occurs just once.
+*
+* INPUTS:
+*        amount    - time increment amount (0 ~ 0xFF)
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gtaiSetTimeInc
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        amount
+);
+
+/*******************************************************************************
+* gtaiSetTimeDec
+*
+* DESCRIPTION:
+*         This routine enables time decrement by the specifed time decrement amount.
+*        The amount specifies the number of units of PTP Global Time that need to be
+*        decremented. This is used for adjusting the PTP Global Time counter value by
+*        a certain amount.
+*        Decrement occurs just once.
+*
+* INPUTS:
+*        amount    - time decrement amount (0 ~ 0x7FF)
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gtaiSetTimeDec
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        amount
+);
+
+
+/*******************************************************************************
+* gavbGetPriority
+*
+* DESCRIPTION:
+*        Priority overwrite.
+*        Supported priority type is defined as GT_AVB_PRI_TYPE.
+*        Priority is either 3 bits or 2 bits depending on priority type.
+*            GT_AVB_HI_FPRI        - priority is 0 ~ 7
+*            GT_AVB_HI_QPRI        - priority is 0 ~ 3
+*            GT_AVB_LO_FPRI        - priority is 0 ~ 7
+*            GT_AVB_LO_QPRI        - priority is 0 ~ 3
+*            GT_LEGACY_HI_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_HI_QPRI    - priority is 0 ~ 3
+*            GT_LEGACY_LO_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_LO_QPRI    - priority is 0 ~ 3
+*
+* INPUTS:
+*         priType    - GT_AVB_PRI_TYPE
+*
+* OUTPUTS:
+*        pri    - priority
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbGetPriority
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_PRI_TYPE        priType,
+    OUT MV_U32        *pri
+);
+
+/*******************************************************************************
+* gavbSetPriority
+*
+* DESCRIPTION:
+*        Priority overwrite.
+*        Supported priority type is defined as GT_AVB_PRI_TYPE.
+*        Priority is either 3 bits or 2 bits depending on priority type.
+*            GT_AVB_HI_FPRI        - priority is 0 ~ 7
+*            GT_AVB_HI_QPRI        - priority is 0 ~ 3
+*            GT_AVB_LO_FPRI        - priority is 0 ~ 7
+*            GT_AVB_LO_QPRI        - priority is 0 ~ 3
+*            GT_LEGACY_HI_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_HI_QPRI    - priority is 0 ~ 3
+*            GT_LEGACY_LO_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_LO_QPRI    - priority is 0 ~ 3
+*
+* INPUTS:
+*         priType    - GT_AVB_PRI_TYPE
+*        pri    - priority
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbSetPriority
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_PRI_TYPE        priType,
+    IN  MV_U32        pri
+);
+
+/*******************************************************************************
+* gavbGetAVBHiLimit
+*
+* DESCRIPTION:
+*        AVB Hi Frame Limit.
+*        When these bits are zero, normal frame processing occurs.
+*        When it's non-zero, they are used to define the maximum frame size allowed
+*        for AVB frames that can be placed into the GT_AVB_HI_QPRI queue. Frames
+*        that are over this size limit are filtered. The only exception to this
+*        is non-AVB frames that get their QPriAvb assigned by the Priority Override
+*        Table
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        limit    - Hi Frame Limit
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbGetAVBHiLimit
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U32        *limit
+);
+
+/*******************************************************************************
+* gavbSetAVBHiLimit
+*
+* DESCRIPTION:
+*        AVB Hi Frame Limit.
+*        When these bits are zero, normal frame processing occurs.
+*        When it's non-zero, they are used to define the maximum frame size allowed
+*        for AVB frames that can be placed into the GT_AVB_HI_QPRI queue. Frames
+*        that are over this size limit are filtered. The only exception to this
+*        is non-AVB frames that get their QPriAvb assigned by the Priority Override
+*        Table
+*
+* INPUTS:
+*        limit    - Hi Frame Limit
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbSetAVBHiLimit
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        limit
+);
+
+/*******************************************************************************
+* gavbGetPtpExtClk
+*
+* DESCRIPTION:
+*        PTP external clock select.
+*        When this bit is cleared to a zero, the PTP core gets its clock from
+*        an internal 125MHz clock based on the device's XTAL_IN input.
+*        When this bit is set to a one, the PTP core gets its clock from the device's
+*        PTP_EXTCLK pin.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        extClk    - GT_TRUE if external clock is selected, GT_FALSE otherwise
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbGetPtpExtClk
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_BOOL        *extClk
+);
+
+/*******************************************************************************
+* gavbSetPtpExtClk
+*
+* DESCRIPTION:
+*        PTP external clock select.
+*        When this bit is cleared to a zero, the PTP core gets its clock from
+*        an internal 125MHz clock based on the device's XTAL_IN input.
+*        When this bit is set to a one, the PTP core gets its clock from the device's
+*        PTP_EXTCLK pin.
+*
+* INPUTS:
+*        extClk    - GT_TRUE if external clock is selected, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbSetPtpExtClk
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_BOOL        extClk
+);
+
+/*******************************************************************************
+* gavbGetRecClkSel
+*
+* DESCRIPTION:
+*        Synchronous Ethernet Recovered Clock Select.
+*        This field indicate the internal PHY number whose recovered clock will
+*        be presented on the SE_RCLK0 or SE_RCLK1 pin depending on the recClk selection.
+*
+* INPUTS:
+*        recClk    - GT_AVB_RECOVERED_CLOCK type
+*
+* OUTPUTS:
+*        clkSel    - recovered clock selection
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbGetRecClkSel
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_RECOVERED_CLOCK    recClk,
+    OUT MV_U32        *clkSel
+);
+
+
+/*******************************************************************************
+* gavbSetRecClkSel
+*
+* DESCRIPTION:
+*        Synchronous Ethernet Recovered Clock Select.
+*        This field indicate the internal PHY number whose recovered clock will
+*        be presented on the SE_RCLK0 or SE_RCLK1 pin depending on the recClk selection.
+*
+* INPUTS:
+*        recClk    - GT_AVB_RECOVERED_CLOCK type
+*        clkSel    - recovered clock selection (should be less than 8)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbSetRecClkSel
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_RECOVERED_CLOCK    recClk,
+    IN  MV_U32        clkSel
+);
+
+/*******************************************************************************
+* gavbGetAvbOuiBytes
+*
+* DESCRIPTION:
+*        AVB OUI Limit Filter bytes(0 ~ 2).
+*        When all three of the AvbOui Bytes are zero, normal frame processing occurs.
+*        When any of the three AvbOui Bytes are non-zero, all AVB frames must have a
+*        destination address whose 1st three bytes of the DA match these three
+*        AvbOui Bytes or the frame will be filtered.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        ouiBytes    - 3 bytes of OUI field in Ethernet address format
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbGetAvbOuiBytes
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U8        *obiBytes
+);
+
+/*******************************************************************************
+* gavbSetAvbOuiBytes
+*
+* DESCRIPTION:
+*        AVB OUI Limit Filter bytes(0 ~ 2).
+*        When all three of the AvbOui Bytes are zero, normal frame processing occurs.
+*        When any of the three AvbOui Bytes are non-zero, all AVB frames must have a
+*        destination address whose 1st three bytes of the DA match these three
+*        AvbOui Bytes or the frame will be filtered.
+*
+* INPUTS:
+*        ouiBytes    - 3 bytes of OUI field in Ethernet address format
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbSetAvbOuiBytes
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U8        *obiBytes
+);
+
+/*******************************************************************************
+* gavbGetAvbMode
+*
+* DESCRIPTION:
+*        Port's AVB Mode.
+*
+* INPUTS:
+*        port    - the logical port number
+*
+* OUTPUTS:
+*        mode    - GT_AVB_MODE type
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbGetAvbMode
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_AVB_MODE    *mode
+);
+
+/*******************************************************************************
+* gavbSetAvbMode
+*
+* DESCRIPTION:
+*        Port's AVB Mode.
+*
+* INPUTS:
+*        port    - the logical port number
+*        mode    - GT_AVB_MODE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbSetAvbMode
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_AVB_MODE    mode
+);
+
+/*******************************************************************************
+* gavbGetAvbOverride
+*
+* DESCRIPTION:
+*        AVB Override.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the egress portion of this port is considered AVB even if
+*        the ingress portion is not.
+*
+* INPUTS:
+*        port    - the logical port number
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbGetAvbOverride
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT MV_BOOL        *en
+);
+
+/*******************************************************************************
+* gavbSetAvbOverride
+*
+* DESCRIPTION:
+*        AVB Override.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the egress portion of this port is considered AVB even if
+*        the ingress portion is not.
+*
+* INPUTS:
+*        port    - the logical port number
+*        en        - GT_TRUE to enable, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbSetAvbOverride
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  MV_BOOL        en
+);
+
+
+/*******************************************************************************
+* gavbGetFilterBadAvb
+*
+* DESCRIPTION:
+*        Filter Bad AVB frames.
+*        When disabled, normal frame processing occurs.
+*        When enabled, frames that are considered Bad AVB frames are filtered.
+*
+* INPUTS:
+*        port    - the logical port number
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbGetFilterBadAvb
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT MV_BOOL        *en
+);
+
+/*******************************************************************************
+* gavbSetFilterBadAvb
+*
+* DESCRIPTION:
+*        Filter Bad AVB frames.
+*        When disabled, normal frame processing occurs.
+*        When enabled, frames that are considered Bad AVB frames are filtered.
+*
+* INPUTS:
+*        port    - the logical port number
+*        en        - GT_TRUE to enable, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbSetFilterBadAvb
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  MV_BOOL        en
+);
+
+
+/*******************************************************************************
+* gavbGetAvbTunnel
+*
+* DESCRIPTION:
+*        AVB Tunnel.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the port based VLAN Table masking, 802.1Q VLAN membership
+*        masking and the Trunk Masking is bypassed for any frame entering this port
+*        that is considered AVB by DA. This includes unicast as well as multicast
+*        frame
+*
+* INPUTS:
+*        port    - the logical port number
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbGetAvbTunnel
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT MV_BOOL        *en
+);
+
+
+/*******************************************************************************
+* gavbSetAvbTunnel
+*
+* DESCRIPTION:
+*        AVB Tunnel.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the port based VLAN Table masking, 802.1Q VLAN membership
+*        masking and the Trunk Masking is bypassed for any frame entering this port
+*        that is considered AVB by DA. This includes unicast as well as multicast
+*        frame
+*
+* INPUTS:
+*        port    - the logical port number
+*        en        - GT_TRUE to enable, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbSetAvbTunnel
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  MV_BOOL        en
+);
+
+
+/*******************************************************************************
+* gavbGetAvbFramePolicy
+*
+* DESCRIPTION:
+*        AVB Hi or Lo frame policy mapping.
+*        Supported policies are defined in GT_AVB_FRAME_POLICY.
+*
+* INPUTS:
+*        port    - the logical port number
+*        fType    - GT_AVB_FRAME_TYPE
+*
+* OUTPUTS:
+*        policy    - GT_AVB_FRAME_POLICY
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbGetAvbFramePolicy
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN    GT_AVB_FRAME_TYPE    fType,
+    OUT GT_AVB_FRAME_POLICY        *policy
+);
+
+
+/*******************************************************************************
+* gavbSetAvbFramePolicy
+*
+* DESCRIPTION:
+*        AVB Hi or Lo frame policy mapping.
+*        Supported policies are defined in GT_AVB_FRAME_POLICY.
+*
+* INPUTS:
+*        port    - the logical port number
+*        fType    - GT_AVB_FRAME_TYPE
+*        policy    - GT_AVB_FRAME_POLICY
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+MV_STATUS gavbSetAvbFramePolicy
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN    GT_AVB_FRAME_TYPE    fType,
+    IN  GT_AVB_FRAME_POLICY        policy
+);
+
+/* Amber QAV API */
+/*******************************************************************************/
+/* Amber QAV API */
+/*******************************************************************************
+* gqavSetPortQpriXQTSToken
+*
+* DESCRIPTION:
+*        This routine set Priority Queue 0-3 time slot tokens on a port.
+*        The setting value is number of tokens that need to be subtracted at each
+*        QTS interval boundary.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue     - 0 - 3
+*        qtsToken - number of tokens.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gqavSetPortQpriXQTSToken
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  MV_U8        queue,
+    IN  MV_U16        qtsToken
+);
+
+/*******************************************************************************
+* gqavGetPortQpriXQTSToken
+*
+* DESCRIPTION:
+*        This routine get Priority Queue 0-3 time slot tokens on a port.
+*        The setting value is number of tokens that need to be subtracted at each
+*        QTS interval boundary.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue - 0 - 3
+*
+* OUTPUTS:
+*        qtsToken - number of tokens
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gqavGetPortQpriXQTSToken
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  MV_U8        queue,
+    OUT MV_U16        *qtsToken
+);
+
+/*******************************************************************************
+* gqavSetPortQpriXBurstBytes
+*
+* DESCRIPTION:
+*        This routine set Priority Queue 0-3 Burst Bytes on a port.
+*        This value specifies the number of credits in bytes that can be
+*        accumulated when the queue is blocked from sending out a frame due to
+*        higher priority queue frames being sent out.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue - 0 - 3
+*        burst - number of credits in bytes .
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavSetPortQpriXBurstBytes
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  MV_U8        queue,
+    IN  MV_U16        burst
+);
+
+/*******************************************************************************
+* gqavGetPortQpriXBurstBytes
+*
+* DESCRIPTION:
+*        This routine get Priority Queue 0-3 Burst Bytes on a port.
+*        This value specifies the number of credits in bytes that can be
+*        accumulated when the queue is blocked from sending out a frame due to
+*        higher priority queue frames being sent out.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue    - 0 - 3
+*
+* OUTPUTS:
+*        burst - number of credits in bytes .
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavGetPortQpriXBurstBytes
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  MV_U8        queue,
+    OUT MV_U16        *burst
+);
+
+/*******************************************************************************
+* gqavSetPortQavEnable
+*
+* DESCRIPTION:
+*        This routine set QAV enable status on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*        en        - GT_TRUE: QAV enable, GT_FALSE: QAV disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavSetPortQavEnable
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  MV_BOOL        en
+);
+
+/*******************************************************************************
+* gqavGetPortQavEnable
+*
+* DESCRIPTION:
+*        This routine get QAV enable status on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*
+* OUTPUTS:
+*        en        - GT_TRUE: QAV enable, GT_FALSE: QAV disable
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavGetPortQavEnable
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT MV_BOOL        *en
+);
+
+/*******************************************************************************/
+/* QAV Global registers processing */
+/*******************************************************************************
+* gqavSetGlobalAdminMGMT
+*
+* DESCRIPTION:
+*        This routine set to accept Admit Management Frames always.
+*
+* INPUTS:
+*        en - GT_TRUE to set MGMT frame accepted always,
+*             GT_FALSE do not set MGMT frame accepted always
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavSetGlobalAdminMGMT
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_BOOL        en
+);
+
+/*******************************************************************************
+* gqavGetGlobalAdminMGMT
+*
+* DESCRIPTION:
+*        This routine get setting of Admit Management Frames always.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to set MGMT frame accepted always,
+*             GT_FALSE do not set MGMT frame accepted always
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavGetGlobalAdminMGMT
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_BOOL        *en
+);
+
+/*******************************************************************************
+* gqavSetGlobalIsoPtrThreshold
+*
+* DESCRIPTION:
+*        This routine set Global Isochronous Queue Pointer Threshold.
+*        This field indicates the total number of isochronous pointers
+*        that are reserved for isochronous streams. The value is expected to be
+*        computed in SRP software and programmed into hardware based on the total
+*        aggregate isochronous streams configured to go through this device..
+*
+* INPUTS:
+*        isoPtrs -  total number of isochronous pointers
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavSetGlobalIsoPtrThreshold
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U16        isoPtrs
+);
+
+/*******************************************************************************
+* gqavGetGlobalIsoPtrThreshold
+*
+* DESCRIPTION:
+*        This routine get Global Isochronous Queue Pointer Threshold.
+*        This field indicates the total number of isochronous pointers
+*        that are reserved for isochronous streams. The value is expected to be
+*        computed in SRP software and programmed into hardware based on the total
+*        aggregate isochronous streams configured to go through this device..
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        isoPtrs -  total number of isochronous pointers
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavGetGlobalIsoPtrThreshold
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U16        *isoPtrs
+);
+
+/*******************************************************************************
+* gqavSetGlobalDisQSD4MGMT
+*
+* DESCRIPTION:
+*        This routine set Disable Queue Scheduler Delays for Management frames..
+*
+* INPUTS:
+*        en - GT_TRUE, it indicates to the Queue Controller to disable applying Queue
+*            Scheduler Delays and the corresponding rate regulator does not account
+*            for MGMT frames through this queue.
+*            GT_FALSE, the MGMT frames follow similar rate regulation and delay
+*            regulation envelope as specified for the isochronous queue that the
+*            MGMT frames are sharing with.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavSetGlobalDisQSD4MGMT
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_BOOL        en
+);
+
+/*******************************************************************************
+* gqavGetGlobalDisQSD4MGMT
+*
+* DESCRIPTION:
+*        This routine Get Disable Queue Scheduler Delays for Management frames..
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE, it indicates to the Queue Controller to disable applying Queue
+*            Scheduler Delays and the corresponding rate regulator does not account
+*            for MGMT frames through this queue.
+*            GT_FALSE, the MGMT frames follow similar rate regulation and delay
+*            regulation envelope as specified for the isochronous queue that the
+*            MGMT frames are sharing with.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavGetGlobalDisQSD4MGMT
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_BOOL        *en
+);
+
+/*******************************************************************************
+* gqavSetGlobalInterrupt
+*
+* DESCRIPTION:
+*        This routine set QAV interrupt enable,
+*        The QAV interrypts include:
+*        [GT_QAV_INT_ENABLE_ENQ_LMT_BIT]      # EnQ Limit Interrupt Enable
+*        [GT_QAV_INT_ENABLE_ISO_DEL_BIT]      # Iso Delay Interrupt Enable
+*        [GT_QAV_INT_ENABLE_ISO_DIS_BIT]      # Iso Discard Interrupt Enable
+*        [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded
+*                                              Interrupt Enable
+*
+* INPUTS:
+*        intEn - [GT_QAV_INT_ENABLE_ENQ_LMT_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_DEL_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_DIS_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavSetGlobalInterrupt
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U16        intEn
+);
+
+/*******************************************************************************
+* gqavGetGlobalInterrupt
+*
+* DESCRIPTION:
+*       This routine get QAV interrupt status and enable status,
+*        The QAV interrypt status include:
+*         [GT_QAV_INT_STATUS_ENQ_LMT_BIT]      # Enqueue Delay Limit exceeded
+*         [GT_QAV_INT_STATUS_ISO_DEL_BIT]      # Iso Delay Interrupt Status
+*         [GT_QAV_INT_STATUS_ISO_DIS_BIT]      # Iso Discard Interrupt Status
+*         [GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded
+*                                                Interrupt Status
+*        The QAV interrypt enable status include:
+*         [GT_QAV_INT_ENABLE_ENQ_LMT_BIT]      # EnQ Limit Interrupt Enable
+*         [GT_QAV_INT_ENABLE_ISO_DEL_BIT]      # Iso Delay Interrupt Enable
+*         [GT_QAV_INT_ENABLE_ISO_DIS_BIT]      # Iso Discard Interrupt Enable
+*         [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded
+*                                                  Interrupt Enable
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        intEnSt - [GT_QAV_INT_STATUS_ENQ_LMT_BIT] OR
+*                [GT_QAV_INT_STATUS_ISO_DEL_BIT] OR
+*                [GT_QAV_INT_STATUS_ISO_DIS_BIT] OR
+*                [GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT] OR
+*                [GT_QAV_INT_ENABLE_ENQ_LMT_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_DEL_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_DIS_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavGetGlobalInterrupt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U16        *intEnSt
+);
+
+/*******************************************************************************
+* gqavGetGlobalIsoInterruptPort
+*
+* DESCRIPTION:
+*        This routine get Isochronous interrupt port.
+*        This field indicates the port number for IsoDisInt or IsoLimitExInt
+*        bits. Only one such interrupt condition can be detected by hardware at one
+*        time. Once an interrupt bit has been set along with the IsoIntPort, the
+*        software would have to come and clear the bits before hardware records
+*        another interrupt event.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port - port number for IsoDisInt or IsoLimitExInt bits.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavGetGlobalIsoInterruptPort
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U8        *port
+);
+
+/*******************************************************************************
+* gqavSetGlobalIsoDelayLmt
+*
+* DESCRIPTION:
+*        This routine set Isochronous queue delay Limit
+*        This field represents a per-port isochronous delay limit that
+*        will be checked by the queue controller logic to ensure no isochronous
+*        packets suffer more than this delay w.r.t to their eligibility time slot.
+*        This represents the number of Queue Time Slots. The interval for the QTS
+*        can be configured using the register in Qav Global Configuration, Offset 0x2.
+*
+* INPUTS:
+*        limit - per-port isochronous delay limit.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavSetGlobalIsoDelayLmt
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U8        limit
+);
+
+/*******************************************************************************
+* gqavGetGlobalIsoDelayLmt
+*
+* DESCRIPTION:
+*        This routine get Isochronous queue delay Limit
+*        This field represents a per-port isochronous delay limit that
+*        will be checked by the queue controller logic to ensure no isochronous
+*        packets suffer more than this delay w.r.t to their eligibility time slot.
+*        This represents the number of Queue Time Slots. The interval for the QTS
+*        can be configured using the register in Qav Global Configuration, Offset 0x2.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        limit - per-port isochronous delay limit.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavGetGlobalIsoDelayLmt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U8        *limit
+);
+
+/*******************************************************************************
+* gqavSetGlobalIsoMonEn
+*
+* DESCRIPTION:
+*       This routine set Isochronous monitor enable
+*        Set GT_TRUE: this bit enables the statistics gathering capabilities stated
+*        in PTP Global Status Registers Offset 0xD, 0xE and 0xF. Once enabled, the
+*        software is expected to program the IsoMonPort (PTP Global Status Offset
+*        0xD) indicating which port of the device does the software wants to monitor.
+*        Upon setting this bit, the hardware collects IsoHiDisCtr, IsoLoDisCtr and
+*        IsoSchMissCtr values for the port indicated by IsoMonPort till this bit is
+*        set to a zero.
+*        Set GT_FALSE: this bit disables the statistics gathering capabilities.
+*
+* INPUTS:
+*        en - GT_TRUE / GT_FALSE.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavSetGlobalIsoMonEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_BOOL        en
+);
+
+/*******************************************************************************
+* gqavGetGlobalIsoMonEn
+*
+* DESCRIPTION:
+*        This routine get Isochronous monitor enable
+*        Set GT_TRUE: this bit enables the statistics gathering capabilities stated
+*        in PTP Global Status Registers Offset 0xD, 0xE and 0xF. Once enabled, the
+*        software is expected to program the IsoMonPort (PTP Global Status Offset
+*        0xD) indicating which port of the device does the software wants to monitor.
+*        Upon setting this bit, the hardware collects IsoHiDisCtr, IsoLoDisCtr and
+*        IsoSchMissCtr values for the port indicated by IsoMonPort till this bit is
+*        set to a zero.
+*        Set GT_FALSE: this bit disables the statistics gathering capabilities.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE / GT_FALSE.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavGetGlobalIsoMonEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_BOOL        *en
+);
+
+/*******************************************************************************
+* gqavSetGlobalIsoMonPort
+*
+* DESCRIPTION:
+*        This routine set Isochronous monitoring port.
+*        This field is updated by software along with Iso Mon En bit
+*        (Qav Global Status, offset 0xD) and it indicates the port number that
+*        the software wants the hardware to start monitoring i.e., start updating
+*        IsoHiDisCtr, IsoLoDisCtr and IsoSchMissCtr. The queue controller clears
+*        the above stats when IsoMonPort is changed..
+*
+* INPUTS:
+*        port -  port number .
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavSetGlobalIsoMonPort
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U16        port
+);
+
+/*******************************************************************************
+* gqavGetGlobalIsoMonPort
+*
+* DESCRIPTION:
+*        This routine get Isochronous monitoring port.
+*        This field is updated by software along with Iso Mon En bit
+*        (Qav Global Status, offset 0xD) and it indicates the port number that
+*        the software wants the hardware to start monitoring i.e., start updating
+*        IsoHiDisCtr, IsoLoDisCtr and IsoSchMissCtr. The queue controller clears
+*        the above stats when IsoMonPort is changed..
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port -  port number.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavGetGlobalIsoMonPort
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U16        *port
+);
+
+/*******************************************************************************
+* gqavSetGlobalIsoHiDisCtr
+*
+* DESCRIPTION:
+*        This routine set Isochronous hi queue discard counter.
+*        This field is updated by hardware when instructed to do so by
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD.
+*        This is an upcounter of number of isochronous hi packets discarded
+*        by Queue Controller.
+*
+* INPUTS:
+*        disCtr - upcounter of number of isochronous hi packets discarded
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavSetGlobalIsoHiDisCtr
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U8        disCtr
+);
+
+/*******************************************************************************
+* gqavGetGlobalIsoHiDisCtr
+*
+* DESCRIPTION:
+*        This routine get Isochronous hi queue discard counter.
+*        This field is updated by hardware when instructed to do so by
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD.
+*        This is an upcounter of number of isochronous hi packets discarded
+*        by Queue Controller.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        disCtr - upcounter of number of isochronous hi packets discarded
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavGetGlobalIsoHiDisCtr
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U8        *disCtr
+);
+
+/*******************************************************************************
+* gqavSetGlobalIsoLoDisCtr
+*
+* DESCRIPTION:
+*        This routine set Isochronous Lo queue discard counter.
+*        This field is updated by hardware when instructed to do so by
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD.
+*        This is an upcounter of number of isochronous lo packets discarded
+*        by Queue Controller.
+*
+* INPUTS:
+*        disCtr - upcounter of number of isochronous lo packets discarded
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavSetGlobalIsoLoDisCtr
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U8        disCtr
+);
+
+/*******************************************************************************
+* gqavGetGlobalIsoLoDisCtr
+*
+* DESCRIPTION:
+*        This routine set Isochronous Lo queue discard counter.
+*        This field is updated by hardware when instructed to do so by
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD.
+*        This is an upcounter of number of isochronous lo packets discarded
+*        by Queue Controller.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        disCtr - upcounter of number of isochronous lo packets discarded
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gqavGetGlobalIsoLoDisCtr
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U8        *disCtr
+);
+
+/*******************************************************************************
+* gsysSetUseIpMappingTable
+*
+* DESCRIPTION:
+*        This API set to use IP Frame Priorities from this table.
+*        Set GT_TRUE:  The IP_FPRI data in this table is used as the frames
+*            initial IP_FPRI.
+*        Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the
+*            frames initial IP_FPRI is generated by using the frames IP_QPRI
+*            as the IP_FPRIs upper two bits, and the IP_FPRIs lowest bit comes
+*            from bit 0 of the frames source ports Default PRI (Port offset 0x07).
+*
+* INPUTS:
+*        en    - [GT_TRUE] / [GT_FALSE]
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysSetUseIpMappingTable
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_BOOL            en
+);
+
+/*******************************************************************************
+* gsysGetUseIpMappingTable
+*
+* DESCRIPTION:
+*        This API get to use IP Frame Priorities from this table.
+*        Set GT_TRUE:  The IP_FPRI data in this table is used as the frames
+*            initial IP_FPRI.
+*        Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the
+*            frames initial IP_FPRI is generated by using the frames IP_QPRI
+*            as the IP_FPRIs upper two bits, and the IP_FPRIs lowest bit comes
+*            from bit 0 of the frames source ports Default PRI (Port offset 0x07).
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en    - [GT_TRUE] / [GT_FALSE]
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysGetUseIpMappingTable
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_BOOL            *en
+);
+
+/*******************************************************************************
+* gsysSetIpMappingPrio
+*
+* DESCRIPTION:
+*        Set IPv4 and IPv6 Frame Priority Mapping, and
+*        IPv4 and IPv6 Queue Priority Mapping.
+*       The ipFpri value is used as the frames initial FPRI when the frame is
+*        an IPv4 or an IPv6 frame, and the ports InitialPri (Port offset 0x04)
+*        is configured to use IP FPris.
+*       The ipQpri value is used as the frames initial QPRI when the frame is
+*        an IPv4 or an IPv6 frame, and the ports InitialPri and TagIfBoth
+*        registers (Port offset 0x04) are configured to use IP QPris.
+*
+* INPUTS:
+*        point - Pointer to the Ip Mapping Table.
+*                0 - 0x3f;
+*        ipFpri -  The value is 0 - 7
+*        ipQpri -  The value is 0 - 3.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysSetIpMappingPrio
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U32            point,
+    IN  MV_U8            ipFpri,
+    IN  MV_U8            ipQpri
+);
+
+/*******************************************************************************
+* gsysGetIpMappingPrio
+*
+* DESCRIPTION:
+*        Get IPv4 and IPv6 Frame Priority Mapping, and
+*        IPv4 and IPv6 Queue Priority Mapping.
+*       The ipFpri value is used as the frames initial FPRI when the frame is
+*        an IPv4 or an IPv6 frame, and the ports InitialPri (Port offset 0x04)
+*        is configured to use IP FPris.
+*        The ipQpri value is used as the frames initial QPRI when the frame is
+*        an IPv4 or an IPv6 frame, and the ports InitialPri and TagIfBoth
+*        registers (Port offset 0x04) are configured to use IP QPris.
+*
+* INPUTS:
+*        point - Pointer to the Ip Mapping Table.
+*                0 - 0x3f;
+*
+* OUTPUTS:
+*        ipFpri -  The value is 0 - 7
+*        ipQpri -  The value is 0 - 3.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+MV_STATUS gsysGetIpMappingPrio
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U32            point,
+    OUT  MV_U8            *ipFpri,
+    OUT  MV_U8            *ipQpri
+);
+
+/*******************************************************************************
+* gsysReadEeprom
+*
+* DESCRIPTION:
+*        Read EEPROM from EEPROMs address where the EEOp is performed.
+*
+* INPUTS:
+*        addr - EEPROM Address.
+*
+* OUTPUTS:
+*        data -  Data that was read back from the EEPROM.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysReadEeprom
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U32            addr,
+    OUT  MV_U8            *data
+);
+
+/*******************************************************************************
+* gsysWriteEeprom
+*
+* DESCRIPTION:
+*        Write EEPROM at the EEPROMs address where the EEOp is performed.
+*
+* INPUTS:
+*        addr - EEPROM Address.
+*        data - Data to be written to the EEPROM
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysWriteEeprom
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U32            addr,
+    IN  MV_U8            data
+);
+
+/*******************************************************************************
+* gsysRestartEeprom
+*
+* DESCRIPTION:
+*        Restart Register Loader execution at the EEPROMs address where the EEOp
+*        is performed
+*
+* INPUTS:
+*        addr - EEPROM Address. .
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysRestartEeprom
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U32            addr
+);
+
+/*******************************************************************************
+* gsysHaltEeprom
+*
+* DESCRIPTION:
+*        Halt (stop executing the EEPROM if its not already stopped)
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysHaltEeprom
+(
+    IN  GT_QD_DEV         *dev
+);
+
+/*******************************************************************************
+* gsysGetStEeprom
+*
+* DESCRIPTION:
+*        Get EEPROM status. They are Register Loader Running status and EEPROM
+*        Write Enable status
+*        runSt is GT_TRUE: Register Loader Running, whenever the register loader
+*            is busy executing the instructions contained in the EEPROM.
+*        writeEn is GT_TRUE: EEPROM Write Enable, that indicates that writing to
+*            the EEPROM is possible.
+*        writeEn is GT_FALSE: the Write EEPROM EEOp above will not do anything.
+*            This reflects the value of the EE_WE configuration pin after Reset.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        runSt   -   [GT_TRUE] / [GT_FALSE)
+*        writeEn -   [GT_TRUE] / [GT_FALSE)
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysGetStEeprom
+(
+    IN  GT_QD_DEV         *dev,
+    OUT MV_BOOL            *writeEn,
+    OUT MV_BOOL            *runSt
+);
+
+/*******************************************************************************
+* gsysSetScratchMiscCtrl
+*
+* DESCRIPTION:
+*        Set Scratch and Misc control data to the Scratch and Misc Control register.
+*        The register of Scratch and Misc control are.
+*                Scratch Byte 0
+*                Scratch Byte 1
+*                GPIO Configuration
+*                Reserved for future use
+*                GPIO Direction
+*                GPIO Data
+*                CONFIG Data 0
+*                CONFIG Data 1
+*                CONFIG Data 2
+*                CONFIG Data 3
+*                SyncE & TAICLK125s Drive
+*                P5s & CLK125s Clock Drive
+*                P6s Clock Drive
+*                EEPROM Pad drive
+*
+* INPUTS:
+*        point - Pointer to the Scratch and Misc. Control register.
+*        data  - Scratch and Misc. Control data written to the register
+*                pointed to by the point above.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysSetScratchMiscCtrl
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U32            point,
+    IN  MV_U8            data
+);
+
+/*******************************************************************************
+* gsysGetScratchMiscCtrl
+*
+* DESCRIPTION:
+*        Get Scratch and Misc control data from the Scratch and Misc Control register.
+*        The register of Scratch and Misc control are.
+*                Scratch Byte 0
+*                Scratch Byte 1
+*                GPIO Configuration
+*                Reserved for future use
+*                GPIO Direction
+*                GPIO Data
+*                CONFIG Data 0
+*                CONFIG Data 1
+*                CONFIG Data 2
+*                CONFIG Data 3
+*                SyncE & TAICLK125s Drive
+*                P5s & CLK125s Clock Drive
+*                P6s Clock Drive
+*                EEPROM Pad drive
+
+*
+* INPUTS:
+*        point - Pointer to the Scratch and Misc. Control register.
+*
+* OUTPUTS:
+*        data - Scratch and Misc. Control data read from the register
+*                pointed to by the point above.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysGetScratchMiscCtrl
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U32            point,
+    OUT  MV_U8            *data
+);
+
+/*******************************************************************************
+* gsysSetScratchBits
+*
+* DESCRIPTION:
+*        Set bits to the Scratch and Misc Control register <scratch byte 0 and 1>.
+*        These bits are 100% available to software for whatever purpose desired.
+*        These bits do not connect to any hardware function.
+*
+* INPUTS:
+*        scritch - written bits.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysSetScratchBits
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U16            scratch
+);
+
+/*******************************************************************************
+* gsysGetScratchBits
+*
+* DESCRIPTION:
+*        Get bits from the Scratch and Misc Control register <scratch byte 0 and 1>.
+*        These bits are 100% available to software for whatever purpose desired.
+*        These bits do not connect to any hardware function.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        scritch - read bits.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysGetScratchBits
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  MV_U16            *scratch
+);
+
+/*******************************************************************************
+* gsysSetGpioConfigMod
+*
+* DESCRIPTION:
+*        Set bits to the Scratch and Misc Control register <GPIO Configuration>
+*        to configure GPIO mode.
+*        The bits are shared General Purpose Input Output mode Bits:
+*        Bit 6 - GT_GPIO_BIT_6:    1:GPIO[6]    0:SE_RCLK1
+*        Bit 5 - GT_GPIO_BIT_5:    1:GPIO[5]    0:SE_RCLK0
+*        Now, folloing bits are read only.
+*        Bit 4 - GT_GPIO_BIT_4:    1:GPIO[4]    0:
+*        Bit 3 - GT_GPIO_BIT_3:    1:GPIO[3]    0:
+*        Bit 2 - GT_GPIO_BIT_2:    1:GPIO[2]    0:
+*        Bit 1 - GT_GPIO_BIT_1:    1:GPIO[1]    0:P6_COL
+*        Bit 0 - GT_GPIO_BIT_0:    1:GPIO[0]    0:P6_CRS
+*
+* INPUTS:
+*        mode - OR [GT_GPIO_BIT_x]
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysSetGpioConfigMod
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U32            mode
+);
+
+/*******************************************************************************
+* gsysGetGpioConfigMod
+*
+* DESCRIPTION:
+*        Get mode from the Scratch and Misc Control register <GPIO Configuration>.
+*        The bits are shared General Purpose Input Output mode Bits:
+*        Bit 6 - GT_GPIO_BIT_6:    1:GPIO[6]    0:SE_RCLK1
+*        Bit 5 - GT_GPIO_BIT_5:    1:GPIO[5]    0:SE_RCLK0
+*        Now, folloing bits are read only.
+*        Bit 4 - GT_GPIO_BIT_4:    1:GPIO[4]    0:
+*        Bit 3 - GT_GPIO_BIT_3:    1:GPIO[3]    0:
+*        Bit 2 - GT_GPIO_BIT_2:    1:GPIO[2]    0:
+*        Bit 1 - GT_GPIO_BIT_1:    1:GPIO[1]    0:P6_COL
+*        Bit 0 - GT_GPIO_BIT_0:    1:GPIO[0]    0:P6_CRS
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode - OR [GT_GPIO_BIT_x]
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysGetGpioConfigMod
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U32            *mode
+);
+
+/*******************************************************************************
+* gsysSetGpioDirection
+*
+* DESCRIPTION:
+*        Set Gpio direction to the Scratch and Misc Control register <GPIO Direction>.
+*        The bits are used to control the direction of GPIO[6:0].
+*        When a GPIOs bit is set to a one that GPIO will become an input. When a
+*        GPIOs bit is cleared to a zero that GPIO will become an output
+*        General Purpose Input Output direction bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
+*
+* INPUTS:
+*        dir - OR [GT_GPIO_BIT_x]
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysSetGpioDirection
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U32            dir
+);
+
+/*******************************************************************************
+* gsysGetGpioDirection
+*
+* DESCRIPTION:
+*        get Gpio direction from the Scratch and Misc Control register <GPIO Direction>.
+*        The bits are used to control the direction of GPIO[6:0].
+*        When a GPIOs bit is set to a one that GPIO will become an input. When a
+*        GPIOs bit is cleared to a zero that GPIO will become an output
+*        General Purpose Input Output direction bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        dir - OR [GT_GPIO_BIT_x]
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysGetGpioDirection
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  MV_U32            *dir
+);
+
+/*******************************************************************************
+* gsysSetGpioData
+*
+* DESCRIPTION:
+*        Set Gpio data to the Scratch and Misc Control register <GPIO data>.
+*        When a GPIOs bit is set to be an input, data written to this bit will go
+*        to a holding register but will not appear on the pin nor in this register.
+*        Reads of this register will return the actual, real-time, data that is
+*        appearing on the GPIOs pin.
+*        When a GPIOs bit is set to be an output, data written to this bit will go
+*        to a holding register and will appear on the GPIOs pin. Reads of this register
+*        will return the actual, real-time, data that is appearing on the GPIOs pin
+*        (which in this case should be the data written, but if its isnt that would
+*        be an indication of a conflict).
+*        When a pins direction changes from input to output, the data last written
+*        to the holding register appears on the GPIOs pin
+*        General Purpose Input Output data bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
+*
+* INPUTS:
+*        data - OR [GT_GPIO_BIT_x]
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysSetGpioData
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U32            data
+);
+
+/*******************************************************************************
+* gsysGetGpioData
+*
+* DESCRIPTION:
+*        get Gpio data to the Scratch and Misc Control register <GPIO data>.
+*        When a GPIOs bit is set to be an input, data written to this bit will go
+*        to a holding register but will not appear on the pin nor in this register.
+*        Reads of this register will return the actual, real-time, data that is
+*        appearing on the GPIOs pin.
+*        When a GPIOs bit is set to be an output, data written to this bit will go
+*        to a holding register and will appear on the GPIOs pin. Reads of this register
+*        will return the actual, real-time, data that is appearing on the GPIOs pin
+*        (which in this case should be the data written, but if its isnt that would
+*        be an indication of a conflict).
+*        When a pins direction changes from input to output, the data last written
+*        to the holding register appears on the GPIOs pin
+*        General Purpose Input Output data bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        data - OR [GT_GPIO_BIT_x]
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysGetGpioData
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U32            *data
+);
+
+/*******************************************************************************
+* gsysGetConfigData
+*
+* DESCRIPTION:
+*        Get Reset Configuration Pin Data 0-3.
+*        These registers return the values observed after a hardware Reset on the
+*        listed CONFIG data listed below.
+*            Config data 0:
+*              Bit    Config    Pin's Primary Name
+*                0    USER[0]        P6_OUTD[5]
+*                1    USER[1]        P6_OUTD[6]
+*                2    USER[2]        P6_OUTD[7]
+*                3    ADDR[0]        P5_OUTD[0]
+*                4    ADDR[1]        P5_OUTD[5]
+*                5    ADDR[2]        P5_OUTD[6]
+*                6    ADDR]3]        P5_OUTD[7]
+*                7    ADDR[4]        P5_OUTD[1]
+*            Config data 1:
+*                0    LED_SEL[0]    P1_LED
+*                1    LED_SEL[1]    P2_LED
+*                2    4COL P3_LED
+*                3    NormCx        P4_LED
+*                4    Jumbo        P0_LED
+*                5    EE_WE        EE_CS/C2_LED
+*                6    FD_FLOW        EE_CLK/C1_LED
+*                7    HD_FLOW        EE_DIN/C0_LED
+*            Config data 2:
+*                0    P5_MODE[0]    P5_OUTD[2]
+*                1    P5_MODE[1]    P5_OUTD[3]
+*                2    P5_MODE[2]    P5_OUTD[4]
+*                3    Reserved for future use
+*                4    P6_MODE[0]    P6_OUTD[2]
+*                5    P6_MODE[1]    P6_OUTD[3]
+*                6    P6_MODE[2]    P6_OUTD[4]
+*                7    Reserved for future use
+*            Config data 3:
+*                0    RMU_MODE[0] P6_OUTD[0]
+*                1    RMU_MODE[1] P6_OUTD[1]
+*                2    S_VDDOS[0]    PTP_TRIG
+*                3    CLK125EN    CLK125
+*                4    P5_VDDOS[0] P5_GTXCLK
+*                5    P5_VDDOS[1] P5_OUTEN
+*                6    P6_VDDOS[0] P5_GTXCLK
+*                7    P6_VDDOS[1] P6_OUTEN
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*       cfgDat - GT_CONFIG_DTTA
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysGetConfigData
+(
+    IN  GT_QD_DEV             *dev,
+    OUT  GT_CONFIG_DATA        *cfgData
+);
+
+/*******************************************************************************
+* gsysSetSyncETai
+*
+* DESCRIPTION:
+*        Set SyncE and Tai to the Scratch and Misc. Control register <SyncE and TAI pad>.
+*
+* INPUTS:
+*        zpr - ZPR for SyncE and TAI
+*        znr - ZNR for SyncE and TAI
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysSetSyncETai
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U8            zpr,
+    IN  MV_U8            znr
+);
+
+/*******************************************************************************
+* gsysGetSyncETai
+*
+* DESCRIPTION:
+*        Get SyncE and Tai from the Scratch and Misc Control register <SyncE and TAI pad>.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        zpr - ZPR for SyncE and TAI
+*        znr - ZNR for SyncE and TAI*
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysGetSyncETai
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  MV_U8            *zpr,
+    OUT  MV_U8            *znr
+);
+
+/*******************************************************************************
+* gsysSetP6_Clock
+*
+* DESCRIPTION:
+*        Set P6_clock to the Scratch and Misc Control register <P6_Clock pad>.
+*
+* INPUTS:
+*        zpr - ZPR for P6_Clock
+*        znr - ZNR for P6_Clock
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysSetP6_Clock
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U8            zpr,
+    IN  MV_U8            znr
+);
+
+/*******************************************************************************
+* gsysGetP6_Clock
+*
+* DESCRIPTION:
+*       Get P6_clock from the Scratch and Misc Control register <P6_Clock pad>.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        zpr - ZPR for P6_Clock
+*        znr - ZNR for P6_Clock
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysGetP6_Clock
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  MV_U8            *zpr,
+    OUT  MV_U8            *znr
+);
+
+/*******************************************************************************
+* gsysSetP5_Clock
+*
+* DESCRIPTION:
+*       Set P5_clock to the Scratch and Misc Control register <P5_Clock pad>.
+*
+* INPUTS:
+*        zpr - ZPR for P5_Clock
+*        znr - ZNR for P5_Clock
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysSetP5_Clock
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U8            zpr,
+    IN  MV_U8            znr
+);
+
+/*******************************************************************************
+* gsysGetP5_Clock
+*
+* DESCRIPTION:
+*       Get P5_clock from the Scratch and Misc Control register <P5_Clock pad>.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        zpr - ZPR for P5_Clock
+*        znr - ZNR for P5_Clock
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysGetP5_Clock
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  MV_U8            *zpr,
+    OUT  MV_U8            *znr
+);
+
+/*******************************************************************************
+* gsysSetEEPROM
+*
+* DESCRIPTION:
+*       Set EEPROM cycle to the Scratch and Misc Control register <EEPROM pad>.
+*
+* INPUTS:
+*        dsm - DSM for EEPROM cycle
+*        zpr - ZPR for EEPROM cycle
+*        znr - ZNR for EEPROM cycle
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysSetEEPROM
+(
+    IN  GT_QD_DEV         *dev,
+    IN  MV_U8            dsm,
+    IN  MV_U8            zpr,
+    IN  MV_U8            znr
+);
+
+/*******************************************************************************
+* gsysGetEEPROM
+*
+* DESCRIPTION:
+*       Get EEPROM cycle to the Scratch and Misc Control register <EEPROM pad>.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        dsm - DSM for EEPROM cycle
+*        zpr - ZPR for EEPROM cycle
+*        znr - ZNR for EEPROM cycle
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+MV_STATUS gsysGetEEPROM
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  MV_U8            *dsm,
+    OUT  MV_U8            *zpr,
+    OUT  MV_U8            *znr
+);
+
+
+/* gtAdvVct.c */
+
+/*******************************************************************************
+* gvctGetAdvCableDiag
+*
+* DESCRIPTION:
+*       This routine perform the advanced virtual cable test for the requested
+*       port and returns the the status per MDI pair.
+*
+* INPUTS:
+*       port - logical port number.
+*       mode - advance VCT mode (either First Peak or Maximum Peak)
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are supporting this API.
+*
+*******************************************************************************/
+MV_STATUS gvctGetAdvCableDiag
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    IN  GT_ADV_VCT_MODE mode,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
+);
+
+/*******************************************************************************
+* gvctGetAdvExtendedStatus
+*
+* DESCRIPTION:
+*        This routine retrieves extended cable status, such as Pair Poloarity,
+*        Pair Swap, and Pair Skew. Note that this routine will be success only
+*        if 1000Base-T Link is up.
+*        DSP based cable length is also provided.
+*
+* INPUTS:
+*       dev  - pointer to GT driver structure returned from mdLoadDriver
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - the extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*        Supporting Device list:
+*           88E1111, 88E1112, 88E1141~6, 88E1149, and Internal Gigabit Phys
+*            in 88E6165 family and 88E6351 family devices
+*
+*******************************************************************************/
+MV_STATUS gvctGetAdvExtendedStatus
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT   port,
+    OUT GT_ADV_EXTENDED_STATUS *extendedStatus
+);
+
+#ifdef CONFIG_AVB_FPGA
+
+/*******************************************************************************
+* gptpGetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine gets interrupt status of PTP logic.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpInt    - PTP Int Status
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U32        *ptpInt
+);
+
+/*******************************************************************************
+* gptpSetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine sets interrupt status of PTP logic.
+*
+* INPUTS:
+*    ptpInt    - PTP Int Status
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_U32    ptpInt
+);
+
+/*******************************************************************************
+* gptpSetFPGAIntEn
+*
+* DESCRIPTION:
+*       This routine enables PTP interrupt.
+*
+* INPUTS:
+*        ptpInt    - PTP Int Status (1 to enable, 0 to disable)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetFPGAIntEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        ptpInt
+);
+
+/*******************************************************************************
+* gptpGetClockSource
+*
+* DESCRIPTION:
+*       This routine gets PTP Clock source setup.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_SRC     *clkSrc
+);
+
+/*******************************************************************************
+* gptpSetClockSource
+*
+* DESCRIPTION:
+*       This routine sets PTP Clock source setup.
+*
+* INPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_SRC     clkSrc
+);
+
+/*******************************************************************************
+* gptpGetP9Mode
+*
+* DESCRIPTION:
+*       This routine gets Port 9 Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_P9_MODE     *mode
+);
+
+/*******************************************************************************
+* gptpSetP9Mode
+*
+* DESCRIPTION:
+*       This routine sets Port 9 Mode.
+*
+* INPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_P9_MODE     mode
+);
+
+/*******************************************************************************
+* gptpReset
+*
+* DESCRIPTION:
+*       This routine performs software reset for PTP logic.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpReset
+(
+    IN  GT_QD_DEV     *dev
+);
+
+/*******************************************************************************
+* gptpGetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP Duty Cycle Adjustment is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adjEn    - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_BOOL        *adjEn
+);
+
+/*******************************************************************************
+* gptpSetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PTP Duty Cycle Adjustment.
+*
+* INPUTS:
+*        adjEn    - GT_TRUE to enable, GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_BOOL        adjEn
+);
+
+/*******************************************************************************
+* gptpGetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine gets clock duty cycle adjustment value.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_ADJUSTMENT    *adj
+);
+
+/*******************************************************************************
+* gptpSetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine sets clock duty cycle adjustment value.
+*
+* INPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_ADJUSTMENT    *adj
+);
+
+/*******************************************************************************
+* gptpGetPLLEn
+*
+* DESCRIPTION:
+*       This routine checks if PLL is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+MV_STATUS gptpGetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT MV_BOOL        *en,
+    OUT MV_U32        *freqSel
+);
+
+/*******************************************************************************
+* gptpSetPLLEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PLL device.
+*
+* INPUTS:
+*        en        - GT_TRUE to enable, GT_FALSE to disable
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*                  Meaningful only when enabling PLL device
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+MV_STATUS gptpSetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_BOOL        en,
+    IN  MV_U32        freqSel
+);
+
+/*******************************************************************************
+* gptpGetDDSReg
+*
+* DESCRIPTION:
+*       This routine gets DDS register data.
+*
+* INPUTS:
+*    ddsReg    - DDS Register
+*
+* OUTPUTS:
+*    ddsData    - register data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpGetDDSReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32    ddsReg,
+    OUT MV_U32    *ddsData
+);
+
+/*******************************************************************************
+* gptpSetDDSReg
+*
+* DESCRIPTION:
+*       This routine sets DDS register data.
+*    DDS register data written by this API are not affected until gptpUpdateDDSReg API is called.
+*
+* INPUTS:
+*    ddsReg    - DDS Register
+*    ddsData    - register data
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetDDSReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32    ddsReg,
+    IN  MV_U32    ddsData
+);
+
+/*******************************************************************************
+* gptpUpdateDDSReg
+*
+* DESCRIPTION:
+*       This routine updates DDS register data.
+*    DDS register data written by gptpSetDDSReg are not affected until this API is called.
+*
+* INPUTS:
+*    none
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpUpdateDDSReg
+(
+    IN  GT_QD_DEV     *dev
+);
+
+/*******************************************************************************
+* gptpSetADFReg
+*
+* DESCRIPTION:
+*       This routine sets ADF4156 register data.
+*
+* INPUTS:
+*    adfData    - register data
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gptpSetADFReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32    adfData
+);
+#endif  /*  CONFIG_AVB_FPGA */
+
+/* gtTCAM.c */
+/*******************************************************************************
+* gtcamFlushAll
+*
+* DESCRIPTION:
+*       This routine is to flush all entries. A Flush All command will initialize
+*       TCAM Pages 0 and 1, offsets 0x02 to 0x1B to 0x0000, and TCAM Page 2 offset
+*       0x02 to 0x05 to 0x0000 for all TCAM entries with the exception that TCAM
+*       Page 0 offset 0x02 will be initialized to 0x00FF.
+*
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtcamFlushAll
+(
+    IN  GT_QD_DEV     *dev
+);
+
+/*******************************************************************************
+* gtcamFlushEntry
+*
+* DESCRIPTION:
+*       This routine is to flush a single entry. A Flush a single TCAM entry command
+*       will write the same values to a TCAM entry as a Flush All command, but it is
+*       done to the selected single TCAM entry only.
+*
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtcamFlushEntry
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        tcamPointer
+);
+
+/*******************************************************************************
+* gtcamLoadEntry
+*
+* DESCRIPTION:
+*       This routine loads a TCAM entry.
+*    	The load sequence of TCAM entry is critical. Each TCAM entry is made up of
+*       3 pages of data. All 3 pages need to loaded in a particular order for the TCAM
+*       to operate correctly while frames are flowing through the switch.
+*       If the entry is currently valid, it must first be flushed. Then page 2 needs
+*       to be loaded first, followed by page 1 and then finally page 0.
+*       Each page load requires its own write TCAMOp with these TCAM page bits set
+*       accordingly.
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*        tcamData    - Tcam entry Data
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtcamLoadEntry
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        tcamPointer,
+    IN  GT_TCAM_DATA        *tcamData
+);
+
+/*******************************************************************************
+* gtcamPurgyEntry
+*
+* DESCRIPTION:
+*       This routine Purgy a TCAM entry.
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*        tcamData    - Tcam entry Data
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtcamPurgyEntry
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        tcamPointer,
+    IN  GT_TCAM_DATA        *tcamData
+);
+
+/*******************************************************************************
+* gtcamReadTCAMData
+*
+* DESCRIPTION:
+*       This routine loads the global 3 offsets 0x02 to 0x1B registers with
+*       the data found in the TCAM entry and its TCAM page pointed to by the TCAM
+*       entry and TCAM page bits of this register (bits 7:0 and 11:10 respectively.
+*
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*
+* OUTPUTS:
+*        tcamData    - Tcam entry Data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtcamReadTCAMData
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        tcamPointer,
+    OUT GT_TCAM_DATA        *tcamData
+);
+
+/*******************************************************************************
+* gtcamGetNextTCAMData
+*
+* DESCRIPTION:
+*       This routine  finds the next higher TCAM Entry number that is valid (i.e.,
+*       any entry whose Page 0 offset 0x02 is not equal to 0x00FF). The TCAM Entry
+*       register (bits 7:0) is used as the TCAM entry to start from. To find
+*       the lowest number TCAM Entry that is valid, start the Get Next operation
+*       with TCAM Entry set to 0xFF.
+*
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 255)
+*
+* OUTPUTS:
+*        tcamData    - Tcam entry Data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gtcamGetNextTCAMData
+(
+    IN  GT_QD_DEV     *dev,
+    IN  MV_U32        tcamPointer,
+    OUT GT_TCAM_DATA        *tcamData
+);
+
+/*******************************************************************************
+* gprtPortPowerSet
+*
+* DESCRIPTION:
+*       This routine resets port disables/enables port power
+*
+* INPUTS:
+*       port  - the logical port number.
+*       onoff - 0 port power down, otherwise port power up
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtPortPowerSet(IN GT_QD_DEV  *dev,
+			   IN GT_LPORT   port,
+			   IN MV_BOOL    onoff);
+
+
+MV_STATUS gprtPortPowerGet( IN GT_QD_DEV  *dev, IN GT_LPORT port);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __msApi_h */
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/eth-phy/mvEthPhyRegs.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/eth-phy/mvEthPhyRegs.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/eth-phy/mvEthPhyRegs.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/eth-phy/mvEthPhyRegs.h	2014-04-01 19:06:20.000000000 +0700
@@ -0,0 +1,175 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	 specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCethphyregsh
+#define __INCethphyregsh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//#include "mvSysEthConfig.h"
+
+/* defines */
+#define ETH_PHY_TIMEOUT		    10000
+
+/* registers offsetes defines */
+
+/* SMI register fields (ETH_PHY_SMI_REG) */
+
+#define ETH_PHY_SMI_DATA_OFFS	        0 /* Data */
+#define ETH_PHY_SMI_DATA_MASK	        (0xffff << ETH_PHY_SMI_DATA_OFFS)
+
+#define ETH_PHY_SMI_DEV_ADDR_OFFS	    16 /* PHY device address */
+#define ETH_PHY_SMI_DEV_ADDR_MASK       (0x1f << ETH_PHY_SMI_DEV_ADDR_OFFS)
+
+#define ETH_PHY_SMI_REG_ADDR_OFFS	    21 /* PHY device register address */
+#define ETH_PHY_SMI_REG_ADDR_MASK	    (0x1f << ETH_PHY_SMI_REG_ADDR_OFFS)
+
+#define ETH_PHY_SMI_OPCODE_OFFS	        26	/* Write/Read opcode */
+#define ETH_PHY_SMI_OPCODE_MASK	        (3 << ETH_PHY_SMI_OPCODE_OFFS)
+#define ETH_PHY_SMI_OPCODE_WRITE        (0 << ETH_PHY_SMI_OPCODE_OFFS)
+#define ETH_PHY_SMI_OPCODE_READ         (1 << ETH_PHY_SMI_OPCODE_OFFS)
+
+#define ETH_PHY_SMI_READ_VALID_BIT	    27	/* Read Valid  */
+#define ETH_PHY_SMI_READ_VALID_MASK	    (1 << ETH_PHY_SMI_READ_VALID_BIT)
+
+#define ETH_PHY_SMI_BUSY_BIT		    28  /* Busy */
+#define ETH_PHY_SMI_BUSY_MASK		    (1 << ETH_PHY_SMI_BUSY_BIT)
+
+/* PHY registers and bits */
+#define ETH_PHY_CTRL_REG                0
+#define ETH_PHY_STATUS_REG              1
+#define ETH_PHY_AUTONEGO_AD_REG		    4
+#define ETH_PHY_1000BASE_T_CTRL_REG	    9
+#define ETH_PHY_SPEC_CTRL_REG           16
+#define ETH_PHY_SPEC_STATUS_REG         17
+
+/* ETH_PHY_CTRL_REG bits */
+#define ETH_PHY_CTRL_SPEED_MSB_BIT      6
+#define ETH_PHY_CTRL_SPEED_MSB_MASK     (1 << ETH_PHY_CTRL_SPEED_MSB_BIT)
+
+#define ETH_PHY_CTRL_COLISION_TEST_BIT  7
+#define ETH_PHY_CTRL_COLISION_TEST_MASK (1 << ETH_PHY_CTRL_COLISION_TEST_BIT)
+
+#define ETH_PHY_CTRL_DUPLEX_BIT         8
+#define ETH_PHY_CTRL_DUPLEX_MASK        (1 << ETH_PHY_CTRL_DUPLEX_BIT)
+
+#define ETH_PHY_CTRL_AN_RESTART_BIT     9
+#define ETH_PHY_CTRL_AN_RESTART_MASK    (1 << ETH_PHY_CTRL_AN_RESTART_BIT)
+
+#define ETH_PHY_CTRL_ISOLATE_BIT        10
+#define ETH_PHY_CTRL_ISOLATE_MASK       (1 << ETH_PHY_CTRL_ISOLATE_BIT)
+
+#define ETH_PHY_CTRL_POWER_DOWN_BIT     11
+#define ETH_PHY_CTRL_POWER_DOWN_MASK    (1 << ETH_PHY_CTRL_POWER_DOWN_BIT)
+
+#define ETH_PHY_CTRL_AN_ENABLE_BIT      12
+#define ETH_PHY_CTRL_AN_ENABLE_MASK     (1 << ETH_PHY_CTRL_AN_ENABLE_BIT)
+
+#define ETH_PHY_CTRL_SPEED_LSB_BIT	    13
+#define ETH_PHY_CTRL_SPEED_LSB_MASK	    (1 << ETH_PHY_CTRL_SPEED_LSB_BIT)
+
+#define ETH_PHY_CTRL_LOOPBACK_BIT	    14
+#define ETH_PHY_CTRL_LOOPBACK_MASK	    (1 << ETH_PHY_CTRL_LOOPBACK_BIT)
+
+#define ETH_PHY_CTRL_RESET_BIT          15
+#define ETH_PHY_CTRL_RESET_MASK         (1 << ETH_PHY_CTRL_RESET_BIT)
+
+/* ETH_PHY_STATUS_REG bits */
+#define ETH_PHY_STATUS_AN_DONE_BIT      5
+#define ETH_PHY_STATUS_AN_DONE_MASK     (1 << ETH_PHY_STATUS_AN_DONE_BIT)
+
+/* ETH_PHY_AUTONEGO_AD_REG bits */
+#define ETH_PHY_10_100_BASE_ADVERTISE_OFFSET	5
+#define ETH_PHY_10_100_BASE_ADVERTISE_MASK	(0xf << ETH_PHY_10_100_BASE_ADVERTISE_OFFSET)
+
+/* ETH_PHY_1000BASE_T_CTRL_REG bits */
+#define ETH_PHY_1000BASE_ADVERTISE_OFFSET	8
+#define ETH_PHY_1000BASE_ADVERTISE_MASK		(0x3 << ETH_PHY_1000BASE_ADVERTISE_OFFSET)
+
+/* ETH_PHY_SPEC_STATUS_REG bits */
+#define ETH_PHY_SPEC_STATUS_SPEED_OFFS		14
+#define ETH_PHY_SPEC_STATUS_SPEED_MASK		(0x3 << ETH_PHY_SPEC_STATUS_SPEED_OFFS)
+
+#define ETH_PHY_SPEC_STATUS_SPEED_10MBPS	(0x0 << ETH_PHY_SPEC_STATUS_SPEED_OFFS)
+#define ETH_PHY_SPEC_STATUS_SPEED_100MBPS	(0x1 << ETH_PHY_SPEC_STATUS_SPEED_OFFS)
+#define ETH_PHY_SPEC_STATUS_SPEED_1000MBPS	(0x2 << ETH_PHY_SPEC_STATUS_SPEED_OFFS)
+
+
+#define ETH_PHY_SPEC_STATUS_DUPLEX_BIT		13
+#define ETH_PHY_SPEC_STATUS_DUPLEX_MASK		(0x1 << ETH_PHY_SPEC_STATUS_DUPLEX_BIT)
+
+#define ETH_PHY_SPEC_STATUS_LINK_BIT		10
+#define ETH_PHY_SPEC_STATUS_LINK_MASK		(0x1 << ETH_PHY_SPEC_STATUS_LINK_BIT)
+
+/* ETH_PHY_SPEC_STATUS_REG bits */
+#define ETH_PHY_LED_ACT_LNK_DV              0x4109
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* __INCethphyregsh */
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/gbe/mvEthRegs.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/gbe/mvEthRegs.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/gbe/mvEthRegs.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/gbe/mvEthRegs.h	2014-04-14 15:34:28.000000000 +0700
@@ -0,0 +1,745 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvEthRegsh
+#define __INCmvEthRegsh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include "../config/mvSysEthConfig.h"
+
+
+
+/****************************************/
+/*        Ethernet Unit Registers       */
+/****************************************/
+#define ETH_PHY_ADDR_REG(port)              (MV_ETH_REGS_BASE(port) + 0x000)
+#define ETH_SMI_REG(port)                   (MV_ETH_REGS_BASE(port) + 0x004)
+#define ETH_UNIT_DEF_ADDR_REG(port)         (MV_ETH_REGS_BASE(port) + 0x008)
+#define ETH_UNIT_DEF_ID_REG(port)           (MV_ETH_REGS_BASE(port) + 0x00c)
+#define ETH_UNIT_RESERVED(port)             (MV_ETH_REGS_BASE(port) + 0x014)
+#define ETH_UNIT_INTR_CAUSE_REG(port)       (MV_ETH_REGS_BASE(port) + 0x080)
+#define ETH_UNIT_INTR_MASK_REG(port)        (MV_ETH_REGS_BASE(port) + 0x084)
+
+
+#define ETH_UNIT_ERROR_ADDR_REG(port)       (MV_ETH_REGS_BASE(port) + 0x094)
+#define ETH_UNIT_INT_ADDR_ERROR_REG(port)   (MV_ETH_REGS_BASE(port) + 0x098)
+#define ETH_UNIT_CONTROL_REG(port)          (MV_ETH_REGS_BASE(port) + 0x0B0)
+
+#define ETH_PORT_CONFIG_REG(port)           (MV_ETH_REGS_BASE(port) + 0x400)
+#define ETH_PORT_CONFIG_EXTEND_REG(port)    (MV_ETH_REGS_BASE(port) + 0x404)
+#define ETH_MII_SERIAL_PARAM_REG(port)      (MV_ETH_REGS_BASE(port) + 0x408)
+#define ETH_GMII_SERIAL_PARAM_REG(port)     (MV_ETH_REGS_BASE(port) + 0x40c)
+#define ETH_VLAN_ETHER_TYPE_REG(port)       (MV_ETH_REGS_BASE(port) + 0x410)
+#define ETH_MAC_ADDR_LOW_REG(port)          (MV_ETH_REGS_BASE(port) + 0x414)
+#define ETH_MAC_ADDR_HIGH_REG(port)         (MV_ETH_REGS_BASE(port) + 0x418)
+#define ETH_SDMA_CONFIG_REG(port)           (MV_ETH_REGS_BASE(port) + 0x41c)
+#define ETH_DIFF_SERV_PRIO_REG(port, code)  (MV_ETH_REGS_BASE(port) + 0x420  + ((code)<<2))
+#define ETH_PORT_SERIAL_CTRL_REG(port)      (MV_ETH_REGS_BASE(port) + 0x43c)
+#define ETH_VLAN_TAG_TO_PRIO_REG(port)      (MV_ETH_REGS_BASE(port) + 0x440)
+#define ETH_PORT_STATUS_REG(port)           (MV_ETH_REGS_BASE(port) + 0x444)
+
+#define ETH_RX_QUEUE_COMMAND_REG(port)      (MV_ETH_REGS_BASE(port) + 0x680)
+#define ETH_TX_QUEUE_COMMAND_REG(port)      (MV_ETH_REGS_BASE(port) + 0x448)
+
+#define ETH_PORT_SERIAL_CTRL_1_REG(port)    (MV_ETH_REGS_BASE(port) + 0x44c)
+#define ETH_PORT_STATUS_1_REG(port)         (MV_ETH_REGS_BASE(port) + 0x450)
+#define ETH_PORT_MARVELL_HEADER_REG(port)   (MV_ETH_REGS_BASE(port) + 0x454)
+#define ETH_PORT_FIFO_PARAMS_REG(port)      (MV_ETH_REGS_BASE(port) + 0x458)
+#define ETH_MAX_TOKEN_BUCKET_SIZE_REG(port) (MV_ETH_REGS_BASE(port) + 0x45c)
+#define ETH_INTR_CAUSE_REG(port)            (MV_ETH_REGS_BASE(port) + 0x460)
+#define ETH_INTR_CAUSE_EXT_REG(port)        (MV_ETH_REGS_BASE(port) + 0x464)
+#define ETH_INTR_MASK_REG(port)             (MV_ETH_REGS_BASE(port) + 0x468)
+#define ETH_INTR_MASK_EXT_REG(port)         (MV_ETH_REGS_BASE(port) + 0x46c)
+#define ETH_TX_FIFO_URGENT_THRESH_REG(port) (MV_ETH_REGS_BASE(port) + 0x474)
+#define ETH_RX_MINIMAL_FRAME_SIZE_REG(port) (MV_ETH_REGS_BASE(port) + 0x47c)
+#define ETH_RX_DISCARD_PKTS_CNTR_REG(port)  (MV_ETH_REGS_BASE(port) + 0x484)
+#define ETH_RX_OVERRUN_PKTS_CNTR_REG(port)  (MV_ETH_REGS_BASE(port) + 0x488)
+#define ETH_INTERNAL_ADDR_ERROR_REG(port)   (MV_ETH_REGS_BASE(port) + 0x494)
+#define ETH_TX_FIXED_PRIO_CFG_REG(port)     (MV_ETH_REGS_BASE(port) + 0x4dc)
+#define ETH_TX_TOKEN_RATE_CFG_REG(port)     (MV_ETH_REGS_BASE(port) + 0x4e0)
+#define ETH_TX_QUEUE_COMMAND1_REG(port)     (MV_ETH_REGS_BASE(port) + 0x4e4)
+#define ETH_MAX_TRANSMIT_UNIT_REG(port)     (MV_ETH_REGS_BASE(port) + 0x4e8)
+#define ETH_TX_TOKEN_BUCKET_SIZE_REG(port)  (MV_ETH_REGS_BASE(port) + 0x4ec)
+#define ETH_TX_TOKEN_BUCKET_COUNT_REG(port) (MV_ETH_REGS_BASE(port) + 0x780)
+#define ETH_RX_DESCR_STAT_CMD_REG(port, q)  (MV_ETH_REGS_BASE(port) + 0x600 + ((q)<<4))
+#define ETH_RX_BYTE_COUNT_REG(port, q)      (MV_ETH_REGS_BASE(port) + 0x604 + ((q)<<4))
+#define ETH_RX_BUF_PTR_REG(port, q)         (MV_ETH_REGS_BASE(port) + 0x608 + ((q)<<4))
+#define ETH_RX_CUR_DESC_PTR_REG(port, q)    (MV_ETH_REGS_BASE(port) + 0x60c + ((q)<<4))
+#define ETH_TX_CUR_DESC_PTR_REG(port, q)    (MV_ETH_REGS_BASE(port) + 0x6c0 + ((q)<<2))
+
+#define ETH_TXQ_TOKEN_COUNT_REG(port, q)    (MV_ETH_REGS_BASE(port) + 0x700 + ((q)<<4))
+#define ETH_TXQ_TOKEN_CFG_REG(port, q)      (MV_ETH_REGS_BASE(port) + 0x704 + ((q)<<4))
+#define ETH_TXQ_ARBITER_CFG_REG(port, q)    (MV_ETH_REGS_BASE(port) + 0x708 + ((q)<<4))
+
+#if (MV_ETH_VERSION >= 4)
+#define ETH_TXQ_CMD_1_REG(port)             (MV_ETH_REGS_BASE(port) + 0x4E4)
+#define ETH_EJP_TX_HI_IPG_REG(port)         (MV_ETH_REGS_BASE(port) + 0x7A8)
+#define ETH_EJP_TX_LO_IPG_REG(port)         (MV_ETH_REGS_BASE(port) + 0x7B8)
+#define ETH_EJP_HI_TKN_LO_PKT_REG(port)     (MV_ETH_REGS_BASE(port) + 0x7C0)
+#define ETH_EJP_HI_TKN_ASYNC_PKT_REG(port)  (MV_ETH_REGS_BASE(port) + 0x7C4)
+#define ETH_EJP_LO_TKN_ASYNC_PKT_REG(port)  (MV_ETH_REGS_BASE(port) + 0x7C8)
+#define ETH_EJP_TX_SPEED_REG(port)          (MV_ETH_REGS_BASE(port) + 0x7D0)
+#endif /* MV_ETH_VERSION >= 4 */
+
+#define ETH_MIB_COUNTERS_BASE(port)         (MV_ETH_REGS_BASE(port) + 0x1000)
+#define ETH_DA_FILTER_SPEC_MCAST_BASE(port) (MV_ETH_REGS_BASE(port) + 0x1400)
+#define ETH_DA_FILTER_OTH_MCAST_BASE(port)  (MV_ETH_REGS_BASE(port) + 0x1500)
+#define ETH_DA_FILTER_UCAST_BASE(port)      (MV_ETH_REGS_BASE(port) + 0x1600)
+
+/* Phy address register definitions */
+#define ETH_PHY_ADDR_OFFS          0
+#define ETH_PHY_ADDR_MASK          (0x1f << ETH_PHY_ADDR_OFFS)
+
+/* MIB Counters register definitions */
+#define ETH_MIB_GOOD_OCTETS_RECEIVED_LOW    0x0
+#define ETH_MIB_GOOD_OCTETS_RECEIVED_HIGH   0x4
+#define ETH_MIB_BAD_OCTETS_RECEIVED         0x8
+#define ETH_MIB_INTERNAL_MAC_TRANSMIT_ERR   0xc
+#define ETH_MIB_GOOD_FRAMES_RECEIVED        0x10
+#define ETH_MIB_BAD_FRAMES_RECEIVED         0x14
+#define ETH_MIB_BROADCAST_FRAMES_RECEIVED   0x18
+#define ETH_MIB_MULTICAST_FRAMES_RECEIVED   0x1c
+#define ETH_MIB_FRAMES_64_OCTETS            0x20
+#define ETH_MIB_FRAMES_65_TO_127_OCTETS     0x24
+#define ETH_MIB_FRAMES_128_TO_255_OCTETS    0x28
+#define ETH_MIB_FRAMES_256_TO_511_OCTETS    0x2c
+#define ETH_MIB_FRAMES_512_TO_1023_OCTETS   0x30
+#define ETH_MIB_FRAMES_1024_TO_MAX_OCTETS   0x34
+#define ETH_MIB_GOOD_OCTETS_SENT_LOW        0x38
+#define ETH_MIB_GOOD_OCTETS_SENT_HIGH       0x3c
+#define ETH_MIB_GOOD_FRAMES_SENT            0x40
+#define ETH_MIB_EXCESSIVE_COLLISION         0x44
+#define ETH_MIB_MULTICAST_FRAMES_SENT       0x48
+#define ETH_MIB_BROADCAST_FRAMES_SENT       0x4c
+#define ETH_MIB_UNREC_MAC_CONTROL_RECEIVED  0x50
+#define ETH_MIB_FC_SENT                     0x54
+#define ETH_MIB_GOOD_FC_RECEIVED            0x58
+#define ETH_MIB_BAD_FC_RECEIVED             0x5c
+#define ETH_MIB_UNDERSIZE_RECEIVED          0x60
+#define ETH_MIB_FRAGMENTS_RECEIVED          0x64
+#define ETH_MIB_OVERSIZE_RECEIVED           0x68
+#define ETH_MIB_JABBER_RECEIVED             0x6c
+#define ETH_MIB_MAC_RECEIVE_ERROR           0x70
+#define ETH_MIB_BAD_CRC_EVENT               0x74
+#define ETH_MIB_COLLISION                   0x78
+#define ETH_MIB_LATE_COLLISION              0x7c
+
+
+/****************************************/
+/*        Ethernet Unit Register BITs   */
+/****************************************/
+
+#define ETH_RXQ_ENABLE_OFFSET               0
+#define ETH_RXQ_ENABLE_MASK                 (0x000000FF << ETH_RXQ_ENABLE_OFFSET)
+
+#define ETH_RXQ_DISABLE_OFFSET              8
+#define ETH_RXQ_DISABLE_MASK                (0x000000FF << ETH_RXQ_DISABLE_OFFSET)
+
+/***** BITs of Transmit Queue Command (TQC) register *****/
+#define ETH_TXQ_ENABLE_OFFSET               0
+#define ETH_TXQ_ENABLE_MASK                 (0x000000FF << ETH_TXQ_ENABLE_OFFSET)
+
+#define ETH_TXQ_DISABLE_OFFSET              8
+#define ETH_TXQ_DISABLE_MASK                (0x000000FF << ETH_TXQ_DISABLE_OFFSET)
+
+#if (MV_ETH_VERSION >= 4)
+#define ETH_TX_EJP_RESET_BIT                0
+#define ETH_TX_EJP_RESET_MASK               (1 << ETH_TX_EJP_RESET_BIT)
+
+#define ETH_TX_EJP_ENABLE_BIT               2
+#define ETH_TX_EJP_ENABLE_MASK              (1 << ETH_TX_EJP_ENABLE_BIT)
+
+#define ETH_TX_LEGACY_WRR_BIT               3
+#define ETH_TX_LEGACY_WRR_MASK              (1 << ETH_TX_LEGACY_WRR_BIT)
+#endif /* (MV_ETH_VERSION >= 4) */
+
+/***** BITs of Ethernet Port Status reg (PSR) *****/
+#define ETH_LINK_UP_BIT                     1
+#define ETH_LINK_UP_MASK                    (1<<ETH_LINK_UP_BIT)
+
+#define ETH_FULL_DUPLEX_BIT                 2
+#define ETH_FULL_DUPLEX_MASK                (1<<ETH_FULL_DUPLEX_BIT)
+
+#define ETH_ENABLE_RCV_FLOW_CTRL_BIT        3
+#define ETH_ENABLE_RCV_FLOW_CTRL_MASK       (1<<ETH_ENABLE_RCV_FLOW_CTRL_BIT)
+
+#define ETH_GMII_SPEED_1000_BIT             4
+#define ETH_GMII_SPEED_1000_MASK            (1<<ETH_GMII_SPEED_1000_BIT)
+
+#define ETH_MII_SPEED_100_BIT               5
+#define ETH_MII_SPEED_100_MASK              (1<<ETH_MII_SPEED_100_BIT)
+
+#define ETH_TX_IN_PROGRESS_BIT              7
+#define ETH_TX_IN_PROGRESS_MASK             (1<<ETH_TX_IN_PROGRESS_BIT)
+
+#define ETH_TX_FIFO_EMPTY_BIT               10
+#define ETH_TX_FIFO_EMPTY_MASK              (1<<ETH_TX_FIFO_EMPTY_BIT)
+
+/***** BITs of Ethernet Port Status 1 reg (PS1R) *****/
+#define ETH_AUTO_NEG_DONE_BIT               4
+#define ETH_AUTO_NEG_DONE_MASK              (1<<ETH_AUTO_NEG_DONE_BIT)
+
+#define ETH_SERDES_PLL_LOCKED_BIT           6
+#define ETH_SERDES_PLL_LOCKED_MASK          (1<<ETH_SERDES_PLL_LOCKED_BIT)
+
+/***** BITs of Port Configuration reg (PxCR) *****/
+#define ETH_UNICAST_PROMISCUOUS_MODE_BIT    0
+#define ETH_UNICAST_PROMISCUOUS_MODE_MASK   (1<<ETH_UNICAST_PROMISCUOUS_MODE_BIT)
+
+#define ETH_DEF_RX_QUEUE_OFFSET             1
+#define ETH_DEF_RX_QUEUE_ALL_MASK           (0x7<<ETH_DEF_RX_QUEUE_OFFSET)
+#define ETH_DEF_RX_QUEUE_MASK(queue)        ((queue)<<ETH_DEF_RX_QUEUE_OFFSET)
+
+#define ETH_DEF_RX_ARP_QUEUE_OFFSET         4
+#define ETH_DEF_RX_ARP_QUEUE_ALL_MASK       (0x7<<ETH_DEF_RX_ARP_QUEUE_OFFSET)
+#define ETH_DEF_RX_ARP_QUEUE_MASK(queue)    ((queue)<<ETH_DEF_RX_ARP_QUEUE_OFFSET)
+
+#define ETH_REJECT_NOT_IP_ARP_BCAST_BIT     7
+#define ETH_REJECT_NOT_IP_ARP_BCAST_MASK    (1<<ETH_REJECT_NOT_IP_ARP_BCAST_BIT)
+
+#define ETH_REJECT_IP_BCAST_BIT             8
+#define ETH_REJECT_IP_BCAST_MASK            (1<<ETH_REJECT_IP_BCAST_BIT)
+
+#define ETH_REJECT_ARP_BCAST_BIT            9
+#define ETH_REJECT_ARP_BCAST_MASK           (1<<ETH_REJECT_ARP_BCAST_BIT)
+
+#define ETH_TX_NO_SET_ERROR_SUMMARY_BIT     12
+#define ETH_TX_NO_SET_ERROR_SUMMARY_MASK    (1<<ETH_TX_NO_SET_ERROR_SUMMARY_BIT)
+
+#define ETH_CAPTURE_TCP_FRAMES_ENABLE_BIT   14
+#define ETH_CAPTURE_TCP_FRAMES_ENABLE_MASK  (1<<ETH_CAPTURE_TCP_FRAMES_ENABLE_BIT)
+
+#define ETH_CAPTURE_UDP_FRAMES_ENABLE_BIT   15
+#define ETH_CAPTURE_UDP_FRAMES_ENABLE_MASK  (1<<ETH_CAPTURE_UDP_FRAMES_ENABLE_BIT)
+
+#define ETH_DEF_RX_TCP_QUEUE_OFFSET         16
+#define ETH_DEF_RX_TCP_QUEUE_ALL_MASK       (0x7<<ETH_DEF_RX_TCP_QUEUE_OFFSET)
+#define ETH_DEF_RX_TCP_QUEUE_MASK(queue)    ((queue)<<ETH_DEF_RX_TCP_QUEUE_OFFSET)
+
+#define ETH_DEF_RX_UDP_QUEUE_OFFSET         19
+#define ETH_DEF_RX_UDP_QUEUE_ALL_MASK       (0x7<<ETH_DEF_RX_UDP_QUEUE_OFFSET)
+#define ETH_DEF_RX_UDP_QUEUE_MASK(queue)    ((queue)<<ETH_DEF_RX_UDP_QUEUE_OFFSET)
+
+#define ETH_DEF_RX_BPDU_QUEUE_OFFSET        22
+#define ETH_DEF_RX_BPDU_QUEUE_ALL_MASK      (0x7<<ETH_DEF_RX_BPDU_QUEUE_OFFSET)
+#define ETH_DEF_RX_BPDU_QUEUE_MASK(queue)   ((queue)<<ETH_DEF_RX_BPDU_QUEUE_OFFSET)
+
+#define ETH_RX_CHECKSUM_MODE_OFFSET         25
+#define ETH_RX_CHECKSUM_NO_PSEUDO_HDR       (0<<ETH_RX_CHECKSUM_MODE_OFFSET)
+#define ETH_RX_CHECKSUM_WITH_PSEUDO_HDR     (1<<ETH_RX_CHECKSUM_MODE_OFFSET)
+
+/***** BITs of Port Configuration Extend reg (PxCXR) *****/
+#define ETH_CAPTURE_SPAN_BPDU_ENABLE_BIT    1
+#define ETH_CAPTURE_SPAN_BPDU_ENABLE_MASK   (1<<ETH_CAPTURE_SPAN_BPDU_ENABLE_BIT)
+
+#define ETH_TX_DISABLE_GEN_CRC_BIT          3
+#define ETH_TX_DISABLE_GEN_CRC_MASK         (1<<ETH_TX_DISABLE_GEN_CRC_BIT)
+
+/***** BITs of Tx/Rx queue command reg (RQCR/TQCR) *****/
+#define ETH_QUEUE_ENABLE_OFFSET             0
+#define ETH_QUEUE_ENABLE_ALL_MASK           (0xFF<<ETH_QUEUE_ENABLE_OFFSET)
+#define ETH_QUEUE_ENABLE_MASK(queue)        (1<<((queue)+ETH_QUEUE_ENABLE_OFFSET))
+
+#define ETH_QUEUE_DISABLE_OFFSET            8
+#define ETH_QUEUE_DISABLE_ALL_MASK          (0xFF<<ETH_QUEUE_DISABLE_OFFSET)
+#define ETH_QUEUE_DISABLE_MASK(queue)       (1<<((queue)+ETH_QUEUE_DISABLE_OFFSET))
+
+
+/***** BITs of Port Sdma Configuration reg (SDCR) *****/
+#define ETH_RX_FRAME_INTERRUPT_BIT          0
+#define ETH_RX_FRAME_INTERRUPT_MASK         (1<<ETH_RX_FRAME_INTERRUPT_BIT)
+
+#define ETH_BURST_SIZE_1_64BIT_VALUE        0
+#define ETH_BURST_SIZE_2_64BIT_VALUE        1
+#define ETH_BURST_SIZE_4_64BIT_VALUE        2
+#define ETH_BURST_SIZE_8_64BIT_VALUE        3
+#define ETH_BURST_SIZE_16_64BIT_VALUE       4
+
+#define ETH_RX_BURST_SIZE_OFFSET            1
+#define ETH_RX_BURST_SIZE_ALL_MASK          (0x7<<ETH_RX_BURST_SIZE_OFFSET)
+#define ETH_RX_BURST_SIZE_MASK(burst)       ((burst)<<ETH_RX_BURST_SIZE_OFFSET)
+
+#define ETH_RX_NO_DATA_SWAP_BIT             4
+#define ETH_RX_NO_DATA_SWAP_MASK            (1<<ETH_RX_NO_DATA_SWAP_BIT)
+#define ETH_RX_DATA_SWAP_MASK               (0<<ETH_RX_NO_DATA_SWAP_BIT)
+
+#define ETH_TX_NO_DATA_SWAP_BIT             5
+#define ETH_TX_NO_DATA_SWAP_MASK            (1<<ETH_TX_NO_DATA_SWAP_BIT)
+#define ETH_TX_DATA_SWAP_MASK               (0<<ETH_TX_NO_DATA_SWAP_BIT)
+
+#define ETH_DESC_SWAP_BIT                   6
+#define ETH_DESC_SWAP_MASK                  (1<<ETH_DESC_SWAP_BIT)
+#define ETH_NO_DESC_SWAP_MASK               (0<<ETH_DESC_SWAP_BIT)
+
+#define ETH_RX_INTR_COAL_OFFSET             7
+#define ETH_RX_INTR_COAL_ALL_MASK           (0x3fff<<ETH_RX_INTR_COAL_OFFSET)
+#define ETH_RX_INTR_COAL_MASK(value)        (((value)<<ETH_RX_INTR_COAL_OFFSET)  \
+	& ETH_RX_INTR_COAL_ALL_MASK)
+
+#define ETH_TX_BURST_SIZE_OFFSET            22
+#define ETH_TX_BURST_SIZE_ALL_MASK          (0x7<<ETH_TX_BURST_SIZE_OFFSET)
+#define ETH_TX_BURST_SIZE_MASK(burst)       ((burst)<<ETH_TX_BURST_SIZE_OFFSET)
+
+#define ETH_RX_INTR_COAL_MSB_BIT            25
+#define ETH_RX_INTR_COAL_MSB_MASK           (1<<ETH_RX_INTR_COAL_MSB_BIT)
+
+/* BITs Port #x Tx FIFO Urgent Threshold (PxTFUT) */
+#define ETH_TX_INTR_COAL_OFFSET             4
+#define ETH_TX_INTR_COAL_ALL_MASK           (0x3fff << ETH_TX_INTR_COAL_OFFSET)
+#define ETH_TX_INTR_COAL_MASK(value)        (((value) << ETH_TX_INTR_COAL_OFFSET)  \
+	& ETH_TX_INTR_COAL_ALL_MASK)
+
+/* BITs of Port Serial Control reg (PSCR) */
+#define ETH_PORT_ENABLE_BIT                 0
+#define ETH_PORT_ENABLE_MASK                (1<<ETH_PORT_ENABLE_BIT)
+
+#define ETH_FORCE_LINK_PASS_BIT             1
+#define ETH_FORCE_LINK_PASS_MASK            (1<<ETH_FORCE_LINK_PASS_BIT)
+
+#define ETH_DISABLE_DUPLEX_AUTO_NEG_BIT     2
+#define ETH_DISABLE_DUPLEX_AUTO_NEG_MASK    (1<<ETH_DISABLE_DUPLEX_AUTO_NEG_BIT)
+
+#define ETH_DISABLE_FC_AUTO_NEG_BIT         3
+#define ETH_DISABLE_FC_AUTO_NEG_MASK        (1<<ETH_DISABLE_FC_AUTO_NEG_BIT)
+
+#define ETH_ADVERTISE_SYM_FC_BIT            4
+#define ETH_ADVERTISE_SYM_FC_MASK           (1<<ETH_ADVERTISE_SYM_FC_BIT)
+
+#define ETH_TX_FC_MODE_OFFSET               5
+#define ETH_TX_FC_MODE_MASK                 (3<<ETH_TX_FC_MODE_OFFSET)
+#define ETH_TX_FC_NO_PAUSE                  (0<<ETH_TX_FC_MODE_OFFSET)
+#define ETH_TX_FC_SEND_PAUSE                (1<<ETH_TX_FC_MODE_OFFSET)
+
+#define ETH_TX_BP_MODE_OFFSET               7
+#define ETH_TX_BP_MODE_MASK                 (3<<ETH_TX_BP_MODE_OFFSET)
+#define ETH_TX_BP_NO_JAM                    (0<<ETH_TX_BP_MODE_OFFSET)
+#define ETH_TX_BP_SEND_JAM                  (1<<ETH_TX_BP_MODE_OFFSET)
+
+#define ETH_DO_NOT_FORCE_LINK_FAIL_BIT      10
+#define ETH_DO_NOT_FORCE_LINK_FAIL_MASK     (1<<ETH_DO_NOT_FORCE_LINK_FAIL_BIT)
+
+#define ETH_RETRANSMIT_FOREVER_BIT          11
+#define ETH_RETRANSMIT_FOREVER_MASK         (1<<ETH_RETRANSMIT_FOREVER_BIT)
+
+#define ETH_DISABLE_SPEED_AUTO_NEG_BIT      13
+#define ETH_DISABLE_SPEED_AUTO_NEG_MASK     (1<<ETH_DISABLE_SPEED_AUTO_NEG_BIT)
+
+#define ETH_DTE_ADVERT_BIT                  14
+#define ETH_DTE_ADVERT_MASK                 (1<<ETH_DTE_ADVERT_BIT)
+
+#define ETH_MII_PHY_MODE_BIT                15
+#define ETH_MII_PHY_MODE_MAC                (0<<ETH_MII_PHY_MODE_BIT)
+#define ETH_MII_PHY_MODE_PHY                (1<<ETH_MII_PHY_MODE_BIT)
+
+#define ETH_MII_SOURCE_SYNCH_BIT            16
+#define ETH_MII_STANDARD_SYNCH              (0<<ETH_MII_SOURCE_SYNCH_BIT)
+#define ETH_MII_400Mbps_SYNCH               (1<<ETH_MII_SOURCE_CLK_BIT)
+
+#define ETH_MAX_RX_PACKET_SIZE_OFFSET       17
+#define ETH_MAX_RX_PACKET_SIZE_MASK         (7<<ETH_MAX_RX_PACKET_SIZE_OFFSET)
+#define ETH_MAX_RX_PACKET_1518BYTE          (0<<ETH_MAX_RX_PACKET_SIZE_OFFSET)
+#define ETH_MAX_RX_PACKET_1522BYTE          (1<<ETH_MAX_RX_PACKET_SIZE_OFFSET)
+#define ETH_MAX_RX_PACKET_1552BYTE          (2<<ETH_MAX_RX_PACKET_SIZE_OFFSET)
+#define ETH_MAX_RX_PACKET_9022BYTE          (3<<ETH_MAX_RX_PACKET_SIZE_OFFSET)
+#define ETH_MAX_RX_PACKET_9192BYTE          (4<<ETH_MAX_RX_PACKET_SIZE_OFFSET)
+#define ETH_MAX_RX_PACKET_9700BYTE          (5<<ETH_MAX_RX_PACKET_SIZE_OFFSET)
+
+#define ETH_SET_FULL_DUPLEX_BIT             21
+#define ETH_SET_FULL_DUPLEX_MASK            (1<<ETH_SET_FULL_DUPLEX_BIT)
+
+#define ETH_SET_FLOW_CTRL_BIT               22
+#define ETH_SET_FLOW_CTRL_MASK              (1<<ETH_SET_FLOW_CTRL_BIT)
+
+#define ETH_SET_GMII_SPEED_1000_BIT         23
+#define ETH_SET_GMII_SPEED_1000_MASK        (1<<ETH_SET_GMII_SPEED_1000_BIT)
+
+#define ETH_SET_MII_SPEED_100_BIT           24
+#define ETH_SET_MII_SPEED_100_MASK          (1<<ETH_SET_MII_SPEED_100_BIT)
+
+/* BITs of Port Serial Control 1 reg (PSC1R) */
+#define ETH_PSC_ENABLE_BIT                  2
+#define ETH_PSC_ENABLE_MASK                 (1<<ETH_PSC_ENABLE_BIT)
+
+#define ETH_RGMII_ENABLE_BIT                3
+#define ETH_RGMII_ENABLE_MASK               (1<<ETH_RGMII_ENABLE_BIT)
+
+#define ETH_PORT_RESET_BIT                  4
+#define ETH_PORT_RESET_MASK                 (1<<ETH_PORT_RESET_BIT)
+
+#define ETH_INBAND_AUTO_NEG_ENABLE_BIT      6
+#define ETH_INBAND_AUTO_NEG_ENABLE_MASK     (1<<ETH_INBAND_AUTO_NEG_ENABLE_BIT)
+
+#define ETH_INBAND_AUTO_NEG_BYPASS_BIT      7
+#define ETH_INBAND_AUTO_NEG_BYPASS_MASK     (1<<ETH_INBAND_AUTO_NEG_BYPASS_BIT)
+
+#define ETH_INBAND_AUTO_NEG_START_BIT       8
+#define ETH_INBAND_AUTO_NEG_START_MASK      (1<<ETH_INBAND_AUTO_NEG_START_BIT)
+
+#define ETH_PORT_TYPE_BIT                   11
+#define ETH_PORT_TYPE_1000BasedX_MASK       (1<<ETH_PORT_TYPE_BIT)
+
+#define ETH_SGMII_MODE_BIT                  12
+#define ETH_1000BaseX_MODE_MASK             (0<<ETH_SGMII_MODE_BIT)
+#define ETH_SGMII_MODE_MASK                 (1<<ETH_SGMII_MODE_BIT)
+
+#define ETH_MGMII_MODE_BIT                  13
+
+#define ETH_EN_MII_ODD_PRE_BIT		    22
+#define ETH_EN_MII_ODD_PRE_MASK		    (1<<ETH_EN_MII_ODD_PRE_BIT)
+
+/* BITs of SDMA Descriptor Command/Status field */
+#if defined(MV_CPU_BE) && !defined(MV_KW2_BE_ETH_WA)
+
+#define ETH_GET_32B_DESCR_VAL(val)	(val)
+#define ETH_GET_16B_DESCR_VAL(val)	(val)
+#define ETH_SET_32B_DESCR_VAL(var, val)	((var) = (val))
+#define ETH_SET_16B_DESCR_VAL(var, val)	((var) = (val))
+
+typedef struct _ethRxDesc {
+    MV_U16      byteCnt    ;    /* Descriptor buffer byte count     */
+    MV_U16      bufSize    ;    /* Buffer size                      */
+    MV_U32      cmdSts     ;    /* Descriptor command status        */
+    MV_U32      nextDescPtr;    /* Next descriptor pointer          */
+    MV_U32      bufPtr     ;    /* Descriptor buffer pointer        */
+    MV_ULONG    returnInfo ;    /* User resource return information */
+} ETH_RX_DESC;
+
+typedef struct _ethTxDesc {
+    MV_U16      byteCnt    ;    /* Descriptor buffer byte count     */
+    MV_U16      L4iChk     ;    /* CPU provided TCP Checksum        */
+    MV_U32      cmdSts     ;    /* Descriptor command status        */
+    MV_U32      nextDescPtr;    /* Next descriptor pointer          */
+    MV_U32      bufPtr     ;    /* Descriptor buffer pointer        */
+    MV_ULONG    returnInfo ;    /* User resource return information */
+    MV_U8	*alignBufPtr;   /* Pointer to 8 byte aligned buffer */
+} ETH_TX_DESC;
+
+#elif defined(MV_CPU_LE) || defined(MV_KW2_BE_ETH_WA)
+
+#ifdef MV_KW2_BE_ETH_WA
+#define ETH_GET_32B_DESCR_VAL(val)	MV_BYTE_SWAP_32BIT(val)
+#define ETH_GET_16B_DESCR_VAL(val)	MV_BYTE_SWAP_16BIT(val)
+#define ETH_SET_32B_DESCR_VAL(var, val) \
+				(var = MV_BYTE_SWAP_32BIT(val))
+#define ETH_SET_16B_DESCR_VAL(var, val) \
+				(var = MV_BYTE_SWAP_16BIT(val))
+#else
+#define ETH_GET_32B_DESCR_VAL(val)	(val)
+#define ETH_GET_16B_DESCR_VAL(val)	(val)
+#define ETH_SET_32B_DESCR_VAL(var, val)	((var) = (val))
+#define ETH_SET_16B_DESCR_VAL(var, val)	((var) = (val))
+#endif
+
+typedef struct _ethRxDesc {
+    MV_U32      cmdSts     ;    /* Descriptor command status        */
+    MV_U16      bufSize    ;    /* Buffer size                      */
+    MV_U16      byteCnt    ;    /* Descriptor buffer byte count     */
+    MV_U32      bufPtr     ;    /* Descriptor buffer pointer        */
+    MV_U32      nextDescPtr;    /* Next descriptor pointer          */
+    MV_ULONG    returnInfo ;    /* User resource return information */
+} ETH_RX_DESC;
+
+typedef struct _ethTxDesc {
+    MV_U32      cmdSts     ;    /* Descriptor command status        */
+    MV_U16      L4iChk     ;    /* CPU provided TCP Checksum        */
+    MV_U16      byteCnt    ;    /* Descriptor buffer byte count     */
+    MV_U32      bufPtr     ;    /* Descriptor buffer pointer        */
+    MV_U32      nextDescPtr;    /* Next descriptor pointer          */
+    MV_ULONG    returnInfo ;    /* User resource return information */
+    MV_U8	*alignBufPtr;   /* Pointer to 32 byte aligned buffer */
+} ETH_TX_DESC;
+
+#else
+#error "MV_CPU_BE or MV_CPU_LE must be defined"
+#endif /* MV_CPU_BE || MV_CPU_LE */
+
+/* Buffer offset from buffer pointer */
+#define ETH_RX_BUF_OFFSET               0x2
+
+
+/* Tx & Rx descriptor bits */
+#define ETH_ERROR_SUMMARY_BIT               0
+#define ETH_ERROR_SUMMARY_MASK              (1<<ETH_ERROR_SUMMARY_BIT)
+
+#define ETH_BUFFER_OWNER_BIT                31
+#define ETH_BUFFER_OWNED_BY_DMA             (1<<ETH_BUFFER_OWNER_BIT)
+#define ETH_BUFFER_OWNED_BY_HOST            (0<<ETH_BUFFER_OWNER_BIT)
+
+/* Tx descriptor bits */
+#define ETH_TX_ERROR_CODE_OFFSET            1
+#define ETH_TX_ERROR_CODE_MASK              (3<<ETH_TX_ERROR_CODE_OFFSET)
+#define ETH_TX_LATE_COLLISION_ERROR         (0<<ETH_TX_ERROR_CODE_OFFSET)
+#define ETH_TX_UNDERRUN_ERROR               (1<<ETH_TX_ERROR_CODE_OFFSET)
+#define ETH_TX_EXCESSIVE_COLLISION_ERROR    (2<<ETH_TX_ERROR_CODE_OFFSET)
+
+#define ETH_TX_LLC_SNAP_FORMAT_BIT          9
+#define ETH_TX_LLC_SNAP_FORMAT_MASK         (1<<ETH_TX_LLC_SNAP_FORMAT_BIT)
+
+#define ETH_TX_IP_FRAG_BIT                  10
+#define ETH_TX_IP_FRAG_MASK                 (1<<ETH_TX_IP_FRAG_BIT)
+#define ETH_TX_IP_FRAG                      (0<<ETH_TX_IP_FRAG_BIT)
+#define ETH_TX_IP_NO_FRAG                   (1<<ETH_TX_IP_FRAG_BIT)
+
+#define ETH_TX_IP_HEADER_LEN_OFFSET         11
+#define ETH_TX_IP_HEADER_LEN_ALL_MASK       (0xF<<ETH_TX_IP_HEADER_LEN_OFFSET)
+#define ETH_TX_IP_HEADER_LEN_MASK(len)      ((len)<<ETH_TX_IP_HEADER_LEN_OFFSET)
+
+#define ETH_TX_VLAN_TAGGED_FRAME_BIT        15
+#define ETH_TX_VLAN_TAGGED_FRAME_MASK       (1<<ETH_TX_VLAN_TAGGED_FRAME_BIT)
+
+#define ETH_TX_L4_TYPE_BIT                  16
+#define ETH_TX_L4_TCP_TYPE                  (0<<ETH_TX_L4_TYPE_BIT)
+#define ETH_TX_L4_UDP_TYPE                  (1<<ETH_TX_L4_TYPE_BIT)
+
+#define ETH_TX_GENERATE_L4_CHKSUM_BIT       17
+#define ETH_TX_GENERATE_L4_CHKSUM_MASK      (1<<ETH_TX_GENERATE_L4_CHKSUM_BIT)
+
+#define ETH_TX_GENERATE_IP_CHKSUM_BIT       18
+#define ETH_TX_GENERATE_IP_CHKSUM_MASK      (1<<ETH_TX_GENERATE_IP_CHKSUM_BIT)
+
+#define ETH_TX_ZERO_PADDING_BIT             19
+#define ETH_TX_ZERO_PADDING_MASK            (1<<ETH_TX_ZERO_PADDING_BIT)
+
+#define ETH_TX_LAST_DESC_BIT                20
+#define ETH_TX_LAST_DESC_MASK               (1<<ETH_TX_LAST_DESC_BIT)
+
+#define ETH_TX_FIRST_DESC_BIT               21
+#define ETH_TX_FIRST_DESC_MASK              (1<<ETH_TX_FIRST_DESC_BIT)
+
+#define ETH_TX_GENERATE_CRC_BIT             22
+#define ETH_TX_GENERATE_CRC_MASK            (1<<ETH_TX_GENERATE_CRC_BIT)
+
+#define ETH_TX_ENABLE_INTERRUPT_BIT         23
+#define ETH_TX_ENABLE_INTERRUPT_MASK        (1<<ETH_TX_ENABLE_INTERRUPT_BIT)
+
+#define ETH_TX_AUTO_MODE_BIT                30
+#define ETH_TX_AUTO_MODE_MASK               (1<<ETH_TX_AUTO_MODE_BIT)
+
+
+/* Rx descriptor bits */
+#define ETH_RX_ERROR_CODE_OFFSET            1
+#define ETH_RX_ERROR_CODE_MASK              (3<<ETH_RX_ERROR_CODE_OFFSET)
+#define ETH_RX_CRC_ERROR                    (0<<ETH_RX_ERROR_CODE_OFFSET)
+#define ETH_RX_OVERRUN_ERROR                (1<<ETH_RX_ERROR_CODE_OFFSET)
+#define ETH_RX_MAX_FRAME_LEN_ERROR          (2<<ETH_RX_ERROR_CODE_OFFSET)
+#define ETH_RX_RESOURCE_ERROR               (3<<ETH_RX_ERROR_CODE_OFFSET)
+
+#define ETH_RX_L4_CHECKSUM_OFFSET           3
+#define ETH_RX_L4_CHECKSUM_MASK             (0xffff<<ETH_RX_L4_CHECKSUM_OFFSET)
+
+#define ETH_RX_VLAN_TAGGED_FRAME_BIT        19
+#define ETH_RX_VLAN_TAGGED_FRAME_MASK       (1<<ETH_RX_VLAN_TAGGED_FRAME_BIT)
+
+#define ETH_RX_BPDU_FRAME_BIT               20
+#define ETH_RX_BPDU_FRAME_MASK              (1<<ETH_RX_BPDU_FRAME_BIT)
+
+#define ETH_RX_L4_TYPE_OFFSET               21
+#define ETH_RX_L4_TYPE_MASK                 (3<<ETH_RX_L4_TYPE_OFFSET)
+#define ETH_RX_L4_TCP_TYPE                  (0<<ETH_RX_L4_TYPE_OFFSET)
+#define ETH_RX_L4_UDP_TYPE                  (1<<ETH_RX_L4_TYPE_OFFSET)
+#define ETH_RX_L4_OTHER_TYPE                (2<<ETH_RX_L4_TYPE_OFFSET)
+
+#define ETH_RX_NOT_LLC_SNAP_FORMAT_BIT      23
+#define ETH_RX_NOT_LLC_SNAP_FORMAT_MASK     (1<<ETH_RX_NOT_LLC_SNAP_FORMAT_BIT)
+
+#define ETH_RX_IP_FRAME_TYPE_BIT            24
+#define ETH_RX_IP_FRAME_TYPE_MASK           (1<<ETH_RX_IP_FRAME_TYPE_BIT)
+
+#define ETH_RX_IP_HEADER_OK_BIT             25
+#define ETH_RX_IP_HEADER_OK_MASK            (1<<ETH_RX_IP_HEADER_OK_BIT)
+
+#define ETH_RX_LAST_DESC_BIT                26
+#define ETH_RX_LAST_DESC_MASK               (1<<ETH_RX_LAST_DESC_BIT)
+
+#define ETH_RX_FIRST_DESC_BIT               27
+#define ETH_RX_FIRST_DESC_MASK              (1<<ETH_RX_FIRST_DESC_BIT)
+
+#define ETH_RX_UNKNOWN_DA_BIT               28
+#define ETH_RX_UNKNOWN_DA_MASK              (1<<ETH_RX_UNKNOWN_DA_BIT)
+
+#define ETH_RX_ENABLE_INTERRUPT_BIT         29
+#define ETH_RX_ENABLE_INTERRUPT_MASK        (1<<ETH_RX_ENABLE_INTERRUPT_BIT)
+
+#define ETH_RX_L4_CHECKSUM_OK_BIT           30
+#define ETH_RX_L4_CHECKSUM_OK_MASK          (1<<ETH_RX_L4_CHECKSUM_OK_BIT)
+
+/* Rx descriptor bufSize field */
+#define ETH_RX_IP_FRAGMENTED_FRAME_BIT      2
+#define ETH_RX_IP_FRAGMENTED_FRAME_MASK     (1<<ETH_RX_IP_FRAGMENTED_FRAME_BIT)
+
+#define ETH_RX_BUFFER_MASK                  0xFFF8
+
+
+/* Ethernet Cause Register BITs */
+#define ETH_CAUSE_RX_READY_SUM_BIT          0
+#define ETH_CAUSE_EXTEND_BIT                1
+
+#define ETH_CAUSE_RX_READY_OFFSET           2
+#define ETH_CAUSE_RX_READY_BIT(queue)       (ETH_CAUSE_RX_READY_OFFSET + (queue))
+#define ETH_CAUSE_RX_READY_MASK(queue)      (1 << (ETH_CAUSE_RX_READY_BIT(queue)))
+
+#define ETH_CAUSE_RX_ERROR_SUM_BIT          10
+#define ETH_CAUSE_RX_ERROR_OFFSET           11
+#define ETH_CAUSE_RX_ERROR_BIT(queue)       (ETH_CAUSE_RX_ERROR_OFFSET + (queue))
+#define ETH_CAUSE_RX_ERROR_MASK(queue)      (1 << (ETH_CAUSE_RX_ERROR_BIT(queue)))
+
+#define ETH_CAUSE_TX_END_BIT                19
+#define ETH_CAUSE_SUM_BIT                   31
+
+/* Ethernet Cause Extended Register BITs */
+#define ETH_CAUSE_TX_BUF_OFFSET             0
+#define ETH_CAUSE_TX_BUF_BIT(queue)         (ETH_CAUSE_TX_BUF_OFFSET + (queue))
+#define ETH_CAUSE_TX_BUF_MASK(queue)        (1 << (ETH_CAUSE_TX_BUF_BIT(queue)))
+
+#define ETH_CAUSE_TX_ERROR_OFFSET           8
+#define ETH_CAUSE_TX_ERROR_BIT(queue)       (ETH_CAUSE_TX_ERROR_OFFSET + (queue))
+#define ETH_CAUSE_TX_ERROR_MASK(queue)      (1 << (ETH_CAUSE_TX_ERROR_BIT(queue)))
+
+#define ETH_CAUSE_PHY_STATUS_CHANGE_BIT     16
+#define ETH_CAUSE_RX_OVERRUN_BIT            18
+#define ETH_CAUSE_TX_UNDERRUN_BIT           19
+#define ETH_CAUSE_LINK_STATE_CHANGE_BIT     20
+#define ETH_CAUSE_INTERNAL_ADDR_ERR_BIT     23
+#define ETH_CAUSE_EXTEND_SUM_BIT            31
+
+/* Marvell Header Register */
+/* Marvell Header register bits */
+#define ETH_MVHDR_EN_BIT                    0
+#define ETH_MVHDR_EN_MASK                   (1 << ETH_MVHDR_EN_BIT)
+
+#define ETH_MVHDR_DAPREFIX_BIT              1
+#define ETH_MVHDR_DAPREFIX_MASK             (0x3 << ETH_MVHDR_DAPREFIX_BIT)
+#define ETH_MVHDR_DAPREFIX_PRI_1_2          (0x1 << ETH_MVHDR_DAPREFIX_BIT)
+#define ETH_MVHDR_DAPREFIX_DBNUM_PRI        (0x2 << ETH_MVHDR_DAPREFIX_BIT)
+#define ETH_MVHDR_DAPREFIX_SPID_PRI         (0x3 << ETH_MVHDR_DAPREFIX_BIT)
+
+#define ETH_MVHDR_MHMASK_BIT                8
+#define ETH_MVHDR_MHMASK_MASK               (0x3 << ETH_MVHDR_MHMASK_BIT)
+#define ETH_MVHDR_MHMASK_8_QUEUE            (0x0 << ETH_MVHDR_MHMASK_BIT)
+#define ETH_MVHDR_MHMASK_4_QUEUE            (0x1 << ETH_MVHDR_MHMASK_BIT)
+#define ETH_MVHDR_MHMASK_2_QUEUE            (0x3 << ETH_MVHDR_MHMASK_BIT)
+
+
+/* Relevant for 6183 ONLY */
+#define ETH_UNIT_PORTS_PADS_CALIB_0_REG     (MV_ETH_REGS_BASE(0) + 0x0A0)
+#define ETH_UNIT_PORTS_PADS_CALIB_1_REG     (MV_ETH_REGS_BASE(0) + 0x0A4)
+#define ETH_UNIT_PORTS_PADS_CALIB_2_REG     (MV_ETH_REGS_BASE(0) + 0x0A8)
+/* Ethernet Unit Ports Pads Calibration_REG (ETH_UNIT_PORTS_PADS_CALIB_x_REG)  */
+#define ETH_ETHERNET_PAD_CLIB_DRVN_OFFS		0
+#define ETH_ETHERNET_PAD_CLIB_DRVN_MASK		(0x1F << ETH_ETHERNET_PAD_CLIB_DRVN_OFFS)
+
+#define ETH_ETHERNET_PAD_CLIB_DRVP_OFFS         5
+#define ETH_ETHERNET_PAD_CLIB_DRVP_MASK         (0x1F << ETH_ETHERNET_PAD_CLIB_DRVP_OFFS)
+
+#define ETH_ETHERNET_PAD_CLIB_TUNEEN_OFFS       16
+#define ETH_ETHERNET_PAD_CLIB_TUNEEN_MASK       (0x1 << ETH_ETHERNET_PAD_CLIB_TUNEEN_OFFS)
+
+#define ETH_ETHERNET_PAD_CLIB_LOCKN_OFFS        17
+#define ETH_ETHERNET_PAD_CLIB_LOCKN_MASK        (0x1F << ETH_ETHERNET_PAD_CLIB_LOCKN_OFFS)
+
+#define ETH_ETHERNET_PAD_CLIB_OFFST_OFFS        24
+#define ETH_ETHERNET_PAD_CLIB_OFFST_MASK        (0x1F << ETH_ETHERNET_PAD_CLIB_OFFST_OFFS)
+
+#define ETH_ETHERNET_PAD_CLIB_WR_EN_OFFS        31
+#define ETH_ETHERNET_PAD_CLIB_WR_EN_MASK        (0x1  << ETH_ETHERNET_PAD_CLIB_WR_EN_OFFS)
+
+
+/**** Address decode register ****/
+
+#define ETH_WIN_BASE_REG(port, win)         (MV_ETH_REGS_BASE(port) + 0x200 + ((win)<<3))
+#define ETH_WIN_SIZE_REG(port, win)         (MV_ETH_REGS_BASE(port) + 0x204 + ((win)<<3))
+#define ETH_WIN_REMAP_REG(port, win)        (MV_ETH_REGS_BASE(port) + 0x280 + ((win)<<2))
+#define ETH_BASE_ADDR_ENABLE_REG(port)      (MV_ETH_REGS_BASE(port) + 0x290)
+#define ETH_ACCESS_PROTECT_REG(port)        (MV_ETH_REGS_BASE(port) + 0x294)
+
+/* Ethernet Base Address Register bits		    */
+#define ETH_MAX_DECODE_WIN              6
+#define ETH_MAX_HIGH_ADDR_REMAP_WIN     4
+
+/* Ethernet Port Access Protect (EPAP) register	    */
+/* The target associated with this window	    */
+#define ETH_WIN_TARGET_OFFS             0
+#define ETH_WIN_TARGET_MASK             (0xf << ETH_WIN_TARGET_OFFS)
+/* The target attributes Associated with window	    */
+#define ETH_WIN_ATTR_OFFS               8
+#define ETH_WIN_ATTR_MASK               (0xff << ETH_WIN_ATTR_OFFS)
+
+#define ETH_WIN_SIZE_OFFS		16
+#define ETH_WIN_SIZE_MASK		(0xFFFF<<ETH_WIN_SIZE_OFFS)
+#define ETH_WIN_BASE_OFFS		16
+#define ETH_WIN_BASE_MASK		(0xFFFF<<ETH_WIN_BASE_OFFS)
+
+/* Ethernet Port Access Protect Register (EPAPR)    */
+#define ETH_PROT_NO_ACCESS              NO_ACCESS_ALLOWED
+#define ETH_PROT_READ_ONLY              READ_ONLY
+#define ETH_PROT_FULL_ACCESS            FULL_ACCESS
+#define ETH_PROT_WIN_OFFS(winNum)       (2 * (winNum))
+#define ETH_PROT_WIN_MASK(winNum)       (0x3 << ETH_PROT_WIN_OFFS(winNum))
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvEthRegsh */
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/Makefile linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/Makefile
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/Makefile	2014-04-08 19:18:02.000000000 +0700
@@ -0,0 +1,2 @@
+#obj-y	+= mv_switch_d.o
+obj-y	+= mv_switch.o mv_switch_api.o mv_switch_sysfs.o
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/mv_netdev.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/mv_netdev.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/mv_netdev.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/mv_netdev.h	2013-10-03 15:45:02.000000000 +0700
@@ -0,0 +1,850 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#ifndef __mv_netdev_h__
+#define __mv_netdev_h__
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <net/ip.h>
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "mv802_3.h"
+#include "mvStack.h"
+
+#include "gbe/mvNeta.h"
+#include "bm/mvBmRegs.h"
+#include "bm/mvBm.h"
+
+
+/******************************************************
+ * driver statistics control --                       *
+ ******************************************************/
+#ifdef CONFIG_MV_ETH_STAT_ERR
+#define STAT_ERR(c) c
+#else
+#define STAT_ERR(c)
+#endif
+
+#ifdef CONFIG_MV_ETH_STAT_INF
+#define STAT_INFO(c) c
+#else
+#define STAT_INFO(c)
+#endif
+
+#ifdef CONFIG_MV_ETH_STAT_DBG
+#define STAT_DBG(c) c
+#else
+#define STAT_DBG(c)
+#endif
+
+#ifdef CONFIG_MV_ETH_STAT_DIST
+#define STAT_DIST(c) c
+#else
+#define STAT_DIST(c)
+#endif
+
+#ifdef CONFIG_MV_ETH_PNC
+extern unsigned int mv_eth_pnc_ctrl_en;
+int mv_eth_ctrl_pnc(int en);
+#endif /* CONFIG_MV_ETH_PNC */
+
+extern int mv_ctrl_txdone;
+
+/****************************************************************************
+ * Rx buffer size: MTU + 2(Marvell Header) + 4(VLAN) + 14(MAC hdr) + 4(CRC) *
+ ****************************************************************************/
+#define RX_PKT_SIZE(mtu) \
+		MV_ALIGN_UP((mtu) + 2 + 4 + ETH_HLEN + 4, CPU_D_CACHE_LINE_SIZE)
+
+#define RX_BUF_SIZE(pkt_size)   ((pkt_size) + NET_SKB_PAD)
+
+
+#ifdef CONFIG_NET_SKB_RECYCLE
+extern int mv_ctrl_recycle;
+
+#define mv_eth_is_recycle()     (mv_ctrl_recycle)
+int mv_eth_skb_recycle(struct sk_buff *skb);
+#else
+#define mv_eth_is_recycle()     0
+#endif /* CONFIG_NET_SKB_RECYCLE */
+
+/******************************************************
+ * interrupt control --                               *
+ ******************************************************/
+#ifdef CONFIG_MV_ETH_TXDONE_ISR
+#define MV_ETH_TXDONE_INTR_MASK       (((1 << CONFIG_MV_ETH_TXQ) - 1) << NETA_CAUSE_TXQ_SENT_DESC_OFFS)
+#else
+#define MV_ETH_TXDONE_INTR_MASK       0
+#endif
+
+#define MV_ETH_MISC_SUM_INTR_MASK     (NETA_CAUSE_TX_ERR_SUM_MASK | NETA_CAUSE_MISC_SUM_MASK)
+#define MV_ETH_RX_INTR_MASK           (((1 << CONFIG_MV_ETH_RXQ) - 1) << NETA_CAUSE_RXQ_OCCUP_DESC_OFFS)
+#define NETA_RX_FL_DESC_MASK          (NETA_RX_F_DESC_MASK|NETA_RX_L_DESC_MASK)
+
+/* NAPI CPU defualt group */
+#define CPU_GROUP_DEF 0
+
+#define MV_ETH_TRYLOCK(lock, flags)                           \
+	(in_interrupt() ? spin_trylock((lock)) :              \
+		spin_trylock_irqsave((lock), (flags)))
+
+#define MV_ETH_LOCK(lock, flags)                              \
+{                                                             \
+	if (in_interrupt())                                   \
+		spin_lock((lock));                            \
+	else                                                  \
+		spin_lock_irqsave((lock), (flags));           \
+}
+
+#define MV_ETH_UNLOCK(lock, flags)                            \
+{                                                             \
+	if (in_interrupt())                                   \
+		spin_unlock((lock));                          \
+	else                                                  \
+		spin_unlock_irqrestore((lock), (flags));      \
+}
+
+#define MV_ETH_LIGHT_LOCK(flags)                              \
+	if (!in_interrupt())                                  \
+		local_irq_save(flags);
+
+#define MV_ETH_LIGHT_UNLOCK(flags)	                      \
+	if (!in_interrupt())                                  \
+		local_irq_restore(flags);
+
+
+#define mv_eth_lock(txq_ctrl, flags)			     \
+{							     \
+	if (txq_ctrl->flags & MV_ETH_F_TX_SHARED)	     \
+		MV_ETH_LOCK(&txq_ctrl->queue_lock, flags)    \
+	else                                                 \
+		MV_ETH_LIGHT_LOCK(flags)		     \
+}
+
+#define mv_eth_unlock(txq_ctrl, flags)    	              \
+{							      \
+	if (txq_ctrl->flags & MV_ETH_F_TX_SHARED)	      \
+		MV_ETH_UNLOCK(&txq_ctrl->queue_lock, flags)   \
+	else                                                  \
+		MV_ETH_LIGHT_UNLOCK(flags)		      \
+}
+
+
+/******************************************************
+ * rx / tx queues --                                  *
+ ******************************************************/
+/*
+ * Debug statistics
+ */
+
+struct txq_stats {
+#ifdef CONFIG_MV_ETH_STAT_ERR
+	u32 txq_err;
+#endif /* CONFIG_MV_ETH_STAT_ERR */
+#ifdef CONFIG_MV_ETH_STAT_DBG
+	u32 txq_tx;
+	u32 txq_txdone;
+#endif /* CONFIG_MV_ETH_STAT_DBG */
+};
+
+struct port_stats {
+
+#ifdef CONFIG_MV_ETH_STAT_ERR
+	u32 rx_error;
+	u32 tx_timeout;
+	u32 netif_stop;
+	u32 ext_stack_empty;
+	u32 ext_stack_full;
+	u32 netif_wake;
+	u32 state_err;
+#endif /* CONFIG_MV_ETH_STAT_ERR */
+
+#ifdef CONFIG_MV_ETH_STAT_INF
+	u32 irq;
+	u32 irq_err;
+	u32 poll[CONFIG_NR_CPUS];
+	u32 poll_exit[CONFIG_NR_CPUS];
+	u32 tx_fragment;
+	u32 tx_done;
+	u32 tx_done_timer;
+	u32 cleanup_timer;
+	u32 link;
+	u32 netdev_stop;
+
+#ifdef CONFIG_MV_ETH_RX_SPECIAL
+	u32 rx_special;
+#endif /* CONFIG_MV_ETH_RX_SPECIAL */
+
+#ifdef CONFIG_MV_ETH_TX_SPECIAL
+	u32	tx_special;
+#endif /* CONFIG_MV_ETH_TX_SPECIAL */
+
+#endif /* CONFIG_MV_ETH_STAT_INF */
+
+#ifdef CONFIG_MV_ETH_STAT_DBG
+	u32 rxq[CONFIG_MV_ETH_RXQ];
+	u32 rxq_fill[CONFIG_MV_ETH_RXQ];
+	u32 rx_netif;
+	u32 rx_nfp;
+	u32 rx_nfp_drop;
+	u32 rx_gro;
+	u32 rx_gro_bytes;
+	u32 rx_drop_sw;
+	u32 rx_csum_hw;
+	u32 rx_csum_sw;
+	u32 tx_csum_hw;
+	u32 tx_csum_sw;
+	u32 tx_skb_free;
+	u32 tx_sg;
+	u32 tx_tso;
+	u32 tx_tso_bytes;
+	u32 ext_stack_put;
+	u32 ext_stack_get;
+#endif /* CONFIG_MV_ETH_STAT_DBG */
+};
+
+/* Used for define type of data saved in shadow: SKB or eth_pbuf or nothing */
+#define MV_ETH_SHADOW_SKB		0x1
+#define MV_ETH_SHADOW_EXT		0x2
+
+/* Masks used for pp->flags */
+#define MV_ETH_F_STARTED_BIT        0
+#define MV_ETH_F_SWITCH_BIT         1	/* port is connected to the Switch using the Gateway driver */
+#define MV_ETH_F_MH_BIT             2
+#define MV_ETH_F_NO_PAD_BIT         3
+#define MV_ETH_F_DBG_RX_BIT         4
+#define MV_ETH_F_DBG_TX_BIT         5
+#define MV_ETH_F_EXT_SWITCH_BIT	    6	/* port is connected to the Switch without the Gateway driver */
+#define MV_ETH_F_CONNECT_LINUX_BIT  7	/* port is connected to Linux netdevice */
+#define MV_ETH_F_LINK_UP_BIT        8
+#define MV_ETH_F_DBG_DUMP_BIT       9
+#define MV_ETH_F_DBG_ISR_BIT        10
+#define MV_ETH_F_DBG_POLL_BIT       11
+#define MV_ETH_F_NFP_EN_BIT         12
+#define MV_ETH_F_SUSPEND_BIT        13
+#define MV_ETH_F_STARTED_OLD_BIT    14 /*STARTED_BIT value before suspend */
+
+
+#define MV_ETH_F_STARTED           (1 << MV_ETH_F_STARTED_BIT)
+#define MV_ETH_F_SWITCH            (1 << MV_ETH_F_SWITCH_BIT)
+#define MV_ETH_F_MH                (1 << MV_ETH_F_MH_BIT)
+#define MV_ETH_F_NO_PAD            (1 << MV_ETH_F_NO_PAD_BIT)
+#define MV_ETH_F_DBG_RX            (1 << MV_ETH_F_DBG_RX_BIT)
+#define MV_ETH_F_DBG_TX            (1 << MV_ETH_F_DBG_TX_BIT)
+#define MV_ETH_F_EXT_SWITCH        (1 << MV_ETH_F_EXT_SWITCH_BIT)
+#define MV_ETH_F_CONNECT_LINUX     (1 << MV_ETH_F_CONNECT_LINUX_BIT)
+#define MV_ETH_F_LINK_UP           (1 << MV_ETH_F_LINK_UP_BIT)
+#define MV_ETH_F_DBG_DUMP          (1 << MV_ETH_F_DBG_DUMP_BIT)
+#define MV_ETH_F_DBG_ISR           (1 << MV_ETH_F_DBG_ISR_BIT)
+#define MV_ETH_F_DBG_POLL          (1 << MV_ETH_F_DBG_POLL_BIT)
+#define MV_ETH_F_NFP_EN            (1 << MV_ETH_F_NFP_EN_BIT)
+#define MV_ETH_F_SUSPEND           (1 << MV_ETH_F_SUSPEND_BIT)
+#define MV_ETH_F_STARTED_OLD       (1 << MV_ETH_F_STARTED_OLD_BIT)
+
+/* Masks used for cpu_ctrl->flags */
+#define MV_ETH_F_TX_DONE_TIMER_BIT  0
+#define MV_ETH_F_CLEANUP_TIMER_BIT  1
+
+#define MV_ETH_F_TX_DONE_TIMER		(1 << MV_ETH_F_TX_DONE_TIMER_BIT)	/* 0x01 */
+#define MV_ETH_F_CLEANUP_TIMER		(1 << MV_ETH_F_CLEANUP_TIMER_BIT)	/* 0x02 */
+
+/* Masks used for tx_queue->flags */
+#define MV_ETH_F_TX_SHARED_BIT  0
+
+#define MV_ETH_F_TX_SHARED		(1 << MV_ETH_F_TX_SHARED_BIT)	/* 0x01 */
+
+
+
+/* One of three TXQ states */
+#define MV_ETH_TXQ_FREE         0
+#define MV_ETH_TXQ_CPU          1
+#define MV_ETH_TXQ_HWF          2
+
+#define MV_ETH_TXQ_INVALID		0xFF
+
+struct mv_eth_tx_spec {
+	u32		hw_cmd;	/* tx_desc offset = 0xC */
+	u16		flags;
+	u8		txp;
+	u8		txq;
+#ifdef CONFIG_MV_ETH_TX_SPECIAL
+	void		(*tx_func) (u8 *data, int size, struct mv_eth_tx_spec *tx_spec);
+#endif
+};
+
+struct tx_queue {
+	MV_NETA_TXQ_CTRL   *q;
+	u8                  cpu_owner[CONFIG_NR_CPUS]; /* counter */
+	u8                  hwf_rxp;
+	u8                  txp;
+	u8                  txq;
+	int                 txq_size;
+	int                 txq_count;
+	int                 bm_only;
+	u32                 *shadow_txq; /* can be MV_ETH_PKT* or struct skbuf* */
+	int                 shadow_txq_put_i;
+	int                 shadow_txq_get_i;
+	struct txq_stats    stats;
+	spinlock_t          queue_lock;
+	MV_U32              txq_done_pkts_coal;
+	unsigned long       flags;
+	int		    nfpCounter;
+};
+
+struct rx_queue {
+	MV_NETA_RXQ_CTRL    *q;
+	int                 rxq_size;
+	int                 missed;
+	MV_U32	            rxq_pkts_coal;
+	MV_U32	            rxq_time_coal;
+};
+
+struct dist_stats {
+	u32     *rx_dist;
+	int     rx_dist_size;
+	u32     *tx_done_dist;
+	int     tx_done_dist_size;
+	u32     *tx_tso_dist;
+	int     tx_tso_dist_size;
+};
+
+struct cpu_ctrl {
+	MV_U8  			cpuTxqMask;
+	MV_U8			cpuRxqMask;
+	MV_U8			cpuTxqOwner;
+	MV_U8  			txq_tos_map[256];
+	MV_U32			causeRxTx;
+	struct napi_struct	*napi;
+	int			napiCpuGroup;
+	int             	txq;
+	struct timer_list   	tx_done_timer;
+	struct timer_list   	cleanup_timer;
+	unsigned long       	flags;
+
+};
+
+struct eth_port {
+	int                 port;
+	MV_NETA_PORT_CTRL   *port_ctrl;
+	struct rx_queue     *rxq_ctrl;
+	struct tx_queue     *txq_ctrl;
+	int                 txp_num;
+	struct net_device   *dev;
+	rwlock_t            rwlock;
+	struct bm_pool      *pool_long;
+	int                 pool_long_num;
+#ifdef CONFIG_MV_ETH_BM_CPU
+	struct bm_pool      *pool_short;
+	int                 pool_short_num;
+#endif /* CONFIG_MV_ETH_BM_CPU */
+	struct napi_struct  *napiGroup[CONFIG_MV_ETH_NAPI_GROUPS];
+	unsigned long       flags;	/* MH, TIMER, etc. */
+	u32                 hw_cmd;	/* offset 0xc in TX descriptor */
+	int                 txp;
+	u16                 tx_mh;	/* 2B MH */
+	struct port_stats   stats;
+	struct dist_stats   dist_stats;
+	int                 weight;
+	MV_STACK            *extArrStack;
+	int                 extBufSize;
+	spinlock_t          extLock;
+#ifdef CONFIG_MV_ETH_TOOL
+	__u16               speed_cfg;
+	__u8                duplex_cfg;
+	__u8                autoneg_cfg;
+	__u16		        advertise_cfg;
+#endif/* CONFIG_MV_ETH_TOOL */
+#ifdef CONFIG_MV_ETH_RX_CSUM_OFFLOAD
+	MV_U32              rx_csum_offload;
+#endif /* CONFIG_MV_ETH_RX_CSUM_OFFLOAD */
+#ifdef CONFIG_MV_ETH_RX_SPECIAL
+	void    (*rx_special_proc)(int port, int rxq, struct net_device *dev,
+					struct sk_buff *skb, struct neta_rx_desc *rx_desc);
+#endif /* CONFIG_MV_ETH_RX_SPECIAL */
+#ifdef CONFIG_MV_ETH_TX_SPECIAL
+	int     (*tx_special_check)(int port, struct net_device *dev, struct sk_buff *skb,
+					struct mv_eth_tx_spec *tx_spec_out);
+#endif /* CONFIG_MV_ETH_TX_SPECIAL */
+	MV_U32 cpuMask;
+	MV_U32 rx_indir_table[256];
+	struct cpu_ctrl	*cpu_config[CONFIG_NR_CPUS];
+	MV_U32  sgmii_serdes;
+	int	wol_mode;
+};
+
+struct eth_netdev {
+	u16     tx_vlan_mh;		/* 2B MH */
+	u16     vlan_grp_id;		/* vlan group ID */
+	u16     port_map;		/* switch port map */
+	u16     link_map;		/* switch port link map */
+	u16     cpu_port;		/* switch CPU port */
+	u16     group;
+};
+
+struct eth_dev_priv {
+	struct eth_port     *port_p;
+	struct eth_netdev   *netdev_p;
+};
+
+#define MV_ETH_PRIV(dev)        (((struct eth_dev_priv *)(netdev_priv(dev)))->port_p)
+#define MV_DEV_PRIV(dev)        (((struct eth_dev_priv *)(netdev_priv(dev)))->netdev_p)
+#define MV_DEV_STAT(dev)        (&((dev)->stats))
+
+/* define which Switch ports are relevant */
+#define SWITCH_CONNECTED_PORTS_MASK	0x7F
+
+#define MV_SWITCH_ID_0			0
+#define MV_ETH_PORT_0			0
+#define MV_ETH_PORT_1			1
+
+struct pool_stats {
+#ifdef CONFIG_MV_ETH_STAT_ERR
+	u32 skb_alloc_oom;
+	u32 stack_empty;
+	u32 stack_full;
+#endif /* CONFIG_MV_ETH_STAT_ERR */
+
+#ifdef CONFIG_MV_ETH_STAT_DBG
+	u32 bm_put;
+	u32 stack_put;
+	u32 stack_get;
+	u32 skb_alloc_ok;
+	u32 skb_recycled_ok;
+	u32 skb_recycled_err;
+#endif /* CONFIG_MV_ETH_STAT_DBG */
+};
+
+struct bm_pool {
+	int         pool;
+	int         capacity;
+	int         buf_num;
+	int         pkt_size;
+	MV_ULONG    physAddr;
+	u32         *bm_pool;
+	MV_STACK    *stack;
+	spinlock_t  lock;
+	u32         port_map;
+	int         missed;		/* FIXME: move to stats */
+	struct pool_stats  stats;
+};
+
+#ifdef CONFIG_MV_ETH_BM_CPU
+#define MV_ETH_BM_POOLS	        MV_BM_POOLS
+#define mv_eth_pool_bm(p)       (p->bm_pool)
+#define mv_eth_txq_bm(q)        (q->bm_only)
+#else
+#define MV_ETH_BM_POOLS		CONFIG_MV_ETH_PORTS_NUM
+#define mv_eth_pool_bm(p)       0
+#define mv_eth_txq_bm(q)        0
+#endif /* CONFIG_MV_ETH_BM_CPU */
+
+#ifdef CONFIG_MV_ETH_BM
+MV_STATUS mv_eth_bm_config_get(void);
+int mv_eth_bm_config_pkt_size_get(int pool);
+int mv_eth_bm_config_pkt_size_set(int pool, int pkt_size);
+int mv_eth_bm_config_short_pool_get(int port);
+int mv_eth_bm_config_short_buf_num_get(int port);
+int mv_eth_bm_config_long_pool_get(int port);
+int mv_eth_bm_config_long_buf_num_get(int port);
+void mv_eth_bm_config_print(void);
+#endif /* CONFIG_MV_ETH_BM */
+
+void mv_eth_stack_print(int port, MV_BOOL isPrintElements);
+extern struct bm_pool mv_eth_pool[MV_ETH_BM_POOLS];
+extern struct eth_port **mv_eth_ports;
+
+static inline void mv_eth_interrupts_unmask(struct eth_port *pp)
+{
+	/* unmask interrupts */
+	if (!(pp->flags & (MV_ETH_F_SWITCH | MV_ETH_F_EXT_SWITCH)))
+		MV_REG_WRITE(NETA_INTR_MISC_MASK_REG(pp->port), NETA_CAUSE_LINK_CHANGE_MASK);
+
+	MV_REG_WRITE(NETA_INTR_NEW_MASK_REG(pp->port),
+		(MV_ETH_MISC_SUM_INTR_MASK |
+		MV_ETH_TXDONE_INTR_MASK |
+		MV_ETH_RX_INTR_MASK));
+}
+
+static inline void mv_eth_interrupts_mask(struct eth_port *pp)
+{
+	/* clear all ethernet port interrupts */
+	MV_REG_WRITE(NETA_INTR_MISC_CAUSE_REG(pp->port), 0);
+	MV_REG_WRITE(NETA_INTR_OLD_CAUSE_REG(pp->port), 0);
+
+	/* mask all ethernet port interrupts */
+	MV_REG_WRITE(NETA_INTR_NEW_MASK_REG(pp->port), 0);
+	MV_REG_WRITE(NETA_INTR_OLD_MASK_REG(pp->port), 0);
+	MV_REG_WRITE(NETA_INTR_MISC_MASK_REG(pp->port), 0);
+}
+
+
+static inline void mv_eth_txq_update_shared(struct tx_queue *txq_ctrl, struct eth_port *pp)
+{
+	int numOfRefCpu, cpu;
+	struct cpu_ctrl	*cpuCtrl;
+
+	numOfRefCpu = 0;
+
+	for_each_possible_cpu(cpu) {
+		cpuCtrl = pp->cpu_config[cpu];
+
+		if (txq_ctrl->cpu_owner[cpu] == 0)
+			cpuCtrl->cpuTxqOwner &= ~(1 << txq_ctrl->txq);
+		else {
+			numOfRefCpu++;
+			cpuCtrl->cpuTxqOwner |= (1 << txq_ctrl->txq);
+		}
+	}
+
+	if ((txq_ctrl->nfpCounter != 0) || (numOfRefCpu > 1))
+		txq_ctrl->flags |=  MV_ETH_F_TX_SHARED;
+	else
+		txq_ctrl->flags &= ~MV_ETH_F_TX_SHARED;
+}
+
+static inline int mv_eth_ctrl_is_tx_enabled(struct eth_port *pp)
+{
+	if (!pp)
+		return -ENODEV;
+
+	if (pp->flags & MV_ETH_F_CONNECT_LINUX)
+		return 1;
+
+	return 0;
+}
+
+static inline struct neta_tx_desc *mv_eth_tx_desc_get(struct tx_queue *txq_ctrl, int num)
+{
+	/* Is enough TX descriptors to send packet */
+	if ((txq_ctrl->txq_count + num) >= txq_ctrl->txq_size) {
+		/*
+		printk(KERN_ERR "eth_tx: txq_ctrl->txq=%d - no_resource: txq_count=%d, txq_size=%d, num=%d\n",
+			txq_ctrl->txq, txq_ctrl->txq_count, txq_ctrl->txq_size, num);
+		*/
+		STAT_ERR(txq_ctrl->stats.txq_err++);
+		return NULL;
+	}
+	return mvNetaTxqNextDescGet(txq_ctrl->q);
+}
+
+static inline void mv_eth_tx_desc_flush(struct neta_tx_desc *tx_desc)
+{
+#if defined(MV_CPU_BE)
+	mvNetaTxqDescSwap(tx_desc);
+#endif /* MV_CPU_BE */
+
+	mvOsCacheLineFlush(NULL, tx_desc);
+}
+
+static inline void *mv_eth_extra_pool_get(struct eth_port *pp)
+{
+	void *ext_buf;
+
+	spin_lock(&pp->extLock);
+	if (mvStackIndex(pp->extArrStack) == 0) {
+		STAT_ERR(pp->stats.ext_stack_empty++);
+		ext_buf = mvOsMalloc(CONFIG_MV_ETH_EXTRA_BUF_SIZE);
+	} else {
+		STAT_DBG(pp->stats.ext_stack_get++);
+		ext_buf = (void *)mvStackPop(pp->extArrStack);
+	}
+	spin_unlock(&pp->extLock);
+
+	return ext_buf;
+}
+
+static inline int mv_eth_extra_pool_put(struct eth_port *pp, void *ext_buf)
+{
+	spin_lock(&pp->extLock);
+	if (mvStackIsFull(pp->extArrStack)) {
+		STAT_ERR(pp->stats.ext_stack_full++);
+		spin_unlock(&pp->extLock);
+		mvOsFree(ext_buf);
+		return 1;
+	}
+	mvStackPush(pp->extArrStack, (MV_U32)ext_buf);
+	STAT_DBG(pp->stats.ext_stack_put++);
+	spin_unlock(&pp->extLock);
+	return 0;
+}
+
+static inline void mv_eth_add_cleanup_timer(struct cpu_ctrl *cpuCtrl)
+{
+	if (test_and_set_bit(MV_ETH_F_CLEANUP_TIMER_BIT, &(cpuCtrl->flags)) == 0) {
+		cpuCtrl->cleanup_timer.expires = jiffies + ((HZ * CONFIG_MV_ETH_CLEANUP_TIMER_PERIOD) / 1000); /* ms */
+		add_timer_on(&cpuCtrl->cleanup_timer, smp_processor_id());
+	}
+}
+
+static inline void mv_eth_add_tx_done_timer(struct cpu_ctrl *cpuCtrl)
+{
+	if (test_and_set_bit(MV_ETH_F_TX_DONE_TIMER_BIT, &(cpuCtrl->flags)) == 0) {
+
+		cpuCtrl->tx_done_timer.expires = jiffies + ((HZ * CONFIG_MV_ETH_TX_DONE_TIMER_PERIOD) / 1000); /* ms */
+		add_timer_on(&cpuCtrl->tx_done_timer, smp_processor_id());
+	}
+}
+
+static inline void mv_eth_shadow_inc_get(struct tx_queue *txq)
+{
+	txq->shadow_txq_get_i++;
+	if (txq->shadow_txq_get_i == txq->txq_size)
+		txq->shadow_txq_get_i = 0;
+}
+
+static inline void mv_eth_shadow_inc_put(struct tx_queue *txq)
+{
+	txq->shadow_txq_put_i++;
+	if (txq->shadow_txq_put_i == txq->txq_size)
+		txq->shadow_txq_put_i = 0;
+}
+
+static inline void mv_eth_shadow_dec_put(struct tx_queue *txq)
+{
+	if (txq->shadow_txq_put_i == 0)
+		txq->shadow_txq_put_i = txq->txq_size - 1;
+	else
+		txq->shadow_txq_put_i--;
+}
+
+/* Free pkt + skb pair */
+static inline void mv_eth_pkt_free(struct eth_pbuf *pkt)
+{
+	struct sk_buff *skb = (struct sk_buff *)pkt->osInfo;
+
+#ifdef CONFIG_NET_SKB_RECYCLE
+	skb->skb_recycle = NULL;
+	skb->hw_cookie = NULL;
+#endif /* CONFIG_NET_SKB_RECYCLE */
+
+	dev_kfree_skb_any(skb);
+	mvOsFree(pkt);
+}
+
+static inline int mv_eth_pool_put(struct bm_pool *pool, struct eth_pbuf *pkt)
+{
+	unsigned long flags = 0;
+
+	MV_ETH_LOCK(&pool->lock, flags);
+	if (mvStackIsFull(pool->stack)) {
+		STAT_ERR(pool->stats.stack_full++);
+		MV_ETH_UNLOCK(&pool->lock, flags);
+
+		/* free pkt+skb */
+		mv_eth_pkt_free(pkt);
+		return 1;
+	}
+	mvStackPush(pool->stack, (MV_U32) pkt);
+	STAT_DBG(pool->stats.stack_put++);
+	MV_ETH_UNLOCK(&pool->lock, flags);
+	return 0;
+}
+
+
+/* Pass pkt to BM Pool or RXQ ring */
+static inline void mv_eth_rxq_refill(struct eth_port *pp, int rxq,
+				     struct eth_pbuf *pkt, struct bm_pool *pool, struct neta_rx_desc *rx_desc)
+{
+	if (mv_eth_pool_bm(pool)) {
+		/* Refill BM pool */
+		STAT_DBG(pool->stats.bm_put++);
+		mvBmPoolPut(pkt->pool, (MV_ULONG) pkt->physAddr);
+		mvOsCacheLineInv(NULL, rx_desc);
+	} else {
+		/* Refill Rx descriptor */
+		STAT_DBG(pp->stats.rxq_fill[rxq]++);
+		mvNetaRxDescFill(rx_desc, pkt->physAddr, (MV_U32)pkt);
+	}
+}
+
+
+#ifdef CONFIG_MV_ETH_SWITCH
+struct mv_eth_switch_config {
+	int             mtu;
+	int             netdev_max;
+	int             netdev_cfg;
+	unsigned char   mac_addr[CONFIG_MV_ETH_SWITCH_NETDEV_NUM][MV_MAC_ADDR_SIZE];
+	u16             board_port_map[CONFIG_MV_ETH_SWITCH_NETDEV_NUM];
+};
+
+extern int  mv_eth_switch_netdev_first, mv_eth_switch_netdev_last;
+extern struct mv_eth_switch_config      switch_net_config[CONFIG_MV_ETH_PORTS_NUM];
+extern struct net_device **mv_net_devs;
+
+int     mv_eth_switch_config_get(int use_existing_config, int port);
+int     mv_eth_switch_set_mac_addr(struct net_device *dev, void *mac);
+void    mv_eth_switch_set_multicast_list(struct net_device *dev);
+int     mv_eth_switch_change_mtu(struct net_device *dev, int mtu);
+int     mv_eth_switch_start(struct net_device *dev);
+int     mv_eth_switch_stop(struct net_device *dev);
+void    mv_eth_switch_status_print(int port);
+int     mv_eth_switch_port_add(struct net_device *dev, int port);
+int     mv_eth_switch_port_del(struct net_device *dev, int port);
+
+#endif /* CONFIG_MV_ETH_SWITCH */
+
+/******************************************************
+ * Function prototypes --                             *
+ ******************************************************/
+int         mv_eth_stop(struct net_device *dev);
+int         mv_eth_change_mtu(struct net_device *dev, int mtu);
+int         mv_eth_check_mtu_internals(struct net_device *dev, int mtu);
+int         mv_eth_check_mtu_valid(struct net_device *dev, int mtu);
+
+int         mv_eth_set_mac_addr(struct net_device *dev, void *mac);
+void        mv_eth_set_multicast_list(struct net_device *dev);
+int         mv_eth_open(struct net_device *dev);
+int         mv_eth_port_suspend(int port);
+int         mv_eth_port_resume(int port);
+int         mv_eth_resume_clock(int port);
+int         mv_eth_suspend_clock(int port);
+int         mv_eth_suspend_internals(struct eth_port *pp);
+int         mv_eth_resume_internals(struct eth_port *pp, int mtu);
+int         mv_eth_restore_registers(struct eth_port *pp, int mtu);
+
+void        mv_eth_win_init(int port);
+int         mv_eth_resume_network_interfaces(struct eth_port *pp);
+int         mv_eth_wol_mode_set(int port, int mode);
+
+int	    mv_eth_cpu_txq_mask_set(int port, int cpu, int txqMask);
+
+irqreturn_t mv_eth_isr(int irq, void *dev_id);
+int         mv_eth_start_internals(struct eth_port *pp, int mtu);
+int         mv_eth_stop_internals(struct eth_port *pp);
+int         mv_eth_change_mtu_internals(struct net_device *netdev, int mtu);
+
+int         mv_eth_rx_reset(int port);
+int         mv_eth_txp_reset(int port, int txp);
+
+MV_STATUS   mv_eth_rx_ptks_coal_set(int port, int rxq, MV_U32 value);
+MV_STATUS   mv_eth_rx_time_coal_set(int port, int rxq, MV_U32 value);
+MV_STATUS   mv_eth_tx_done_ptks_coal_set(int port, int txp, int txq, MV_U32 value);
+
+struct eth_port     *mv_eth_port_by_id(unsigned int port);
+struct net_device   *mv_eth_netdev_by_id(unsigned int idx);
+bool                 mv_eth_netdev_find(unsigned int if_index);
+
+void        mv_eth_mac_show(int port);
+void        mv_eth_tos_map_show(int port);
+int         mv_eth_rxq_tos_map_set(int port, int rxq, unsigned char tos);
+int         mv_eth_txq_tos_map_set(int port, int txq, int cpu, unsigned int tos);
+int         mv_eth_napi_set_cpu_affinity(int port, int group, int affinity);
+int         mv_eth_napi_set_rxq_affinity(int port, int group, int rxq);
+void        mv_eth_napi_group_show(int port);
+
+int         mv_eth_rxq_vlan_prio_set(int port, int rxq, unsigned char prio);
+void        mv_eth_vlan_prio_show(int port);
+
+void        mv_eth_netdev_print(struct net_device *netdev);
+void        mv_eth_status_print(void);
+void        mv_eth_port_status_print(unsigned int port);
+void        mv_eth_port_stats_print(unsigned int port);
+
+void        mv_eth_set_noqueue(struct net_device *dev, int enable);
+
+void        mv_eth_ctrl_hwf(int en);
+int         mv_eth_ctrl_recycle(int en);
+void        mv_eth_ctrl_txdone(int num);
+int         mv_eth_ctrl_tx_mh(int port, u16 mh);
+int         mv_eth_ctrl_tx_cmd(int port, u32 cmd);
+int         mv_eth_ctrl_txq_cpu_def(int port, int txp, int txq, int cpu);
+int         mv_eth_ctrl_txq_mode_get(int port, int txp, int txq, int *rx_port);
+int         mv_eth_ctrl_txq_cpu_own(int port, int txp, int txq, int add, int cpu);
+int         mv_eth_ctrl_txq_hwf_own(int port, int txp, int txq, int rxp);
+int         mv_eth_ctrl_flag(int port, u32 flag, u32 val);
+int         mv_eth_ctrl_txq_size_set(int port, int txp, int txq, int value);
+int         mv_eth_ctrl_rxq_size_set(int port, int rxq, int value);
+int         mv_eth_ctrl_port_buf_num_set(int port, int long_num, int short_num);
+int         mv_eth_ctrl_pool_size_set(int pool, int pkt_size);
+int         mv_eth_ctrl_set_poll_rx_weight(int port, u32 weight);
+int         mv_eth_shared_set(int port, int txp, int txq, int value);
+void        mv_eth_tx_desc_print(struct neta_tx_desc *desc);
+void        mv_eth_pkt_print(struct eth_pbuf *pkt);
+void        mv_eth_rx_desc_print(struct neta_rx_desc *desc);
+void        mv_eth_skb_print(struct sk_buff *skb);
+void        mv_eth_link_status_print(int port);
+
+#ifdef CONFIG_MV_PON
+typedef MV_BOOL(*PONLINKSTATUSPOLLFUNC)(void);		  /* prototype for PON link status polling function */
+typedef void   (*PONLINKSTATUSNOTIFYFUNC)(MV_BOOL state); /* prototype for PON link status notification function */
+
+MV_BOOL mv_pon_link_status(void);
+void mv_pon_link_state_register(PONLINKSTATUSPOLLFUNC poll_func, PONLINKSTATUSNOTIFYFUNC *notify_func);
+void mv_pon_ctrl_omci_type(MV_U16 type);
+void mv_pon_ctrl_omci_rx_gh(int en);
+void mv_pon_omci_print(void);
+
+#endif /* CONFIG_MV_PON */
+
+#ifdef CONFIG_MV_ETH_TX_SPECIAL
+void        mv_eth_tx_special_check_func(int port, int (*func)(int port, struct net_device *dev,
+				  struct sk_buff *skb, struct mv_eth_tx_spec *tx_spec_out));
+#endif /* CONFIG_MV_ETH_TX_SPECIAL */
+
+#ifdef CONFIG_MV_ETH_RX_SPECIAL
+void        mv_eth_rx_special_proc_func(int port, void (*func)(int port, int rxq, struct net_device *dev,
+							struct sk_buff *skb, struct neta_rx_desc *rx_desc));
+#endif /* CONFIG_MV_ETH_RX_SPECIAL */
+
+int  mv_eth_poll(struct napi_struct *napi, int budget);
+void mv_eth_link_event(struct eth_port *pp, int print);
+
+int mv_eth_rx_policy(u32 cause);
+int mv_eth_refill(struct eth_port *pp, int rxq,
+				struct eth_pbuf *pkt, struct bm_pool *pool, struct neta_rx_desc *rx_desc);
+u32 mv_eth_txq_done(struct eth_port *pp, struct tx_queue *txq_ctrl);
+u32 mv_eth_tx_done_gbe(struct eth_port *pp, u32 cause_tx_done, int *tx_todo);
+u32 mv_eth_tx_done_pon(struct eth_port *pp, int *tx_todo);
+
+#ifdef CONFIG_MV_ETH_RX_DESC_PREFETCH
+struct neta_rx_desc *mv_eth_rx_prefetch(struct eth_port *pp,
+						MV_NETA_RXQ_CTRL *rx_ctrl, int rx_done, int rx_todo);
+#endif /* CONFIG_MV_ETH_RX_DESC_PREFETCH */
+
+#ifdef CONFIG_MV_ETH_BM
+void	*mv_eth_bm_pool_create(int pool, int capacity, MV_ULONG *physAddr);
+#endif /* CONFIG_MV_ETH_BM */
+
+#if defined(CONFIG_MV_ETH_HWF) && !defined(CONFIG_MV_ETH_BM_CPU)
+MV_STATUS mv_eth_hwf_bm_create(int port, int mtuPktSize);
+void      mv_hwf_bm_dump(void);
+#endif /* CONFIG_MV_ETH_HWF && !CONFIG_MV_ETH_BM_CPU */
+
+
+#ifdef CONFIG_MV_ETH_NFP
+int         mv_eth_nfp_ctrl(struct net_device *dev, int en);
+int         mv_eth_nfp_ext_ctrl(struct net_device *dev, int en);
+int         mv_eth_nfp_ext_add(struct net_device *dev, int port);
+int         mv_eth_nfp_ext_del(struct net_device *dev);
+MV_STATUS   mv_eth_nfp(struct eth_port *pp, int rxq, struct neta_rx_desc *rx_desc,
+					struct eth_pbuf *pkt, struct bm_pool *pool);
+#endif /* CONFIG_MV_ETH_NFP */
+
+#endif /* __mv_netdev_h__ */
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/mv_switch_api.c linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/mv_switch_api.c
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/mv_switch_api.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/mv_switch_api.c	2014-04-11 00:05:34.000000000 +0700
@@ -0,0 +1,1489 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#include "dsdt/gtDrvSwRegs.h"
+#include "dsdt/msApiDefs.h"
+#include "os/mvCommon.h"
+#include "mv_switch.h"
+
+static MV_STATUS pvtOperationPerform
+(
+    IN    GT_QD_DEV           *dev,
+    IN    GT_PVT_OPERATION   pvtOp,
+    INOUT GT_PVT_OP_DATA     *opData
+);
+
+/*******************************************************************************
+* portToSmiMapping
+*
+* DESCRIPTION:
+*       This function mapps port to smi address
+*
+* INPUTS:
+*        dev - device context
+*       portNum - Port number to read the register for.
+*        accessType - type of register (Phy, Port, or Global)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       smiAddr    - smi address.
+*
+*******************************************************************************/
+MV_U8 portToSmiMapping
+(
+    IN GT_QD_DEV *dev,
+    IN MV_U8    portNum,
+    IN MV_U32    accessType
+)
+{
+    MV_U8 smiAddr;
+
+    switch(accessType)
+    {
+        case PHY_ACCESS:
+	      smiAddr = portNum;            
+              break;
+        case PORT_ACCESS:
+              smiAddr = portNum + PORT_REGS_START_ADDR_8PORT;
+              break;
+        case GLOBAL_REG_ACCESS:
+              smiAddr = GLOBAL_REGS_START_ADDR_8PORT;
+              break;
+        case GLOBAL3_REG_ACCESS:
+              smiAddr = GLOBAL_REGS_START_ADDR_8PORT + 2;
+              break;
+        default:
+              smiAddr = GLOBAL_REGS_START_ADDR_8PORT + 1;
+              break;
+    }
+
+    return smiAddr;
+}
+
+/*******************************************************************************
+* gstpSetPortState
+*
+* DESCRIPTION:
+*       This routine set the port state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       state - the port state to set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gstpSetPortState
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT           port,
+    IN GT_PORT_STP_STATE  state
+)
+{
+    MV_U16          data;           /* Data to write to register.   */
+    MV_STATUS       retVal;         /* Functions return value.      */
+    
+    data    = state;
+
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+    /* Set the port state bits.             */
+    retVal = mv_switch_mii_write_RegField( dev, port, QD_REG_PORT_CONTROL, 0, 2, data);
+    
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetEgressMode
+*
+* DESCRIPTION:
+*       This routine set the egress mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the egress mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetEgressMode
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_EGRESS_MODE  mode
+)
+{
+    MV_STATUS       retVal;         /* Functions return value.      */
+    MV_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+
+    DBG_INFO(("gprtSetEgressMode Called.\n"));
+
+    switch (mode)
+    {
+        case (GT_UNMODIFY_EGRESS):
+            data = 0;
+            break;
+
+        case (GT_TAGGED_EGRESS):
+            data = 2;
+            break;
+
+        case (GT_UNTAGGED_EGRESS):
+            data = 1;
+            break;
+
+        case (GT_ADD_TAG):
+            data = 3;
+            break;
+        default:
+            DBG_INFO(("Failed.\n"));
+            return MV_FAIL;
+    }
+
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+    retVal = mv_switch_mii_write_RegField( dev, port, QD_REG_PORT_CONTROL, 12, 2, data);
+    if(retVal != MV_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return MV_OK;
+}
+
+
+/*******************************************************************************
+* gpvtInitialize
+*
+* DESCRIPTION:
+*       This routine initializes the PVT Table to all one's (initial state)
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK      - on success
+*       MV_FAIL    - on error
+*       MV_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS gpvtInitialize
+(
+    IN  GT_QD_DEV     *dev
+)
+{
+    MV_STATUS           retVal;
+    GT_PVT_OPERATION    op;
+
+    DBG_INFO(("gpvtInitialize Called.\n"));
+
+    /* Program Tuning register */
+    op = PVT_INITIALIZE;
+    retVal = pvtOperationPerform(dev,op,NULL);
+    if(retVal != MV_OK)
+    {
+        DBG_INFO(("Failed (pvtOperationPerform returned MV_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return MV_OK;
+
+}
+
+/*******************************************************************************
+* pvtOperationPerform
+*
+* DESCRIPTION:
+*       This function accesses PVT Table
+*
+* INPUTS:
+*       pvtOp   - The pvt operation
+*       pvtData - address and data to be written into PVT
+*
+* OUTPUTS:
+*       pvtData - data read from PVT pointed by address
+*
+* RETURNS:
+*       MV_OK on success,
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static MV_STATUS pvtOperationPerform
+(
+    IN    GT_QD_DEV           *dev,
+    IN    GT_PVT_OPERATION   pvtOp,
+    INOUT GT_PVT_OP_DATA     *opData
+)
+{
+    MV_STATUS       retVal;    /* Functions return value */
+    MV_U16          data;     /* temporary Data storage */
+
+    /* Wait until the pvt in ready. */
+
+    data = 0x8000;  // BIT15
+    while(data & 0x8000)
+    {
+        retVal = mv_switch_mii_read( dev, 0x1c, QD_REG_PVT_ADDR, &data);
+        if(retVal != MV_OK)
+        {
+            return retVal;
+        }
+    }
+
+    /* Set the PVT Operation register */
+    switch (pvtOp)
+    {
+        case PVT_INITIALIZE:
+            data = (1 << 15) | (pvtOp << 12);
+            retVal = mv_switch_mii_write( dev, 0x1c, QD_REG_PVT_ADDR, data);
+            if(retVal != MV_OK)
+            {
+                 return retVal;
+            }
+            break;
+
+        case PVT_WRITE:
+            data = (MV_U16)opData->pvtData;
+            retVal = mv_switch_mii_write( dev, 0x1c, QD_REG_PVT_ADDR, data);
+            
+            if(retVal != MV_OK)
+            {
+                return retVal;
+            }
+
+            data = (MV_U16)((1 << 15) | (pvtOp << 12) | opData->pvtAddr);
+            retVal = mv_switch_mii_write( dev, 0x1c, QD_REG_PVT_ADDR, data);
+
+            if(retVal != MV_OK)
+            {
+                return retVal;
+            }
+            break;
+
+        case PVT_READ:
+            data = (MV_U16)((1 << 15) | (pvtOp << 12) | opData->pvtAddr);
+            retVal = mv_switch_mii_write( dev, 0x1c, QD_REG_PVT_ADDR, data);
+            
+            if(retVal != MV_OK)
+            {
+                return retVal;
+            }
+            
+            data = 0x8000;  // BIT15
+            
+            while(data & 0x8000)
+            {
+                retVal = mv_switch_mii_read( dev, 0x1c, QD_REG_PVT_ADDR, &data);
+                if(retVal != MV_OK)
+                {
+                    return retVal;
+                }
+            }
+
+            retVal = mv_switch_mii_read(dev, 0x1c, QD_REG_PVT_DATA, &data);
+            opData->pvtData = (MV_U32)data;
+            if(retVal != MV_OK)
+            {
+                return retVal;
+            }
+
+            break;
+
+        default:
+
+            return MV_FAIL;
+    }
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetFrameMode
+*
+* DESCRIPTION:
+*        Frmae Mode is used to define the expected Ingress and the generated Egress
+*        tagging frame format for this port as follows:
+*            GT_FRAME_MODE_NORMAL -
+*                Normal Network mode uses industry standard IEEE 802.3ac Tagged or
+*                Untagged frames. Tagged frames use an Ether Type of 0x8100.
+*            GT_FRAME_MODE_DSA -
+*                DSA mode uses a Marvell defined tagged frame format for
+*                Chip-to-Chip and Chip-to-CPU connections.
+*            GT_FRAME_MODE_PROVIDER -
+*                Provider mode uses user definable Ether Types per port
+*                (see gprtSetPortEType/gprtGetPortEType API).
+*            GT_FRAME_MODE_ETHER_TYPE_DSA -
+*                Ether Type DSA mode uses standard Marvell DSA Tagged frame info
+*                flowing a user definable Ether Type. This mode allows the mixture
+*                of Normal Network frames with DSA Tagged frames and is useful to
+*                be used on ports that connect to a CPU.
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_FRAME_MODE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        MV_OK   - on success
+*        MV_FAIL - on error
+*        MV_BAD_PARAM - if mode is unknown
+*        MV_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gprtSetFrameMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_FRAME_MODE    mode
+)
+{
+    DBG_INFO(("gprtSetFrameMode Called.\n"));
+
+    switch (mode)
+    {
+        case GT_FRAME_MODE_NORMAL:
+        case GT_FRAME_MODE_DSA:
+        case GT_FRAME_MODE_PROVIDER:
+        case GT_FRAME_MODE_ETHER_TYPE_DSA:
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return MV_BAD_PARAM;
+    }
+
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+    /* Set Frame Mode.  */
+    return mv_switch_mii_write_RegField(dev, port, QD_REG_PORT_CONTROL, 8, 2, (MV_U16)mode);
+}
+
+
+/*******************************************************************************
+* gcosSetPortDefaultTc
+*
+* DESCRIPTION:
+*       Sets the default traffic class for a specific port.
+*
+* INPUTS:
+*       port      - logical port number
+*       trafClass - default traffic class of a port.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*       Fast Ethernet switch family supports 2 bits (0 ~ 3) while Gigabit Switch
+*        family supports 3 bits (0 ~ 7)
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gcosSetPortDefaultTc
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    IN MV_U8      trafClass
+)
+{
+    DBG_INFO(("gcosSetPortDefaultTc Called.\n"));
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PVID, 13, 3, trafClass);
+}
+
+/*******************************************************************************
+* gqosIpPrioMapEn
+*
+* DESCRIPTION:
+*       This routine enables the IP priority mapping.
+*
+* INPUTS:
+*       port - the logical port number.
+*       en   - MV_TRUE to Enable, MV_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosIpPrioMapEn
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    IN MV_BOOL    en
+)
+{
+    MV_U16          data;           /* Used to poll the SWReset bit */
+
+    DBG_INFO(("gqosIpPrioMapEn Called.\n"));
+    /* translate bool to binary */
+    BOOL_2_BIT(en, data);
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+
+    /* Set the useIp.  */
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PORT_CONTROL, 5, 1, data);
+}
+
+
+/*******************************************************************************
+* gqosSetPrioMapRule
+*
+* DESCRIPTION:
+*       This routine sets priority mapping rule.
+*        If the current frame is both IEEE 802.3ac tagged and an IPv4 or IPv6,
+*        and UserPrioMap (for IEEE 802.3ac) and IPPrioMap (for IP frame) are
+*        enabled, then priority selection is made based on this setup.
+*        If PrioMapRule is set to MV_TRUE, UserPrioMap is used.
+*        If PrioMapRule is reset to MV_FALSE, IPPrioMap is used.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - MV_TRUE for user prio rule, MV_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosSetPrioMapRule
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    IN MV_BOOL    mode
+)
+{
+    MV_U16          data;           /* temporary data buffer */
+
+    DBG_INFO(("gqosSetPrioMapRule Called.\n"));
+    /* translate bool to binary */
+    BOOL_2_BIT(mode, data);
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+    
+    /* Set the TagIfBoth.  */
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PORT_CONTROL, 6, 1, data);
+}
+
+/*******************************************************************************
+* gqosUserPrioMapEn
+*
+* DESCRIPTION:
+*       This routine enables the user priority mapping.
+*
+* INPUTS:
+*       port - the logical port number.
+*       en   - MV_TRUE to Enable, MV_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gqosUserPrioMapEn
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    IN MV_BOOL    en
+)
+{
+    MV_U16          data;           /* Used to poll the SWReset bit */
+
+    DBG_INFO(("gqosUserPrioMapEn Called.\n"));
+    /* translate bool to binary */
+    BOOL_2_BIT(en, data);
+
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+    /* Set the useTag.  */
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PORT_CONTROL, 4, 1, data);
+}
+
+/*******************************************************************************
+* gprtSetHeaderMode
+*
+* DESCRIPTION:
+*       This routine set ingress and egress header mode of a switch port.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - MV_TRUE for header mode  or MV_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetHeaderMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_LPORT     port,
+    IN MV_BOOL      mode
+)
+{
+    MV_U16          data;
+
+    DBG_INFO(("gprtSetHeaderMode Called.\n"));
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+    /* Set the header mode.            */
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PORT_CONTROL, 11, 1, data);
+}
+
+/*******************************************************************************
+* gsysSetJumboMode
+*
+* DESCRIPTION:
+*       This routine Set the max frame size allowed to be received and transmitted
+*        from or to a given port.
+*
+* INPUTS:
+*        port - the logical port number
+*       mode - GT_JUMBO_MODE (1522, 2048, or 10240)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*        MV_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS gsysSetJumboMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_JUMBO_MODE   mode
+)
+{
+    DBG_INFO(("gsysSetJumboMode Called.\n"));
+
+    if (mode > GT_JUMBO_MODE_10240)
+    {
+        DBG_INFO(("Bad Parameter\n"));
+        return MV_BAD_PARAM;
+    }
+
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+    /* Set the Jumbo Fram Size bit.               */
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PORT_CONTROL2, 12, 2,(MV_U16)mode);
+}
+
+/*******************************************************************************
+* gprtSetVlanTunnel
+*
+* DESCRIPTION:
+*       This routine sets the vlan tunnel mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the vlan tunnel mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtSetVlanTunnel
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN MV_BOOL   mode
+)
+{
+    MV_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+
+    DBG_INFO(("gprtSetVlanTunnel Called.\n"));
+
+    BOOL_2_BIT(mode,data);
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PORT_CONTROL, 7, 1, data);
+}
+
+/*******************************************************************************
+* gvlnSetPortVlanPortMask
+*
+* DESCRIPTION:
+*       This routine sets the port VLAN group port membership list.
+*
+* INPUTS:
+*       port        - logical port number to set.
+*       portMask    - bitmap for port[0..6]
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_FAIL             - on error
+*       MV_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvlnSetPortVlanPortMask
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN MV_U16    portMask
+)
+{
+    DBG_INFO(("gvlnSetPortVlanPortMask Called.\n"));
+
+    if(portMask & 0x80)
+    {
+        DBG_INFO(("Failed (PortMask incorrect).\n"));
+        return MV_BAD_PARAM;
+    }
+    
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+    /* numOfPorts = 3 for fullsail, = 10 for octane, = 7 for others */
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PORT_VLAN_MAP, 0, MAX_SWITCH_PORT_NUM, portMask);
+}
+
+/********************************************************************
+* gvlnSetPortVlanDot1qMode
+*
+* DESCRIPTION:
+*       This routine sets the IEEE 802.1q mode for this port (11:10)
+*
+* INPUTS:
+*       port    - logical port number to set.
+*       mode     - 802.1q mode for this port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:IN GT_INGRESS_MODE mode
+*       MV_OK               - on success
+*       MV_FAIL             - on error
+*       MV_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gvlnSetPortVlanDot1qMode
+(
+    IN GT_QD_DEV        *dev,
+    IN GT_LPORT     	port,
+    IN GT_DOT1Q_MODE    mode
+)
+{
+    DBG_INFO(("gvlnSetPortVlanDot1qMode Called.\n"));
+
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PORT_CONTROL2,10,2,(MV_U16)mode );
+}
+
+/*******************************************************************************
+* gpcsSetForceSpeed
+*
+* DESCRIPTION:
+*		This routine forces Speed.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or no force speed)
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		MV_OK   - on success
+*		MV_FAIL - on error
+*		MV_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetForceSpeed
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_PORT_FORCED_SPEED_MODE  mode
+)
+{
+    DBG_INFO(("gpcsSetForceSpeed Called.\n"));
+
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+
+    /* Set the Force Speed bits.  */
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PCS_CONTROL,0,2, (MV_U16)mode);
+}
+
+/*******************************************************************************
+* gpcsSetDpxValue
+*
+* DESCRIPTION:
+*		This routine sets Duplex's Forced value. This function needs to be
+*		called prior to gpcsSetForcedDpx.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - MV_TRUE to force full duplex, MV_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		MV_OK   - on success
+*		MV_FAIL - on error
+*		MV_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetDpxValue
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN MV_BOOL	state
+)
+{
+    MV_U16          data;           /* Used to poll the SWReset bit */
+
+    DBG_INFO(("gpcsSetDpxValue Called.\n"));
+
+    BOOL_2_BIT(state, data);
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+
+    /* Get the DpxValue bit.  */
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PCS_CONTROL,3,1,data);
+}
+
+/*******************************************************************************
+* gpcsSetForcedDpx
+*
+* DESCRIPTION:
+*		This routine forces duplex mode. If DpxValue is set to one, calling this
+*		routine with MV_TRUE will force duplex mode to be full duplex.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - MV_TRUE to force duplex mode, MV_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		MV_OK   - on success
+*		MV_FAIL - on error
+*		MV_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetForcedDpx
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN MV_BOOL	state
+)
+{
+    MV_U16          data;           /* Used to poll the SWReset bit */
+
+    DBG_INFO(("gpcsSetForcedDpx Called.\n"));
+
+    BOOL_2_BIT(state, data);
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+
+    /* Get the ForcedDpx bit.  */
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PCS_CONTROL,2,1,data);
+}
+
+/*******************************************************************************
+* gpcsSetFCValue
+*
+* DESCRIPTION:
+*		This routine sets Flow Control's force value
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - MV_TRUE to force flow control enabled, MV_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		MV_OK   - on success
+*		MV_FAIL - on error
+*		MV_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetFCValue
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN MV_BOOL	state
+)
+{
+    MV_U16          data;           /* Used to poll the SWReset bit */
+
+    DBG_INFO(("gpcsSetFCValue Called.\n"));
+
+    BOOL_2_BIT(state, data);
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+
+    /* Set the FCValue bit.  */
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PCS_CONTROL,7,1,data);
+}
+
+/*******************************************************************************
+* gpcsSetForcedFC
+*
+* DESCRIPTION:
+*		This routine forces Flow Control. If FCValue is set to one, calling this
+*		routine with MV_TRUE will force Flow Control to be enabled.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - MV_TRUE to force flow control (enable or disable), MV_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		MV_OK   - on success
+*		MV_FAIL - on error
+*		MV_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetForcedFC
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN MV_BOOL	state
+)
+{
+    MV_U16          data;           /* Used to poll the SWReset bit */
+
+    DBG_INFO(("gpcsSetForcedFC Called.\n"));
+
+    BOOL_2_BIT(state, data);
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+
+    /* Get the ForcedFC bit.  */
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PCS_CONTROL,6,1,data);
+}
+
+/*******************************************************************************
+* gpcsSetLinkValue
+*
+* DESCRIPTION:
+*		This routine sets Link's force value
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - MV_TRUE to force link up, MV_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		MV_OK   - on success
+*		MV_FAIL - on error
+*		MV_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetLinkValue
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN MV_BOOL	state
+)
+{
+    MV_U16          data;           /* Used to poll the SWReset bit */
+
+    DBG_INFO(("gpcsSetLinkValue Called.\n"));
+
+    BOOL_2_BIT(state, data);
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+
+    /* Get the LinkValue bit.  */
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PCS_CONTROL,5,1,data);
+}
+
+/*******************************************************************************
+* gpcsSetForcedLink
+*
+* DESCRIPTION:
+*		This routine forces Link. If LinkValue is set to one, calling this
+*		routine with MV_TRUE will force Link to be up.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - MV_TRUE to force link (up or down), MV_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		MV_OK   - on success
+*		MV_FAIL - on error
+*		MV_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gpcsSetForcedLink
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN MV_BOOL	state
+)
+{
+    MV_U16          data;           /* Used to poll the SWReset bit */
+
+    DBG_INFO(("gpcsSetForcedLink Called.\n"));
+
+    BOOL_2_BIT(state, data);
+
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+
+    /* Get the ForcedLink bit.  */
+    return mv_switch_mii_write_RegField( dev, port, QD_REG_PCS_CONTROL,4,1,data);
+}
+
+/*******************************************************************************
+* atuOperationPerform
+*
+* DESCRIPTION:
+*       This function is used by all ATU control functions, and is responsible
+*       to write the required operation into the ATU registers.
+*
+* INPUTS:
+*       atuOp       - The ATU operation bits to be written into the ATU
+*                     operation register.
+*       DBNum       - ATU Database Number for CPU accesses
+*       entryPri    - The EntryPri field in the ATU Data register.
+*       portVec     - The portVec field in the ATU Data register.
+*       entryState  - The EntryState field in the ATU Data register.
+*       atuMac      - The Mac address to be written to the ATU Mac registers.
+*
+* OUTPUTS:
+*       entryPri    - The EntryPri field in case the atuOp is GetNext.
+*       portVec     - The portVec field in case the atuOp is GetNext.
+*       entryState  - The EntryState field in case the atuOp is GetNext.
+*       atuMac      - The returned Mac address in case the atuOp is GetNext.
+*
+* RETURNS:
+*       MV_OK on success,
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  if atuMac == NULL, nothing needs to be written to ATU Mac registers.
+*
+*******************************************************************************/
+static MV_STATUS atuOperationPerform
+(
+    IN      GT_QD_DEV           *dev,
+    IN      GT_ATU_OPERATION    atuOp,
+    INOUT   GT_EXTRA_OP_DATA    *opData,
+    INOUT   GT_ATU_ENTRY        *entry
+)
+{
+    MV_STATUS       retVal;         /* Functions return value.      */
+    MV_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    MV_U16          opcodeData;           /* Data to be set into the      */
+                                    /* register.                    */
+    MV_U8           i;
+    MV_U16          portMask;
+
+    portMask = (1 << dev->maxPorts) - 1;
+
+    data = 0x8000;
+    while(data == 0x8000)
+    {
+        retVal = mv_switch_mii_read( dev, 0x1b, QD_REG_ATU_OPERATION, &data);
+        if(retVal != MV_OK)
+        {
+            return retVal;
+        }
+    }
+
+    opcodeData = 0;
+
+    switch (atuOp)
+    {
+        case LOAD_PURGE_ENTRY:
+                data = (MV_U16)( (((entry->prio) & 0x3) << 14) |
+                       (((entry->portVec) & portMask) << 4) |
+                       (((entry->entryState.ucEntryState) & 0xF)) );
+                retVal = mv_switch_mii_write( dev, 0x1b, QD_REG_ATU_DATA_REG, data);
+                if(retVal != MV_OK)
+                {
+                    return retVal;
+                }
+                /* pass thru */
+
+        case GET_NEXT_ENTRY:
+                for(i = 0; i < 3; i++)
+                {
+                    data=(entry->macAddr[2*i] << 8)|(entry->macAddr[1 + 2*i]);
+                    retVal = mv_switch_mii_write( dev, 0x1b, (MV_U8)(QD_REG_ATU_MAC_BASE+i), data);
+                    if(retVal != MV_OK)
+                    {
+                        return retVal;
+                    }
+                }
+                break;
+
+        case FLUSH_ALL:
+        case FLUSH_UNLOCKED:
+        case FLUSH_ALL_IN_DB:
+        case FLUSH_UNLOCKED_IN_DB:
+                if (entry->entryState.ucEntryState == 0xF)
+                {
+                    data = (MV_U16)(0xF | ((opData->moveFrom & 0xF) << 4) | ((opData->moveTo & 0xF) << 8));
+                }
+                else
+                {
+                    data = 0;
+                }
+                retVal = mv_switch_mii_write( dev, 0x1b, QD_REG_ATU_DATA_REG, data);
+                   if(retVal != MV_OK)
+                {
+                    return retVal;
+                }
+                break;
+
+        case SERVICE_VIOLATIONS:
+
+                break;
+
+        default :
+                return MV_FAIL;
+    }
+
+    /* Set DBNum */
+    retVal = mv_switch_mii_write_RegField( dev, 0x1b, QD_REG_ATU_FID_REG,0,12,(MV_U16)(entry->DBNum & 0xFFF));
+    if(retVal != MV_OK)
+    {
+        return retVal;
+    }
+
+    /* Set the ATU Operation register in addtion to DBNum setup  */
+
+    opcodeData |= ((1 << 15) | (atuOp << 12));
+
+    retVal = mv_switch_mii_write( dev, 0x1b, QD_REG_ATU_OPERATION, opcodeData);
+    if(retVal != MV_OK)
+    {
+        return retVal;
+    }
+
+    /* If the operation is to service violation operation wait for the response   */
+    if(atuOp == SERVICE_VIOLATIONS)
+    {
+        /* Wait until the VTU in ready. */
+        data = 0x8000;
+        while(data == 0x8000)
+        {
+            retVal = mv_switch_mii_read( dev, 0x1b, QD_REG_ATU_OPERATION, &data);
+            if(retVal != MV_OK)
+            {
+                return retVal;
+            }
+        }
+
+        /* get the Interrupt Cause */
+        retVal = mv_switch_mii_read( dev, 0x1b, QD_REG_ATU_OPERATION, &data);
+        if(retVal != MV_OK)
+        {
+            return retVal;
+        }
+        
+        data = (data >> 4) & 0x0F;
+
+        switch (data)
+        {
+            case 8:    /* Age Interrupt */
+                opData->intCause = GT_AGE_VIOLATION;
+                break;
+            case 4:    /* Member Violation */
+                opData->intCause = GT_MEMBER_VIOLATION;
+                break;
+            case 2:    /* Miss Violation */
+                opData->intCause = GT_MISS_VIOLATION;
+                break;
+            case 1:    /* Full Violation */
+                opData->intCause = GT_FULL_VIOLATION;
+                break;
+            default:
+                opData->intCause = 0;
+                return MV_OK;
+        }
+
+        /* get the DBNum that was involved in the violation */
+        entry->DBNum = 0;
+
+        retVal = mv_switch_mii_read( dev, 0x1b, QD_REG_ATU_FID_REG, &data);
+        if(retVal != MV_OK)
+        {
+            return retVal;
+        }
+        
+        data &= 0xFFF;
+        entry->DBNum = (MV_U16)data;
+
+        /* get the Source Port ID that was involved in the violation */
+
+        retVal = mv_switch_mii_read( dev, 0x1b, QD_REG_ATU_DATA_REG, &data);
+        if(retVal != MV_OK)
+        {
+            return retVal;
+        }
+
+        entry->entryState.ucEntryState = data & 0xF;
+
+        /* Get the Mac address  */
+        for(i = 0; i < 3; i++)
+        {
+            retVal = mv_switch_mii_read( dev, 0x1b, (MV_U8)(QD_REG_ATU_MAC_BASE+i), &data);
+            if(retVal != MV_OK)
+            {
+                return retVal;
+            }
+            entry->macAddr[2*i] = data >> 8;
+            entry->macAddr[1 + 2*i] = data & 0xFF;
+        }
+
+    } /* end of service violations */
+    /* If the operation is a gen next operation wait for the response   */
+    if(atuOp == GET_NEXT_ENTRY)
+    {
+        entry->trunkMember = MV_FALSE;
+        entry->exPrio.useMacFPri = MV_FALSE;
+        entry->exPrio.macFPri = 0;
+        entry->exPrio.macQPri = 0;
+
+        /* Wait until the ATU in ready. */
+        data = 0x8000;
+        while(data == 0x8000)
+        {
+            retVal = mv_switch_mii_read( dev, 0x1b, QD_REG_ATU_OPERATION, &data);
+            if(retVal != MV_OK)
+            {
+                return retVal;
+            }
+        }
+
+        /* Get the Mac address  */
+        for(i = 0; i < 3; i++)
+        {
+            retVal = mv_switch_mii_read( dev, 0x1b, (MV_U8)(QD_REG_ATU_MAC_BASE+i), &data);
+            if(retVal != MV_OK)
+            {
+                return retVal;
+            }
+            entry->macAddr[2*i] = data >> 8;
+            entry->macAddr[1 + 2*i] = data & 0xFF;
+        }
+
+        retVal = mv_switch_mii_read( dev, 0x1b, QD_REG_ATU_DATA_REG,&data);
+        if(retVal != MV_OK)
+        {
+            return retVal;
+        }
+        /* Get the Atu data register fields */
+        entry->prio = data >> 14;
+        entry->portVec = (data >> 4) & portMask;
+        entry->entryState.ucEntryState = data & 0xF;
+    }
+
+    return MV_OK;
+}
+
+/*******************************************************************************
+* gfdbFlush
+*
+* DESCRIPTION:
+*       This routine flush all or unblocked addresses from the MAC Address
+*       Table.
+*
+* INPUTS:
+*       flushCmd - the flush operation type.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       MV_OK           - on success
+*       MV_FAIL         - on error
+*       MV_NO_RESOURCE  - failed to allocate a t2c struct
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gfdbFlush
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_FLUSH_CMD flushCmd
+)
+{
+    MV_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+
+    DBG_INFO(("gfdbFlush Called.\n"));
+
+    entry.DBNum = 0;
+    entry.entryState.ucEntryState = 0;
+
+    if(flushCmd == GT_FLUSH_ALL)
+        retVal = atuOperationPerform(dev,FLUSH_ALL,NULL,&entry);
+    else
+        retVal = atuOperationPerform(dev,FLUSH_UNLOCKED,NULL,&entry);
+
+    if(retVal != MV_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    
+    return retVal;
+}
+
+MV_STATUS gprtPortPowerGet( IN GT_QD_DEV  *dev, IN GT_LPORT port)
+{
+    MV_U16          data;
+
+    mv_switch_mii_read( dev, port, QD_PHY_CONTROL_REG, &data);
+     
+    data = (data >> 11) & 1;   
+    return !data;
+}
+
+/*******************************************************************************
+* gprtPortPowerSet
+*
+* DESCRIPTION:
+*       This routine resets port disables/enables port power
+*
+* INPUTS:
+*       port  - the logical port number.
+*       onoff - 0 port power down, otherwise port power up
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtPortPowerSet(IN GT_QD_DEV  *dev,
+			   IN GT_LPORT   port,
+			   IN MV_BOOL    onoff)
+{
+	MV_U16          data;
+        
+        port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+
+	if (onoff != MV_TRUE) {
+
+		/* Page 2, register 16, bit 3. GMII intefrace power down */
+		mv_switch_mii_write_PhyPaged_RegField( dev, port, 2, QD_PHY_SPEC_CONTROL_REG, 3, 1, G65G_ANY_PAGE, 0);
+		
+		/* Page 0, register 16, bits 3,2. Copper Transmitter disable, Power down */
+		mv_switch_mii_write_PhyPaged_RegField(dev, port, 0, QD_PHY_SPEC_CONTROL_REG, 2, 2, G65G_ANY_PAGE, 3);
+		
+		/* Register 0, bit 11, Power Down */
+		mv_switch_mii_write_RegField(dev, port, QD_PHY_CONTROL_REG, 11, 1, 1);
+	} else {
+		/* Page 2, register 16, bit 3 GMII intefrace power down */
+		mv_switch_mii_write_PhyPaged_RegField(dev, port, 2, QD_PHY_SPEC_CONTROL_REG, 3, 1, G65G_ANY_PAGE, 1);
+		
+		/* Page 0, register 16, bits 3,2. Copper Transmitter disable, Power down */
+		mv_switch_mii_write_PhyPaged_RegField(dev, port, 0, QD_PHY_SPEC_CONTROL_REG, 2, 2, G65G_ANY_PAGE, 0);
+		
+		/* Register 0, bit 11, Power Down */
+		mv_switch_mii_write_RegField(dev, port, QD_PHY_CONTROL_REG, 11, 1, 0);
+	}
+	return 0;
+}
+
+/*******************************************************************************
+* gprtGetLinkState
+*
+* DESCRIPTION:
+*       This routine retrives the link state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - MV_TRUE for Up  or MV_FALSE otherwise
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+MV_STATUS gprtGetLinkState
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT MV_BOOL   *state
+)
+{
+    MV_U8	    reg;
+    MV_U16          data;           /* Used to poll the SWReset bit */
+    MV_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gprtGetLinkState Called.\n"));
+
+    port = CALC_SMI_DEV_ADDR(dev, port, PORT_ACCESS);
+
+    /* Get the force flow control bit.  */
+    retVal = mv_switch_mii_read( dev, port, QD_REG_PORT_STATUS, &data);
+
+    data = (data >> 11) & 1;
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    /* return */
+    return retVal;
+}
\ No newline at end of file
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/mv_switch.c linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/mv_switch.c
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/mv_switch.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/mv_switch.c	2014-04-14 16:22:32.000000000 +0700
@@ -0,0 +1,615 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#include <linux/etherdevice.h>
+#include <linux/interrupt.h>
+
+#include "os/mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "eth-phy/mvEthPhyRegs.h"
+#include "dsdt/gtDrvSwRegs.h"
+
+#include <asm/../../mach-mvebu/armada-370-xp.h>
+
+#include "gbe/mvEthRegs.h"
+
+#include "dsdt/msApiDefs.h"
+#include "dsdt/msApiPrototype.h"
+#include "mv_switch.h"
+
+/* uncomment for debug prints */
+/* #define SWITCH_DEBUG */
+
+#define SWITCH_DBG_OFF      0x0000
+#define SWITCH_DBG_LOAD     0x0001
+#define SWITCH_DBG_MCAST    0x0002
+#define SWITCH_DBG_VLAN     0x0004
+#define SWITCH_DBG_ALL      0xffff
+
+#ifdef SWITCH_DEBUG
+static MV_U32 switch_dbg = 0;
+#define SWITCH_DBG(FLG, X) if ((switch_dbg & (FLG)) == (FLG)) printk X
+#else
+#define SWITCH_DBG(FLG, X)
+#endif /* SWITCH_DEBUG */
+
+GT_QD_DEV qddev;
+
+static spinlock_t switch_lock;
+
+/*******************************************************************************
+* mvEthPhyRegRead - Read from ethernet phy register.
+*
+* DESCRIPTION:
+*       This function reads ethernet phy register.
+*
+* INPUT:
+*       phyAddr - Phy address.
+*       regOffs - Phy register offset.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       16bit phy register value, or 0xffff on error
+*
+*******************************************************************************/
+MV_STATUS mvEthPhyRegRead(MV_U32 phyAddr, MV_U32 regOffs, MV_U16 *data)
+{
+	MV_U32 		smiReg;
+	volatile MV_U32 timeout;
+
+	/* check parameters */
+	if ((phyAddr << ETH_PHY_SMI_DEV_ADDR_OFFS) & ~ETH_PHY_SMI_DEV_ADDR_MASK) {
+		mvOsPrintf("mvEthPhyRegRead: Err. Illegal PHY device address %d\n",
+				phyAddr);
+		return MV_FAIL;
+	}
+	if ((regOffs <<  ETH_PHY_SMI_REG_ADDR_OFFS) & ~ETH_PHY_SMI_REG_ADDR_MASK) {
+		mvOsPrintf("mvEthPhyRegRead: Err. Illegal PHY register offset %d\n",
+				regOffs);
+		return MV_FAIL;
+	}
+
+	timeout = ETH_PHY_TIMEOUT;
+	/* wait till the SMI is not busy*/
+	do {
+		/* read smi register */
+		smiReg = MV_REG_READ( ETH_SMI_REG(MV_ETH_SMI_PORT));
+		if (timeout-- == 0) {
+			mvOsPrintf("mvEthPhyRegRead: SMI busy timeout\n");
+			return MV_FAIL;
+		}
+	} while (smiReg & ETH_PHY_SMI_BUSY_MASK);
+
+	/* fill the phy address and regiser offset and read opcode */
+	smiReg = (phyAddr <<  ETH_PHY_SMI_DEV_ADDR_OFFS) | (regOffs << ETH_PHY_SMI_REG_ADDR_OFFS)|
+			   ETH_PHY_SMI_OPCODE_READ;
+
+	/* write the smi register */
+	MV_REG_WRITE( ETH_SMI_REG(MV_ETH_SMI_PORT), smiReg);
+
+	timeout = 0xffffffff; //ETH_PHY_TIMEOUT;
+
+	/*wait till readed value is ready */
+	do {
+		/* read smi register */
+		smiReg = MV_REG_READ( ETH_SMI_REG(MV_ETH_SMI_PORT));
+
+		if (timeout-- == 0) {
+			mvOsPrintf("mvEthPhyRegRead: SMI read-valid timeout\n");
+			return MV_FAIL;
+		}
+	} while (!(smiReg & ETH_PHY_SMI_READ_VALID_MASK));
+
+	/* Wait for the data to update in the SMI register */
+	for (timeout = 0; timeout < ETH_PHY_TIMEOUT; timeout++)
+		;
+
+        *data = (MV_U16)(MV_REG_READ( ETH_SMI_REG(MV_ETH_SMI_PORT)) & ETH_PHY_SMI_DATA_MASK); 
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvEthPhyRegWrite - Write to ethernet phy register.
+*
+* DESCRIPTION:
+*       This function write to ethernet phy register.
+*
+* INPUT:
+*       phyAddr - Phy address.
+*       regOffs - Phy register offset.
+*       data    - 16bit data.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK if write succeed, MV_BAD_PARAM on bad parameters , MV_ERROR on error .
+*		MV_TIMEOUT on timeout
+*
+*******************************************************************************/
+MV_STATUS mvEthPhyRegWrite(MV_U32 phyAddr, MV_U32 regOffs, MV_U16 data)
+{
+	MV_U32 		smiReg;
+	volatile MV_U32 timeout;
+
+	/* check parameters */
+	if ((phyAddr <<  ETH_PHY_SMI_DEV_ADDR_OFFS) & ~ETH_PHY_SMI_DEV_ADDR_MASK) {
+		mvOsPrintf("mvEthPhyRegWrite: Err. Illegal phy address 0x%x\n", phyAddr);
+		return MV_BAD_PARAM;
+	}
+	if ((regOffs <<  ETH_PHY_SMI_REG_ADDR_OFFS) & ~ETH_PHY_SMI_REG_ADDR_MASK) {
+		mvOsPrintf("mvEthPhyRegWrite: Err. Illegal register offset 0x%x\n", regOffs);
+		return MV_BAD_PARAM;
+	}
+
+	timeout = ETH_PHY_TIMEOUT;
+
+	/* wait till the SMI is not busy*/
+	do {
+		/* read smi register */
+		smiReg = MV_REG_READ( ETH_SMI_REG(MV_ETH_SMI_PORT));
+		if (timeout-- == 0) {
+			mvOsPrintf("mvEthPhyRegWrite: SMI busy timeout\n");
+		return MV_TIMEOUT;
+		}
+	} while (smiReg & ETH_PHY_SMI_BUSY_MASK);
+
+	/* fill the phy address and regiser offset and write opcode and data*/
+	smiReg = (data << ETH_PHY_SMI_DATA_OFFS);
+	smiReg |= (phyAddr <<  ETH_PHY_SMI_DEV_ADDR_OFFS) | (regOffs << ETH_PHY_SMI_REG_ADDR_OFFS);
+	smiReg &= ~ETH_PHY_SMI_OPCODE_READ;
+
+	/* write the smi register */
+	MV_REG_WRITE( ETH_SMI_REG(MV_ETH_SMI_PORT), smiReg);
+
+	return MV_OK;
+}
+
+MV_STATUS mv_switch_mii_read(GT_QD_DEV *dev, unsigned int phy, unsigned int reg, unsigned int *data)
+{
+	unsigned long	flags;
+	MV_U16 		tmp;
+	MV_STATUS 	status;
+
+	spin_lock_irqsave(&switch_lock, flags);
+	status = mvEthPhyRegRead(phy, reg, &tmp);
+	spin_unlock_irqrestore(&switch_lock, flags);
+	*data = tmp;
+
+	return status;
+}
+
+MV_STATUS mv_switch_mii_write(GT_QD_DEV *dev, unsigned int phy, unsigned int reg, unsigned int data)
+{
+	unsigned long	flags;
+	MV_U16	 	tmp;
+	MV_STATUS 	status;
+
+	spin_lock_irqsave(&switch_lock, flags);
+	tmp = (unsigned short)data;
+	status = mvEthPhyRegWrite(phy, reg, tmp);
+	spin_unlock_irqrestore(&switch_lock, flags);
+
+	return status;
+}
+
+/* This macro calculates the mask for partial read /    */
+/* write of register's data.                            */
+#define CALC_MASK(fieldOffset,fieldLen,mask)        \
+            if((fieldLen + fieldOffset) >= 16)      \
+                mask = (0 - (1 << fieldOffset));    \
+            else                                    \
+                mask = (((1 << (fieldLen + fieldOffset))) - (1 << fieldOffset))
+
+MV_STATUS mv_switch_mii_write_RegField( 
+   GT_QD_DEV *dev, unsigned int phy, unsigned int reg, 
+   unsigned char fieldOffset, unsigned char fieldLength, unsigned int data)
+{
+	unsigned long	flags;
+	MV_U16 		tmp;
+	MV_U16  	mask;
+	MV_STATUS 	status;
+
+	spin_lock_irqsave(&switch_lock, flags);
+	
+	status = mvEthPhyRegRead(phy, reg, &tmp);
+	
+	CALC_MASK(fieldOffset,fieldLength,mask);
+
+        /* Set the desired bits to 0.                       */
+        tmp &= ~mask;
+        /* Set the given data into the above reset bits.    */
+        tmp |= ((data << fieldOffset) & mask);
+        
+	status |= mvEthPhyRegWrite(phy, reg, tmp);
+	spin_unlock_irqrestore(&switch_lock, flags);
+
+	return status;
+}
+
+#define GT_GET_PAGE_ADDR(_regAddr) ((_regAddr<29)?22:29)
+
+MV_STATUS mv_switch_mii_write_PhyPaged_RegField
+(
+    IN GT_QD_DEV *dev,
+    IN  MV_U8    portNum,
+    IN  MV_U8    pageNum,
+    IN  MV_U8    regAddr,
+    IN  MV_U8    fieldOffset,
+    IN  MV_U8    fieldLength,
+    IN  MV_U32   anyPage,
+    IN  MV_U16   data
+)
+{
+    unsigned long	flags;
+    MV_U8       	phyAddr, pageAddr;
+    MV_STATUS   	retVal;
+    MV_U16      	tmpData, orgPage, mask;
+
+    phyAddr = portNum;
+    
+    spin_lock_irqsave(&switch_lock, flags);
+    
+    if (!(anyPage & (1 << regAddr)))
+    {
+        pageAddr = GT_GET_PAGE_ADDR(regAddr);
+
+        retVal = mvEthPhyRegRead(phyAddr,pageAddr,&orgPage);
+
+        if(pageAddr == 22)
+            tmpData = orgPage & 0xFF00;
+        else
+            tmpData = orgPage & 0xFFC0;
+        tmpData |= pageNum;
+
+        retVal = mvEthPhyRegWrite(phyAddr,pageAddr,tmpData);
+    
+    }
+ 
+    retVal |= mvEthPhyRegRead(phyAddr, regAddr, &tmpData);
+	
+    CALC_MASK( fieldOffset, fieldLength, mask);
+
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= ((tmpData << fieldOffset) & mask);   
+    retVal |= mvEthPhyRegWrite( phyAddr,regAddr,data);
+
+    if (!(anyPage & (1 << regAddr)))
+    {
+        pageAddr = GT_GET_PAGE_ADDR(regAddr);
+        retVal = mvEthPhyRegWrite(phyAddr,pageAddr,orgPage);  
+    }
+        
+    spin_unlock_irqrestore(&switch_lock, flags);
+
+    return retVal;
+}
+
+
+int mv_switch_reg_write( int port, int reg, int type, unsigned int value)
+{
+	MV_STATUS status = MV_FAIL;
+	GT_QD_DEV *dev = &qddev;
+
+	switch (type) {
+	case MV_SWITCH_PHY_ACCESS:
+		status = mv_switch_mii_write(dev, port, reg, value);
+		break;
+
+	case MV_SWITCH_PORT_ACCESS:
+		status = mv_switch_mii_write(dev, 0x10+port, reg, value);
+		break;
+
+	case MV_SWITCH_GLOBAL_ACCESS:
+		status = mv_switch_mii_write(dev, 0x1b, reg, value);
+		break;
+
+	case MV_SWITCH_GLOBAL2_ACCESS:
+		status = mv_switch_mii_write(dev, 0x1c, reg, value);
+		break;
+
+	case MV_SWITCH_SMI_ACCESS:
+		/* port means phyAddr */
+		MV_REG_WRITE( ETH_SMI_REG(MV_ETH_SMI_PORT), value);
+		status = MV_OK;
+		break;
+
+	default:
+		printk(KERN_ERR "%s Failed: Unexpected access type %d\n", __func__, type);
+		return 1;
+	}
+	if (status != MV_OK) {
+		printk(KERN_ERR "%s Failed: status = %d\n", __func__, status);
+		return 2;
+	}
+	return status;
+}
+
+int mv_switch_reg_read( int port, int reg, int type, unsigned int *value)
+{
+	MV_STATUS status = MV_FAIL;
+	GT_QD_DEV *dev = &qddev;
+
+	switch (type) {
+	case MV_SWITCH_PHY_ACCESS:
+		status = mv_switch_mii_read(dev, port, reg, value);
+		break;
+
+	case MV_SWITCH_PORT_ACCESS:
+		status = mv_switch_mii_read(dev, 0x10+port, reg, value);
+		break;
+
+	case MV_SWITCH_GLOBAL_ACCESS:
+		status = mv_switch_mii_read(dev, 0x1b, reg, value);
+		break;
+
+	case MV_SWITCH_GLOBAL2_ACCESS:
+		status = mv_switch_mii_read(dev, 0x1c, reg, value);
+		break;
+
+	case MV_SWITCH_SMI_ACCESS:
+		/* port means phyAddr */
+		*value = MV_REG_READ( ETH_SMI_REG(MV_ETH_SMI_PORT)); 
+		status = MV_OK;
+		break;
+
+	default:
+		printk(KERN_ERR "%s Failed: Unexpected access type %d\n", __func__, type);
+		return 1;
+	}
+	if (status != MV_OK) {
+		printk(KERN_ERR "%s Failed: status = %d\n", __func__, status);
+		return 2;
+	}
+	return 0;
+}
+
+int mv_switch_jumbo_mode_set( GT_QD_DEV *qd_dev, int max_size)
+{
+	int i;
+	GT_JUMBO_MODE jumbo_mode;
+
+	/* Set jumbo frames mode */
+	if (max_size <= 1522)
+		jumbo_mode = GT_JUMBO_MODE_1522;
+	else if (max_size <= 2048)
+		jumbo_mode = GT_JUMBO_MODE_2048;
+	else
+		jumbo_mode = GT_JUMBO_MODE_10240;
+
+	for (i = 0; i < MAX_SWITCH_PORT_NUM; i++) {
+		if (gsysSetJumboMode(qd_dev, i, jumbo_mode) != MV_OK) {
+			printk(KERN_ERR "gsysSetJumboMode %d failed\n", jumbo_mode);
+			return -1;
+		}
+	}
+	return 0;
+}
+
+
+static MV_STATUS qd_dev_init(GT_QD_DEV *qd_dev)
+{
+	spin_lock_init(&switch_lock);
+
+        /* Initialize dev fields.         */
+        qd_dev->cpuPortNum = SWITCH_TO_CPU_LAN;
+        qd_dev->maxPhyNum = 5;
+        qd_dev->devGroup = 0;
+        qd_dev->devStorage = 0;
+        /* Assign Device Name */
+        qd_dev->devName1 = 0;
+       
+        qd_dev->numOfPorts = 7;
+        qd_dev->maxPorts = 7;
+        qd_dev->maxPhyNum = 7;
+        qd_dev->validPortVec = (1 << qd_dev->numOfPorts) - 1;
+        qd_dev->validPhyVec = 0x7F;
+        qd_dev->devName = DEV_88E6171;
+
+    	qd_dev->use_mad = MV_FALSE;
+        qd_dev->devEnabled = 1;
+        qd_dev->deviceId = GT_88E6172;
+        // QD_DEV init completely 
+
+	return MV_OK;
+}
+
+int mv_switch_init(int mtu, unsigned int switch_ports_mask)
+{
+	MV_U16 		p;
+	MV_U8 		tmp;
+        GT_QD_DEV       *qd_dev = &qddev;
+
+	/* general Switch initialization - relevant for all Switch devices */
+        qd_dev_init( qd_dev);
+
+	/* disable all ports */
+	for (p = 0; p < MAX_SWITCH_PORT_NUM; p++) {
+		if (MV_BIT_CHECK(switch_ports_mask, p))
+			if (gstpSetPortState(qd_dev, p, GT_PORT_DISABLE) != MV_OK) {
+				printk(KERN_ERR "gstpSetPortState failed\n");
+	
+				return -1;
+			}
+	}
+
+	/* disable all disconnected ports (for CPU RGMII0/RGMII1) */
+	for (p = 5; p <= 6; p++) {
+		if (gpcsSetForceSpeed(qd_dev, p, PORT_FORCE_SPEED_1000_MBPS) != MV_OK) {
+			printk(KERN_ERR "Force speed 1000mbps - Failed\n");
+			return -1;
+		}
+
+		if ((gpcsSetDpxValue(qd_dev, p, MV_TRUE) != MV_OK) ||
+		    (gpcsSetForcedDpx(qd_dev, p, MV_TRUE) != MV_OK)) {
+			printk(KERN_ERR "Force duplex FULL - Failed\n");
+			return -1;
+		}
+
+		if ((gpcsSetFCValue(qd_dev, p, MV_TRUE) != MV_OK) ||
+		    (gpcsSetForcedFC(qd_dev, p, MV_TRUE) != MV_OK)) {
+			printk(KERN_ERR "Force Flow Control - Failed\n");
+			return -1;
+		}
+
+		if ((gpcsSetLinkValue(qd_dev, p, MV_TRUE) != MV_OK) ||
+		    (gpcsSetForcedLink(qd_dev, p, MV_TRUE) != MV_OK)) {
+			printk(KERN_ERR "Force Link UP - Failed\n");
+			return -1;
+		}
+	}
+
+	/* set all ports not to unmodify the vlan tag on egress */
+	for (p = 0; p < MAX_SWITCH_PORT_NUM; p++) {
+		if (MV_BIT_CHECK(switch_ports_mask, p)) {
+			if (gprtSetEgressMode(qd_dev, p, GT_UNMODIFY_EGRESS) != MV_OK) {
+				printk(KERN_ERR "gprtSetEgressMode GT_UNMODIFY_EGRESS failed\n");
+				return -1;
+			}
+		}
+	}
+
+	/* initializes the PVT Table (cross-chip port based VLAN) to all one's (initial state) */
+	if (gpvtInitialize(qd_dev) != MV_OK) {
+		printk(KERN_ERR "gpvtInitialize failed\n");
+		return -1;
+	}
+
+	/* set all ports to work in Normal mode */
+	for (p = 0; p < MAX_SWITCH_PORT_NUM; p++) {
+		if (MV_BIT_CHECK(switch_ports_mask, p)) {
+			if (gprtSetFrameMode(qd_dev, p, GT_FRAME_MODE_NORMAL) != MV_OK) {
+				printk(KERN_ERR "gprtSetFrameMode GT_FRAME_MODE_NORMAL failed\n");
+				return -1;
+			}
+		}
+	}
+	
+	/* specific Switch initialization according to Switch ID */
+	switch (qd_dev->deviceId) {
+	case GT_88E6161:
+	case GT_88E6165:
+	case GT_88E6171:
+	case GT_88E6351:
+	case GT_88E6172:
+	case GT_88E6176:
+		/* set Header Mode in all ports to False */
+		for (p = 0; p < 5; p++) {
+ 			if (gprtSetHeaderMode(qd_dev, p, MV_FALSE) != MV_OK) {
+				printk(KERN_ERR "gprtSetHeaderMode MV_FALSE failed\n");
+				return -1;
+			}
+		}
+
+		if (gprtSetHeaderMode(qd_dev, 5, MV_FALSE) != MV_OK ||
+		    gprtSetHeaderMode(qd_dev, 6, MV_FALSE) != MV_OK) 
+		{
+			printk(KERN_ERR "gprtSetHeaderMode MV_TRUE failed\n");
+			return -1;
+		}
+
+		mv_switch_jumbo_mode_set( qd_dev, mtu);
+		break;
+
+	default:
+		printk(KERN_ERR "Unsupported Switch. Switch ID is 0x%X.\n", qd_dev->deviceId);
+		return -1;
+	}
+
+	/* The switch CPU port is not part of the VLAN, but rather connected by tunneling to each */
+	/* of the VLAN's ports. Our MAC addr will be added during start operation to the VLAN DB  */
+	/* at switch level to forward packets with this DA to CPU port.                           */
+	SWITCH_DBG(SWITCH_DBG_LOAD, ("Enabling Tunneling on ports: "));
+	for (p = 0; p < MAX_SWITCH_PORT_NUM; p++) {
+		if (MV_BIT_CHECK(switch_ports_mask, p) && (p != SWITCH_TO_CPU_WAN || p != SWITCH_TO_CPU_LAN)) {
+			if (gprtSetVlanTunnel(qd_dev, p, MV_TRUE) != MV_OK) {
+				printk(KERN_ERR "gprtSetVlanTunnel failed (port %d)\n", p);
+				return -1;
+			} else {
+				SWITCH_DBG(SWITCH_DBG_LOAD, ("%d ", p));
+			}
+		}
+	}
+	
+	SWITCH_DBG(SWITCH_DBG_LOAD, ("Disable 802.1Q VLAN on ports: "));
+	for (p = 0; p < MAX_SWITCH_PORT_NUM; p++) {
+		if (MV_BIT_CHECK(switch_ports_mask, p)) {
+	            gvlnSetPortVlanDot1qMode(qd_dev, p, GT_DISABLE);
+	        }
+	}
+	
+	/* set P5(RGMII0) and P0~3 as one VLAN */
+	if (gvlnSetPortVlanPortMask(qd_dev, SWITCH_TO_CPU_LAN, 0x0F) != MV_OK) {
+		printk(KERN_ERR "gvlnSetPortVlanPorts failed\n");
+		return -1;
+	}
+	
+	tmp = 1;
+	for (p=0; p< 4; p++) {
+	    if (gvlnSetPortVlanPortMask(qd_dev, p, 0x20 | (0x0F & (~tmp))) != MV_OK) {
+		printk(KERN_ERR "gvlnSetPortVlanPorts failed\n");
+		return -1;
+	    }
+	    
+	    tmp <<=1;
+	}
+	
+	/* Set P4 and P6(RGMII1) as another port-based VLAN (for WAN) */
+	if (gvlnSetPortVlanPortMask(qd_dev, SWITCH_TO_CPU_WAN, 0x10) != MV_OK) {
+		printk(KERN_ERR "gvlnSetPortVlanPorts failed\n");
+		return -1;
+	}
+	
+	if (gvlnSetPortVlanPortMask(qd_dev, 4, 0x40) != MV_OK) {
+		printk(KERN_ERR "gvlnSetPortVlanPorts failed\n");
+		return -1;
+	}	
+	
+
+	if (gfdbFlush(qd_dev, GT_FLUSH_ALL) != MV_OK)
+		printk(KERN_ERR "gfdbFlush failed\n");
+
+	/* Configure Ethernet related LEDs, currently according to Switch ID, do nothing for E61xx/63xx */
+
+	/* enable all relevant ports (ports connected to the MAC or external ports) */
+	for (p = 0; p < MAX_SWITCH_PORT_NUM; p++) {
+		if (MV_BIT_CHECK(switch_ports_mask, p))
+			if (gstpSetPortState(qd_dev, p, GT_PORT_FORWARDING) != MV_OK) {
+				printk(KERN_ERR "gstpSetPortState failed\n");
+	
+				return -1;
+			}
+	}
+
+	return 0;
+}
+
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/mv_switch.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/mv_switch.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/mv_switch.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/mv_switch.h	2014-04-10 13:41:22.000000000 +0700
@@ -0,0 +1,84 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#ifndef __mv_switch_h__
+#define __mv_switch_h__
+
+#include "dsdt/msApiDefs.h"
+
+#define MV_SWITCH_PHY_ACCESS			1
+#define MV_SWITCH_PORT_ACCESS			2
+#define MV_SWITCH_GLOBAL_ACCESS			3
+#define MV_SWITCH_GLOBAL2_ACCESS		4
+#define MV_SWITCH_SMI_ACCESS                	5
+
+/* define which Switch ports are relevant */
+#define SWITCH_CONNECTED_PORTS_MASK	0x7F
+#define MAX_SWITCH_PORT_NUM 	7
+#define SWITCH_TO_CPU_LAN	5
+#define SWITCH_TO_CPU_WAN	6
+
+#define G65G_ANY_PAGE 0x2040FFFF
+
+
+/* value (of 1 bit) to a boolean one.       */
+/* 0 --> MV_FALSE                           */
+/* 1 --> MV_TRUE                            */
+#define BIT_2_BOOL(binVal,boolVal)                                  \
+            (boolVal) = (((binVal) == 0) ? MV_FALSE : MV_TRUE)
+
+int     mv_switch_load(GT_QD_DEV *qd_dev, unsigned int switch_ports_mask);
+int     mv_switch_unload(unsigned int switch_ports_mask);
+int     mv_switch_init(int mtu, unsigned int switch_ports_mask);
+void    mv_switch_link_update_event(MV_U32 port_mask, int force_link_check);
+int     mv_switch_jumbo_mode_set(GT_QD_DEV *qd_dev, int max_size);
+int     mv_switch_tos_get(unsigned char tos);
+int     mv_switch_tos_set(unsigned char tos, int queue);
+int     mv_switch_port_based_vlan_set(unsigned int ports_mask, int set_cpu_port);
+int     mv_switch_vlan_in_vtu_set(unsigned short vlan_id, unsigned short db_num, unsigned int ports_mask);
+int     mv_switch_mac_addr_set(unsigned char *mac_addr, unsigned char db,
+			       unsigned int ports_mask, unsigned char op);
+int     mv_switch_atu_db_flush(int db_num);
+int     mv_eth_switch_vlan_set(MV_U16 vlan_grp_id, MV_U16 port_map, MV_U16 cpu_port);
+int     mv_switch_promisc_set(MV_U16 vlan_grp_id, MV_U16 port_map, MV_U16 cpu_port, MV_U8 promisc_on);
+unsigned int    mv_switch_link_detection_init(void);
+
+int 	mv_switch_reg_read(int port, int reg, int type, unsigned int *value);
+int 	mv_switch_reg_write(int port, int reg, int type, unsigned int value);
+void    mv_switch_stats_print(void);
+void    mv_switch_status_print(void);
+
+int     mv_switch_all_multicasts_del(int db_num);
+
+int     mv_switch_port_add(int switch_port, MV_U16 vlan_grp_id, MV_U16 port_map);
+int     mv_switch_port_del(int switch_port, MV_U16 vlan_grp_id, MV_U16 port_map);
+
+MV_STATUS mv_switch_mii_write_RegField( GT_QD_DEV *dev, unsigned int phy, unsigned int reg, unsigned char fieldOffset, unsigned char fieldLength, unsigned int data);
+MV_STATUS mv_switch_mii_read(GT_QD_DEV *dev, unsigned int phy, unsigned int reg, unsigned int *data);
+MV_STATUS mv_switch_mii_write(GT_QD_DEV *dev, unsigned int phy, unsigned int reg, unsigned int data);
+MV_STATUS mv_switch_mii_write_PhyPaged_RegField(GT_QD_DEV *dev, MV_U8 port, MV_U8 page, MV_U8 reg, MV_U8 offset, MV_U8 length, MV_U32 anyPage, MV_U16 data);
+#endif /* __mv_switch_h__ */
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/mv_switch_sysfs.c linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/mv_switch_sysfs.c
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/mv_switch_sysfs.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/mv_switch_sysfs.c	2014-04-14 16:24:08.000000000 +0700
@@ -0,0 +1,339 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+
+
+
+#include <linux/init.h>
+
+#include "common/mvTypes.h"
+#include "mv_switch.h"
+#include "dsdt/msApiPrototype.h"
+
+
+static ssize_t mv_switch_help(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "cat help                            - show this help\n");
+	off += sprintf(buf+off, "cat stats                           - show statistics for switch all ports info\n");
+	off += sprintf(buf+off, "cat status                          - show switch status\n");
+#ifdef CONFIG_MV_ETH_SWITCH
+	off += sprintf(buf+off, "echo <eth_name>   > netdev_sts      - print network device status\n");
+	off += sprintf(buf+off, "echo <eth_name> p > port_add        - map switch port to a network device\n");
+	off += sprintf(buf+off, "echo <eth_name> p > port_del        - unmap switch port from a network device\n");
+#endif /* CONFIG_MV_ETH_SWITCH */
+	off += sprintf(buf+off, "echo p r t   > reg_r                - read switch register.  t: 1-phy, 2-port, 3-global, 4-global2, 5-smi\n");
+	off += sprintf(buf+off, "echo p r t v > reg_w                - write switch register. t: 1-phy, 2-port, 3-global, 4-global2, 5-smi\n");
+	return off;
+}
+
+static ssize_t mv_switch_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	const char *name = attr->attr.name;
+	int off = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "stats")){
+		//mv_switch_stats_print();
+	}else if (!strcmp(name, "status")){
+		//mv_switch_status_print();
+	}else
+		off = mv_switch_help(buf);
+
+	return off;
+}
+
+static ssize_t mv_switch_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	unsigned long   flags;
+	int             err, port, reg, type;
+	unsigned int    v;
+	unsigned int    val;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read arguments */
+	err = port = reg = type = val = 0;
+	sscanf(buf, "%d %d %d %x", &port, &reg, &type, &v);
+
+	local_irq_save(flags);
+	if (!strcmp(name, "reg_r")) {
+		err = mv_switch_reg_read(port, reg, type, &val);
+	} else if (!strcmp(name, "reg_w")) {
+		val = (MV_U16)v;
+		err = mv_switch_reg_write(port, reg, type, v);
+	}
+	printk(KERN_ERR "switch register access: type=%d, port=%d, reg=%d", type, port, reg);
+
+	if (err)
+		printk(KERN_ERR " - FAILED, err=%d\n", err);
+	else
+		printk(KERN_ERR " - SUCCESS, val=0x%04x\n", val);
+
+	local_irq_restore(flags);
+
+	return err ? -EINVAL : len;
+}
+
+#ifdef CONFIG_MV_ETH_SWITCH
+static ssize_t mv_switch_netdev_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err = 0, port = 0;
+	char            dev_name[30];
+	struct net_device *netdev;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read arguments */
+	sscanf(buf, "%s %d", dev_name, &port);
+	netdev = dev_get_by_name(&init_net, dev_name);
+	if (netdev == NULL) {
+		err = 1;
+	} else {
+		if (!strcmp(name, "netdev_sts"))
+			mv_eth_netdev_print(netdev);
+		else if (!strcmp(name, "port_add"))
+			err = mv_eth_switch_port_add(netdev, port);
+		else if (!strcmp(name, "port_del"))
+			err = mv_eth_switch_port_del(netdev, port);
+
+		dev_put(netdev);
+	}
+
+	if (err)
+		printk(KERN_ERR " - FAILED, err=%d\n", err);
+	else
+		printk(KERN_ERR " - SUCCESS\n");
+
+	return err ? -EINVAL : len;
+}
+#endif /* CONFIG_MV_ETH_SWITCH */
+
+static DEVICE_ATTR(reg_r,       S_IWUSR, mv_switch_show, mv_switch_store);
+static DEVICE_ATTR(reg_w,       S_IWUSR, mv_switch_show, mv_switch_store);
+static DEVICE_ATTR(status,      S_IRUSR, mv_switch_show, mv_switch_store);
+static DEVICE_ATTR(stats,       S_IRUSR, mv_switch_show, mv_switch_store);
+static DEVICE_ATTR(help,        S_IRUSR, mv_switch_show, mv_switch_store);
+#ifdef CONFIG_MV_ETH_SWITCH
+static DEVICE_ATTR(netdev_sts,  S_IWUSR, mv_switch_show, mv_switch_netdev_store);
+static DEVICE_ATTR(port_add,    S_IWUSR, mv_switch_show, mv_switch_netdev_store);
+static DEVICE_ATTR(port_del,    S_IWUSR, mv_switch_show, mv_switch_netdev_store);
+#endif /* CONFIG_MV_ETH_SWITCH */
+
+static struct attribute *mv_switch_attrs[] = {
+	&dev_attr_reg_r.attr,
+	&dev_attr_reg_w.attr,
+	&dev_attr_status.attr,
+	&dev_attr_stats.attr,
+	&dev_attr_help.attr,
+#ifdef CONFIG_MV_ETH_SWITCH
+	&dev_attr_netdev_sts.attr,
+	&dev_attr_port_add.attr,
+	&dev_attr_port_del.attr,
+#endif /* CONFIG_MV_ETH_SWITCH */
+	NULL
+};
+
+static struct attribute_group mv_switch_group = {
+	.name = "switch",
+	.attrs = mv_switch_attrs,
+};
+
+static dev_t  base_dev;
+extern GT_QD_DEV qddev; 
+
+
+char* mv_str_speed_state(int port)
+{
+    GT_PORT_SPEED_MODE  speed;
+    char*               speed_str;
+
+    if(gprtGetSpeedMode(&qddev, port, &speed) != MV_OK) {
+	printk("gprtGetSpeedMode failed (port %d)\n", port);
+	speed_str = "ERR";
+    }
+    else
+    {
+        if (speed == PORT_SPEED_1000_MBPS)
+            speed_str = "1000Mbps";
+        else if (speed == PORT_SPEED_100_MBPS)
+            speed_str = "100Mbps";
+        else
+            speed_str = "10Mbps";
+    }
+    return speed_str;
+}
+
+char* mv_str_duplex_state(int port)
+{
+    MV_BOOL duplex;
+
+    if(gprtGetDuplex(&qddev, port, &duplex) != MV_OK) {
+        printk("gprtGetDuplex failed (port %d)\n", port);
+		return "ERR";
+	}
+    else 
+        return (duplex) ? "Full" : "Half";
+}
+
+
+char* mv_str_link_state(int port)
+{
+    MV_BOOL link;
+    
+    if(gprtGetLinkState(&qddev, port, &link) != MV_OK) {
+	    printk("gprtGetLinkState failed (port %d)\n", port);
+	    return "ERR";
+    }
+    else 
+        return (link) ? "Up" : "Down";
+}
+
+
+static ssize_t mv_carrier_show(struct device *dev, 
+			       struct device_attribute *attr, char *buf)
+{
+    int port_no = MINOR(dev->devt) - MINOR(base_dev);
+ 
+    if (!capable(CAP_NET_ADMIN))
+  	return -EPERM;
+   
+    strcpy(buf, mv_str_link_state(port_no));
+    return strlen(buf);
+}
+
+void mv_switch_port_power_set(int port, int updown)
+{
+    gprtPortPowerSet(&qddev, (GT_LPORT) port, (MV_BOOL) updown);
+}
+
+int mv_switch_port_power_get(int port)
+{
+    return gprtPortPowerGet(&qddev, (GT_LPORT) port);
+}
+
+
+static ssize_t mv_link_power_set(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t len)
+{
+    unsigned long state;
+    int port_no = MINOR(dev->devt) - MINOR(base_dev);
+ 
+    if (!capable(CAP_NET_ADMIN))
+  	return -EPERM;
+       
+    state = simple_strtoul(buf, NULL, 10);
+    mv_switch_port_power_set(port_no, state != 0);
+    return strlen(buf);
+}
+
+
+static ssize_t mv_link_power_show(struct device *dev,
+				  struct device_attribute *attr,
+				  char *buf)
+{
+    int port_no = MINOR(dev->devt) - MINOR(base_dev);
+ 
+    if (!capable(CAP_NET_ADMIN))
+  	return -EPERM;
+           
+    return sprintf(buf, "%d\n", mv_switch_port_power_get(port_no));
+}
+
+static struct device_attribute neta_switch[] = {
+	__ATTR(carrier, S_IRUGO, mv_carrier_show, NULL),
+//	__ATTR(speed, S_IRUGO, mv_speed_show, NULL),
+//	__ATTR(duplex, S_IRUGO, mv_duplex_show, NULL),
+	/*can not __ATTR(power) because linux default create the power, can not duplicate */
+	__ATTR(power_config, S_IRUSR | S_IWUSR, mv_link_power_show, mv_link_power_set),
+//  __ATTR(peer_mac_addresses, S_IRUGO, mv_mac_addr_show, NULL),
+	NULL
+};
+
+static struct class *neta_switch_class;
+
+int __devinit mv_switch_sysfs_init(void)
+{
+	int err, i;
+	struct device *pd;
+
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "neta");
+	if (!pd) {
+		platform_device_register_simple("neta", -1, NULL, 0);
+		pd = bus_find_device_by_name(&platform_bus_type, NULL, "neta");
+	}
+
+	if (!pd) {
+		printk(KERN_ERR "%s: cannot find neta device\n", __func__);
+		pd = &platform_bus;
+	}
+
+	err = sysfs_create_group(&pd->kobj, &mv_switch_group);
+	if (err) {
+		printk(KERN_INFO "sysfs group failed %d\n", err);
+		goto out;
+	}
+
+	err = alloc_chrdev_region(&base_dev, 0, 8, "neta-switch");
+	if (err)
+		printk(KERN_ERR "Allocate chrdev failed: %d\n", err);
+	else {
+		neta_switch_class = class_create(THIS_MODULE, "neta-switch");
+		neta_switch_class->dev_attrs = neta_switch;
+
+		for (i = 0; i < 8; ++i) {
+			device_create(neta_switch_class, pd,
+				      MKDEV(MAJOR(base_dev), MINOR(base_dev) + i),
+				      NULL, "port%d", i);
+		}
+	}	
+	
+out:
+	return err;
+}
+
+module_init(mv_switch_sysfs_init);
+
+MODULE_AUTHOR("Dima Epshtein");
+MODULE_DESCRIPTION("sysfs for Marvell switch");
+MODULE_LICENSE("GPL");
+
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/os/mvCommon.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/os/mvCommon.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/os/mvCommon.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/os/mvCommon.h	2014-04-14 16:24:42.000000000 +0700
@@ -0,0 +1,404 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCommonh
+#define __INCmvCommonh
+
+#ifdef __cplusplus
+extern "C" {
+#endif	/* __cplusplus */
+
+#include "../common/mvTypes.h"
+
+#ifndef MV_ASMLANGUAGE
+
+/* The golden ration: an arbitrary value */
+#define MV_JHASH_GOLDEN_RATIO           0x9e3779b9
+
+#define MV_JHASH_MIX(a, b, c)        \
+{                                   \
+    a -= b; a -= c; a ^= (c>>13);   \
+    b -= c; b -= a; b ^= (a<<8);    \
+    c -= a; c -= b; c ^= (b>>13);   \
+    a -= b; a -= c; a ^= (c>>12);   \
+    b -= c; b -= a; b ^= (a<<16);   \
+    c -= a; c -= b; c ^= (b>>5);    \
+    a -= b; a -= c; a ^= (c>>3);    \
+    b -= c; b -= a; b ^= (a<<10);   \
+    c -= a; c -= b; c ^= (b>>15);   \
+}
+
+static inline MV_U32 mv_jhash_3words(MV_U32 a, MV_U32 b, MV_U32 c, MV_U32 initval)
+{
+	a += MV_JHASH_GOLDEN_RATIO;
+	b += MV_JHASH_GOLDEN_RATIO;
+	c += initval;
+	MV_JHASH_MIX(a, b, c);
+
+	return c;
+}
+#endif
+
+
+/* Swap tool */
+
+/* 16bit nibble swap. For example 0x1234 -> 0x2143                          */
+#define MV_NIBBLE_SWAP_16BIT(X)        (((X&0xf) << 4) |     \
+					((X&0xf0) >> 4) |    \
+					((X&0xf00) << 4) |   \
+					((X&0xf000) >> 4))
+
+/* 32bit nibble swap. For example 0x12345678 -> 0x21436587                  */
+#define MV_NIBBLE_SWAP_32BIT(X)		(((X&0xf) << 4) |       \
+					((X&0xf0) >> 4) |      \
+					((X&0xf00) << 4) |     \
+					((X&0xf000) >> 4) |    \
+					((X&0xf0000) << 4) |   \
+					((X&0xf00000) >> 4) |  \
+					((X&0xf000000) << 4) | \
+					((X&0xf0000000) >> 4))
+
+/* 16bit byte swap. For example 0x1234->0x3412                             */
+#define MV_BYTE_SWAP_16BIT(X) ((((X)&0xff)<<8) | (((X)&0xff00)>>8))
+
+/* 32bit byte swap. For example 0x12345678->0x78563412                    */
+#define MV_BYTE_SWAP_32BIT(X)  ((((X)&0xff)<<24) |                       \
+				(((X)&0xff00)<<8) |                      \
+				(((X)&0xff0000)>>8) |                    \
+				(((X)&0xff000000)>>24))
+
+/* 64bit byte swap. For example 0x11223344.55667788 -> 0x88776655.44332211  */
+#define MV_BYTE_SWAP_64BIT(X) ((l64) ((((X)&0xffULL)<<56) |             \
+				      (((X)&0xff00ULL)<<40) |           \
+				      (((X)&0xff0000ULL)<<24) |         \
+				      (((X)&0xff000000ULL)<<8) |        \
+				      (((X)&0xff00000000ULL)>>8) |      \
+				      (((X)&0xff0000000000ULL)>>24) |   \
+				      (((X)&0xff000000000000ULL)>>40) | \
+				      (((X)&0xff00000000000000ULL)>>56)))
+
+/* Endianess macros.                                                        */
+#define MV_CPU_LE
+
+#if defined(MV_CPU_LE)
+#define MV_16BIT_LE(X)  (X)
+#define MV_32BIT_LE(X)  (X)
+#define MV_64BIT_LE(X)  (X)
+#define MV_16BIT_BE(X)  MV_BYTE_SWAP_16BIT(X)
+#define MV_32BIT_BE(X)  MV_BYTE_SWAP_32BIT(X)
+#define MV_64BIT_BE(X)  MV_BYTE_SWAP_64BIT(X)
+#elif defined(MV_CPU_BE)
+#define MV_16BIT_LE(X)  MV_BYTE_SWAP_16BIT(X)
+#define MV_32BIT_LE(X)  MV_BYTE_SWAP_32BIT(X)
+#define MV_64BIT_LE(X)  MV_BYTE_SWAP_64BIT(X)
+#define MV_16BIT_BE(X)  (X)
+#define MV_32BIT_BE(X)  (X)
+#define MV_64BIT_BE(X)  (X)
+#else
+#error "CPU endianess isn't defined!\n"
+#endif
+
+/* Bit field definitions */
+#define NO_BIT      0x00000000
+
+/* avoid redefinition of bits */
+#ifndef BIT0
+
+#define BIT0        0x00000001
+#define BIT1        0x00000002
+#define BIT2        0x00000004
+#define BIT3        0x00000008
+#define BIT4        0x00000010
+#define BIT5        0x00000020
+#define BIT6        0x00000040
+#define BIT7        0x00000080
+#define BIT8        0x00000100
+#define BIT9        0x00000200
+#define BIT10       0x00000400
+#define BIT11       0x00000800
+#define BIT12       0x00001000
+#define BIT13       0x00002000
+#define BIT14       0x00004000
+#define BIT15       0x00008000
+#define BIT16       0x00010000
+#define BIT17       0x00020000
+#define BIT18       0x00040000
+#define BIT19       0x00080000
+#define BIT20       0x00100000
+#define BIT21       0x00200000
+#define BIT22       0x00400000
+#define BIT23       0x00800000
+#define BIT24       0x01000000
+#define BIT25       0x02000000
+#define BIT26       0x04000000
+#define BIT27       0x08000000
+#define BIT28       0x10000000
+#define BIT29       0x20000000
+#define BIT30       0x40000000
+#define BIT31       0x80000000
+
+#endif /* BIT0 */
+/* Handy sizes */
+#define _1K         0x00000400
+#define _2K         0x00000800
+#define _4K         0x00001000
+#define _8K         0x00002000
+#define _16K        0x00004000
+#define _32K        0x00008000
+#define _64K        0x00010000
+#define _128K       0x00020000
+#define _256K       0x00040000
+#define _512K       0x00080000
+
+#define _1M         0x00100000
+#define _2M         0x00200000
+#define _4M         0x00400000
+#define _8M         0x00800000
+#define _16M        0x01000000
+#define _32M        0x02000000
+#define _64M        0x04000000
+#define _128M       0x08000000
+#define _256M       0x10000000
+#define _512M       0x20000000
+
+#define _1G         0x40000000
+#define _2G         0x80000000
+
+/* Tclock and Sys clock define */
+#define _100MHz     100000000
+#define _125MHz     125000000
+#define _133MHz     133333334
+#define _150MHz     150000000
+#define _160MHz     160000000
+#define _166MHz     166666667
+#define _175MHz     175000000
+#define _178MHz     178000000
+#define _183MHz     183333334
+#define _187MHz     187000000
+#define _192MHz     192000000
+#define _194MHz     194000000
+#define _200MHz     200000000
+#define _233MHz     233333334
+#define _250MHz     250000000
+#define _266MHz     266666667
+#define _300MHz     300000000
+
+/* Supported clocks */
+#define MV_BOARD_TCLK_100MHZ	100000000
+#define MV_BOARD_TCLK_125MHZ	125000000
+#define MV_BOARD_TCLK_133MHZ	133333333
+#define MV_BOARD_TCLK_150MHZ	150000000
+#define MV_BOARD_TCLK_166MHZ	166666667
+#define MV_BOARD_TCLK_200MHZ	200000000
+#define MV_BOARD_TCLK_250MHZ	250000000
+
+#define MV_BOARD_SYSCLK_100MHZ	100000000
+#define MV_BOARD_SYSCLK_125MHZ	125000000
+#define MV_BOARD_SYSCLK_133MHZ	133333333
+#define MV_BOARD_SYSCLK_150MHZ	150000000
+#define MV_BOARD_SYSCLK_166MHZ	166666667
+#define MV_BOARD_SYSCLK_200MHZ	200000000
+#define MV_BOARD_SYSCLK_233MHZ	233333333
+#define MV_BOARD_SYSCLK_250MHZ	250000000
+#define MV_BOARD_SYSCLK_267MHZ	266666667
+#define MV_BOARD_SYSCLK_300MHZ	300000000
+#define MV_BOARD_SYSCLK_333MHZ	333333334
+#define MV_BOARD_SYSCLK_400MHZ	400000000
+
+#define MV_BOARD_REFCLK_25MHZ	 25000000
+
+/* For better address window table readability */
+#define EN			MV_TRUE
+#define DIS			MV_FALSE
+#define N_A			-1	/* Not applicable */
+
+/* Cache configuration options for memory (DRAM, SRAM, ... ) */
+
+/* Memory uncached, HW or SW cache coherency is not needed */
+#define MV_UNCACHED             0
+/* Memory cached, HW cache coherency supported in WriteThrough mode */
+#define MV_CACHE_COHER_HW_WT    1
+/* Memory cached, HW cache coherency supported in WriteBack mode */
+#define MV_CACHE_COHER_HW_WB    2
+/* Memory cached, No HW cache coherency, Cache coherency must be in SW */
+#define MV_CACHE_COHER_SW       3
+
+/* Macro for testing aligment. Positive if number is NOT aligned   */
+#define MV_IS_NOT_ALIGN(number, align)      ((number) & ((align) - 1))
+
+/* Macro for alignment up. For example, MV_ALIGN_UP(0x0330, 0x20) = 0x0340   */
+#define MV_ALIGN_UP(number, align)                                          \
+(((number) & ((align) - 1)) ? (((number) + (align)) & ~((align)-1)) : (number))
+
+/* Macro for alignment down. For example, MV_ALIGN_UP(0x0330, 0x20) = 0x0320 */
+#define MV_ALIGN_DOWN(number, align) ((number) & ~((align)-1))
+
+/* This macro returns absolute value                                        */
+#define MV_ABS(number)  (((int)(number) < 0) ? -(int)(number) : (int)(number))
+
+/* Bit fields manipulation macros                                           */
+
+/* An integer word which its 'x' bit is set                                 */
+#define MV_BIT_MASK(bitNum)         (1 << (bitNum))
+
+/* Checks wheter bit 'x' in integer word is set                             */
+#define MV_BIT_CHECK(word, bitNum)  ((word) & MV_BIT_MASK(bitNum))
+
+/* Clear (reset) bit 'x' in integer word (RMW - Read-Modify-Write)          */
+#define MV_BIT_CLEAR(word, bitNum)  ((word) &= ~(MV_BIT_MASK(bitNum)))
+
+/* Set bit 'x' in integer word (RMW)                                        */
+#define MV_BIT_SET(word, bitNum)    ((word) |= MV_BIT_MASK(bitNum))
+
+/* Invert bit 'x' in integer word (RMW)                                     */
+#define MV_BIT_INV(word, bitNum)    ((word) ^= MV_BIT_MASK(bitNum))
+
+/* The following macro converts a boolean   */
+/* value to a binary one (of 1 bit).        */
+/* MV_FALSE --> 0                           */
+/* MV_TRUE --> 1                            */
+#define BOOL_2_BIT(boolVal,binVal)                                  \
+            (binVal) = (((boolVal) == MV_TRUE) ? 1 : 0)
+
+/* Get the min between 'a' or 'b'                                           */
+#define MV_MIN(a, b)    (((a) < (b)) ? (a) : (b))
+
+/* Get the max between 'a' or 'b'                                           */
+#define MV_MAX(a, b)    (((a) < (b)) ? (b) : (a))
+
+#define mvOsDivide(num, div)	\
+({				\
+	int i = 0, rem = (num);	\
+	while (rem >= (div)) {	\
+		rem -= (div);	\
+		i++;		\
+	}			\
+	(i);			\
+})
+
+#define mvOsReminder(num, div)	\
+({				\
+	int rem = (num);	\
+	while (rem >= (div))	\
+		rem -= (div);	\
+	(rem);			\
+})
+
+#define MV_MACQUAD_FMT "%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x"
+
+#define MV_MACQUAD(addr) \
+	((unsigned char *)addr)[0], \
+	((unsigned char *)addr)[1], \
+	((unsigned char *)addr)[2], \
+	((unsigned char *)addr)[3], \
+	((unsigned char *)addr)[4], \
+	((unsigned char *)addr)[5]
+
+#define MV_IPQUAD_FMT         "%u.%u.%u.%u"
+#define MV_IPQUAD(ip)         ip[0], ip[1], ip[2], ip[3]
+
+#define MV_IP_QUAD(ipAddr)    ((ipAddr >> 24) & 0xFF), ((ipAddr >> 16) & 0xFF), \
+				((ipAddr >> 8) & 0xFF), ((ipAddr >> 0) & 0xFF)
+
+#define MV_IP6_FMT		"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x"
+#define MV_IP6_ARG(L3)		L3[0], L3[1], L3[2], L3[3],	\
+				L3[4], L3[5], L3[6], L3[7],	\
+				L3[8], L3[9], L3[10], L3[11],	\
+				L3[12], L3[13], L3[14], L3[15]
+
+#define MV_IS_POWER_OF_2(num) ((num != 0) && ((num & (num - 1)) == 0))
+
+#define MV_GET_BIT(word, bitNum) (((word) & (1 << (bitNum))) >> (bitNum))
+
+#define MV_SET_BIT(word, bitNum, bitVal) (((word) & ~(1 << (bitNum))) | (bitVal << bitNum))
+
+#define MV_ARRAY_SIZE(a)                    ((sizeof(a)) / (sizeof(a[0])))
+
+#ifndef MV_ASMLANGUAGE
+/* mvCommon API list */
+
+int mvCharToHex(char ch);
+int mvCharToDigit(char ch);
+
+MV_VOID mvHexToBin(const char *pHexStr, MV_U8 *pBin, int size);
+void mvAsciiToHex(const char *asciiStr, char *hexStr);
+void mvBinToHex(const MV_U8 *bin, char *hexStr, int size);
+void mvBinToAscii(const MV_U8 *bin, char *asciiStr, int size);
+
+MV_STATUS mvMacStrToHex(const char *macStr, MV_U8 *macHex);
+MV_STATUS mvMacHexToStr(MV_U8 *macHex, char *macStr);
+void mvSizePrint(MV_U64);
+
+MV_U32 mvLog2(MV_U32 num);
+
+MV_STATUS mvWinOverlapTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+MV_STATUS mvWinWithinWinTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+
+#endif /* MV_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif	/* __cplusplus */
+
+#endif /* __INCmvCommonh */
diff -rupN ./linux-3.10.32/drivers/net/ethernet/marvell/switch/os/mvOs.h linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/os/mvOs.h
--- ./linux-3.10.32/drivers/net/ethernet/marvell/switch/os/mvOs.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-3.10.32.switch/drivers/net/ethernet/marvell/switch/os/mvOs.h	2014-04-08 19:54:16.000000000 +0700
@@ -0,0 +1,334 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#ifndef _WNC_MV_OS_LNX_H_
+#define _WNC_MV_OS_LNX_H_
+
+#ifdef __KERNEL__
+/* for kernel space */
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/reboot.h>
+#include <linux/pci.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
+#include <linux/blkdev.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/seq_file.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/hardirq.h>
+#include <asm/dma.h>
+#include <asm/io.h>
+
+#include <linux/random.h>
+
+#include <asm/../../mach-mvebu/armada-370-xp.h>
+
+extern void mv_early_printk(char *fmt, ...);
+
+#define MV_ASM              __asm__ __volatile__
+#define INLINE              inline
+#define _INIT				__init
+#define MV_TRC_REC	        TRC_REC
+#define mvOsPrintf          printk
+#define mvOsEarlyPrintf	    mv_early_printk
+#define mvOsOutput          printk
+#define mvOsSPrintf         sprintf
+#define mvOsMalloc(_size_)  kmalloc(_size_, GFP_ATOMIC)
+#define mvOsFree            kfree
+#define mvOsMemcpy          memcpy
+#define mvOsMemset          memset
+#define mvOsSleep(_mils_)   mdelay(_mils_)
+#define mvOsTaskLock()
+#define mvOsTaskUnlock()
+#define strtol              simple_strtoul
+#define mvOsDelay(x)        mdelay(x)
+#define mvOsUDelay(x)       udelay(x)
+#define mvCopyFromOs        copy_from_user
+#define mvCopyToOs          copy_to_user
+#define mvOsWarning()       WARN_ON(1)
+#define mvOsGetTicks()      jiffies
+#define mvOsGetTicksFreq()  HZ
+
+#include "../common/mvTypes.h"
+#include "mvCommon.h"
+
+
+#ifdef MV_NDEBUG
+#define mvOsAssert(cond)
+#else
+#define mvOsAssert(cond) { do { if (!(cond)) { BUG(); } } while (0); }
+#endif /* MV_NDEBUG */
+
+#else /* __KERNEL__ */
+
+/* for user space applications */
+#include <stdlib.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+
+#define INLINE inline
+#define mvOsPrintf printf
+#define mvOsOutput printf
+#define mvOsMalloc(_size_) malloc(_size_)
+#define mvOsFree free
+#define mvOsAssert(cond) assert(cond)
+
+#endif /* __KERNEL__ */
+
+
+#define mvOsIoVirtToPhy(pDev, pVirtAddr)        virt_to_dma((pDev), (pVirtAddr))
+/*    pci_map_single((pDev), (pVirtAddr), 0, PCI_DMA_BIDIRECTIONAL) */
+
+#define mvOsIoVirtToPhys(pDev, pVirtAddr)       virt_to_dma((pDev), (pVirtAddr))
+
+#define mvOsCacheFlushInv(pDev, p, size)                            \
+	pci_map_single((pDev), (p), (size), PCI_DMA_BIDIRECTIONAL)
+/*
+ * This was omitted because as of 2.6.35 the Biderection performs only
+ * flush for outer cache because of the speculative issues.
+ * This should be replaced by Flush then invalidate
+ *
+#define mvOsCacheClear(pDev, p, size )                              \
+	pci_map_single((pDev), (p), (size), PCI_DMA_BIDIRECTIONAL)
+*/
+
+#define mvOsCacheFlush(pDev, p, size)                              \
+	pci_map_single((pDev), (p), (size), PCI_DMA_TODEVICE)
+
+#define mvOsCacheInvalidate(pDev, p, size)                          \
+	pci_map_single((pDev), (p), (size), PCI_DMA_FROMDEVICE)
+
+#define mvOsCacheUnmap(pDev, phys, size)                          \
+	pci_unmap_single((pDev), (dma_addr_t)(phys), (size), PCI_DMA_FROMDEVICE)
+
+#define CPU_PHY_MEM(x)              (MV_U32)x
+#define CPU_MEMIO_CACHED_ADDR(x)    (void *)x
+#define CPU_MEMIO_UNCACHED_ADDR(x)  (void *)x
+
+
+/* CPU architecture dependent 32, 16, 8 bit read/write IO addresses */
+#define MV_MEMIO32_WRITE(addr, data)    \
+	((*((volatile unsigned int *)(addr))) = ((unsigned int)(data)))
+
+#define MV_MEMIO32_READ(addr)           \
+	((*((volatile unsigned int *)(addr))))
+
+#define MV_MEMIO16_WRITE(addr, data)    \
+	((*((volatile unsigned short *)(addr))) = ((unsigned short)(data)))
+
+#define MV_MEMIO16_READ(addr)           \
+	((*((volatile unsigned short *)(addr))))
+
+#define MV_MEMIO8_WRITE(addr, data)     \
+	((*((volatile unsigned char *)(addr))) = ((unsigned char)(data)))
+
+#define MV_MEMIO8_READ(addr)            \
+	((*((volatile unsigned char *)(addr))))
+
+
+/* No Fast Swap implementation (in assembler) for ARM */
+#define MV_32BIT_LE_FAST(val)            MV_32BIT_LE(val)
+#define MV_16BIT_LE_FAST(val)            MV_16BIT_LE(val)
+#define MV_32BIT_BE_FAST(val)            MV_32BIT_BE(val)
+#define MV_16BIT_BE_FAST(val)            MV_16BIT_BE(val)
+
+/* 32 and 16 bit read/write in big/little endian mode */
+
+/* 16bit write in little endian mode */
+#define MV_MEMIO_LE16_WRITE(addr, data) \
+	MV_MEMIO16_WRITE(addr, MV_16BIT_LE_FAST(data))
+
+/* 16bit read in little endian mode */
+static inline MV_U16 MV_MEMIO_LE16_READ(MV_U32 addr)
+{
+	MV_U16 data;
+
+	data = (MV_U16)MV_MEMIO16_READ(addr);
+
+	return (MV_U16)MV_16BIT_LE_FAST(data);
+}
+
+/* 32bit write in little endian mode */
+#define MV_MEMIO_LE32_WRITE(addr, data) \
+	MV_MEMIO32_WRITE(addr, MV_32BIT_LE_FAST(data))
+
+/* 32bit read in little endian mode */
+static inline MV_U32 MV_MEMIO_LE32_READ(MV_U32 addr)
+{
+	MV_U32 data;
+
+	data = (MV_U32)MV_MEMIO32_READ(addr);
+
+	return (MV_U32)MV_32BIT_LE_FAST(data);
+}
+
+static inline void mvOsBCopy(char *srcAddr, char *dstAddr, int byteCount)
+{
+	while (byteCount != 0) {
+		*dstAddr = *srcAddr;
+		dstAddr++;
+		srcAddr++;
+		byteCount--;
+	}
+}
+
+static INLINE MV_U64 mvOsDivMod64(MV_U64 divided, MV_U64 divisor, MV_U64 *modulu)
+{
+	MV_U64  division = 0;
+
+	if (divisor == 1)
+		return divided;
+
+	while (divided >= divisor) {
+		division++;
+		divided -= divisor;
+	}
+	if (modulu != NULL)
+		*modulu = divided;
+
+	return division;
+}
+
+#if defined(MV_BRIDGE_SYNC_REORDER)
+extern MV_U32 *mvUncachedParam;
+
+static inline void mvOsBridgeReorderWA(void)
+{
+	volatile MV_U32 val = 0;
+
+	val = mvUncachedParam[0];
+}
+#endif
+
+
+/* Flush CPU pipe */
+#define CPU_PIPE_FLUSH
+
+
+
+/* register manipulations  */
+
+/******************************************************************************
+* This debug function enable the write of each register that u-boot access to
+* to an array in the DRAM, the function record only MV_REG_WRITE access.
+* The function could not be operate when booting from flash.
+* In order to print the array we use the printreg command.
+******************************************************************************/
+/* #define REG_DEBUG */
+#if defined(REG_DEBUG)
+extern int reg_arry[2048][2];
+extern int reg_arry_index;
+#endif
+
+/* Marvell controller register read/write macros */
+#define MV_REG_VALUE(offset)          \
+	(MV_MEMIO32_READ((ARMADA_370_XP_INTER_REGS_BASE | (offset)))) //INTER_REGS_BASE
+
+#define MV_REG_READ(offset)             \
+	(MV_MEMIO_LE32_READ(ARMADA_370_XP_INTER_REGS_BASE | (offset)))
+
+#if defined(REG_DEBUG)
+#define MV_REG_WRITE(offset, val)    \
+	MV_MEMIO_LE32_WRITE((ARMADA_370_XP_INTER_REGS_BASE | (offset)), (val)); \
+	{ \
+		reg_arry[reg_arry_index][0] = (ARMADA_370_XP_INTER_REGS_BASE | (offset));\
+		reg_arry[reg_arry_index][1] = (val);\
+		reg_arry_index++;\
+	}
+#else
+#define MV_REG_WRITE(offset, val)    \
+	MV_MEMIO_LE32_WRITE((ARMADA_370_XP_INTER_REGS_BASE | (offset)), (val))
+#endif
+
+#define MV_REG_BYTE_READ(offset)        \
+	(MV_MEMIO8_READ((ARMADA_370_XP_INTER_REGS_BASE | (offset))))
+
+#if defined(REG_DEBUG)
+#define MV_REG_BYTE_WRITE(offset, val)  \
+	MV_MEMIO8_WRITE((ARMADA_370_XP_INTER_REGS_BASE | (offset)), (val)); \
+	{ \
+		reg_arry[reg_arry_index][0] = (ARMADA_370_XP_INTER_REGS_BASE | (offset));\
+		reg_arry[reg_arry_index][1] = (val);\
+		reg_arry_index++;\
+	}
+#else
+#define MV_REG_BYTE_WRITE(offset, val)  \
+	MV_MEMIO8_WRITE((ARMADA_370_XP_INTER_REGS_BASE | (offset)), (val))
+#endif
+
+#if defined(REG_DEBUG)
+#define MV_REG_BIT_SET(offset, bitMask)                 \
+	(MV_MEMIO32_WRITE((ARMADA_370_XP_INTER_REGS_BASE | (offset)), \
+	(MV_MEMIO32_READ(ARMADA_370_XP_INTER_REGS_BASE | (offset)) | \
+	MV_32BIT_LE_FAST(bitMask)))); \
+	{ \
+		reg_arry[reg_arry_index][0] = (ARMADA_370_XP_INTER_REGS_BASE | (offset));\
+		reg_arry[reg_arry_index][1] = (MV_MEMIO32_READ(ARMADA_370_XP_INTER_REGS_BASE | (offset)));\
+		reg_arry_index++;\
+	}
+#else
+#define MV_REG_BIT_SET(offset, bitMask)                 \
+	(MV_MEMIO32_WRITE((ARMADA_370_XP_INTER_REGS_BASE | (offset)), \
+	(MV_MEMIO32_READ(ARMADA_370_XP_INTER_REGS_BASE | (offset)) | \
+	MV_32BIT_LE_FAST(bitMask))))
+#endif
+
+#if defined(REG_DEBUG)
+#define MV_REG_BIT_RESET(offset, bitMask)                \
+	(MV_MEMIO32_WRITE((ARMADA_370_XP_INTER_REGS_BASE | (offset)), \
+	(MV_MEMIO32_READ(ARMADA_370_XP_INTER_REGS_BASE | (offset)) & \
+	MV_32BIT_LE_FAST(~bitMask)))); \
+	{ \
+		reg_arry[reg_arry_index][0] = (ARMADA_370_XP_INTER_REGS_BASE | (offset));\
+		reg_arry[reg_arry_index][1] = (MV_MEMIO32_READ(ARMADA_370_XP_INTER_REGS_BASE | (offset)));\
+		reg_arry_index++;\
+	}
+#else
+#define MV_REG_BIT_RESET(offset, bitMask)                \
+	(MV_MEMIO32_WRITE((ARMADA_370_XP_INTER_REGS_BASE | (offset)), \
+	(MV_MEMIO32_READ(ARMADA_370_XP_INTER_REGS_BASE | (offset)) & \
+	MV_32BIT_LE_FAST(~bitMask))))
+#endif
+
+
+#endif /* _WNC_MV_OS_LNX_H_ */
+
+
diff -rupN ./linux-3.10.32/include/linux/init.h linux-3.10.32.switch/include/linux/init.h
--- ./linux-3.10.32/include/linux/init.h	2014-02-23 03:41:54.000000000 +0700
+++ linux-3.10.32.switch/include/linux/init.h	2014-04-14 15:33:34.000000000 +0700
@@ -93,6 +93,14 @@
 
 #define __exit          __section(.exit.text) __exitused __cold notrace
 
+/* Used for HOTPLUG */
+#define __devinit        __section(.devinit.text) __cold notrace
+#define __devinitdata    __section(.devinit.data)
+#define __devinitconst   __section(.devinit.rodata)
+#define __devexit        __section(.devexit.text) __exitused __cold notrace
+#define __devexitdata    __section(.devexit.data)
+#define __devexitconst   __section(.devexit.rodata)
+
 /* Used for HOTPLUG_CPU */
 #define __cpuinit        __section(.cpuinit.text) __cold notrace
 #define __cpuinitdata    __section(.cpuinit.data)
